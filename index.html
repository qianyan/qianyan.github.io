<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qianyan.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Senior Consultant | DevOps Master | Blockchain &amp; Web3 Specialist">
<meta property="og:type" content="website">
<meta property="og:title" content="鄢倩">
<meta property="og:url" content="https://qianyan.github.io/index.html">
<meta property="og:site_name" content="鄢倩">
<meta property="og:description" content="Senior Consultant | DevOps Master | Blockchain &amp; Web3 Specialist">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ryan Qian">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://qianyan.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>鄢倩</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">鄢倩</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">(conj clojurians me)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ryan Qian</p>
  <div class="site-description" itemprop="description">Senior Consultant | DevOps Master | Blockchain & Web3 Specialist</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/qianyan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qianyan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qianyan.lambda@gmail.com" title="E-Mail → mailto:qianyan.lambda@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/3672207020" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;3672207020" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/_qian_yan" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;_qian_yan" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://lambdaisland.com/blog" title="https:&#x2F;&#x2F;lambdaisland.com&#x2F;blog" rel="noopener" target="_blank">Lambdaisland</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.youtube.com/@SystemCrafters" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;@SystemCrafters" rel="noopener" target="_blank">System Crafters</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://aphyr.com/" title="https:&#x2F;&#x2F;aphyr.com" rel="noopener" target="_blank">Aphyr</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://bucharestfp.ro/" title="http:&#x2F;&#x2F;bucharestfp.ro" rel="noopener" target="_blank">Bucharest FP</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://blog.rlmflores.me/" title="http:&#x2F;&#x2F;blog.rlmflores.me&#x2F;" rel="noopener" target="_blank">Rodrigo Flores</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://seancorfield.github.io/" title="https:&#x2F;&#x2F;seancorfield.github.io&#x2F;" rel="noopener" target="_blank">Seancorfield</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2024/09/01/A-Guided-Tour-of-Functional-Design-Part-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ryan Qian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鄢倩">
      <meta itemprop="description" content="Senior Consultant | DevOps Master | Blockchain & Web3 Specialist">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 鄢倩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/01/A-Guided-Tour-of-Functional-Design-Part-3/" class="post-title-link" itemprop="url">函数式设计导读系列（三）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-01 21:57:56" itemprop="dateCreated datePublished" datetime="2024-09-01T21:57:56+08:00">2024-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 12:13:24" itemprop="dateModified" datetime="2025-06-25T12:13:24+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Clojure/" itemprop="url" rel="index"><span itemprop="name">Clojure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Neal Ford 在《函数式编程思想》（Functional Thinking）中提到面向对象编程是通过封装可变因素控制复杂性（makes code understandable），而函数式编程是通过消除可变因素控制复杂性的。</p>
<h2 id="封装和消除，哪种好理解？"><a href="#封装和消除，哪种好理解？" class="headerlink" title="封装和消除，哪种好理解？"></a>封装和消除，哪种好理解？</h2><p>封装是为了构造抽象屏障（Abstract Barrier），到达隐藏信息的目的。任何编程范式都不会缺少封装，因为这是人类简化理解事物的方式。只不过在面向对象编程语言中，封装、继承和多态（polymorphism）被拔到了一种必须充分理解的高度，而 Bob 在函数式设计中挑明了态度，他认为多态比其他两者高出一筹。原因在于进行高层次策略设计时，多态是调整依赖关系行之有效的方法。我认为他说得有一定道理，但是弱化封装这个性质倒和他的中心思想相背离，因为在这本书里，面向对象的封装和函数式的消除是棋逢对手的关键性质，费点笔墨解释清楚，很有必要。</p>
<p>Bob 大叔在第五章里列举了两段伪代码，如下。</p>
<p><img src="/images/image_1725192315571_0.png" alt="image.png">{:height 442, :width 780}</p>
<p><img src="/images/image_1725192327717_0.png" alt="image.png"></p>
<p>如果你看过我之前写的文章，不难理解这里发生了什么，无非用尾递归消除了 x 的赋值。在 Bob 大叔的眼中，赋值等同于可变性。所以，函数式设计的精髓就是消除可变性。</p>
<p>可是，除了赋值，第一段程序跟封装有什么关系呢？别急，我们稍微重构一下它。</p>
<p><img src="/images/refactor-f_1725194242935_0.png" alt="refactor-f.png"></p>
<p><img src="/images/refactor-getInput_1725194265652_0.png" alt="refactor-getInput.png"></p>
<p><img src="/images/refactor-getInput-f_1725194285148_0.png" alt="refactor-getInput-f.png"></p>
<p><code>Input x</code> 是一个对象，所以我们就把所有依赖其本身的行为通通封装进它的体内，希望你能感受到封装的力量。这里面有一点洞察，面向对象尽量会把行为放进对象体内，以符合数据内聚性的需要。也因此，对象的状态会原地改变，相当于赋值。</p>
<p>函数式则不然，它的状态无法原地改变，也就意味着它必须以递归或管道的方式自旋或流动起来，那些状态就保持在不可变的外部数据结构当中。</p>
<p>所以 Bob 大叔下了个结论：在状态可变的语言中，行为流过了对象；而在函数式语言中，对象流过行为。</p>
<p>行为流过对象，指的是行为在对象中迭代发生；而对象流过行为则是说行为在对象外顺序发生。或者说面向对象中的赋值（状态变化）在对象里发生，而函数式中的状态变化在对象外发生。所以从做事的横向流程上看，函数式更加清爽明了。而纵向结构上，面向对象则更加边界清晰，粒度合适。究其原因，函数式是一种“以终为始”的思考方式，其定义的每个阶段的产物都是比较完整的；而面向对象则是子问题划分，在子问题中寻求差异化解决方案。</p>
<h2 id="函数式编程的过程与结构"><a href="#函数式编程的过程与结构" class="headerlink" title="函数式编程的过程与结构"></a>函数式编程的过程与结构</h2><p>函数式编程是一种管道式的编程风格，Bob 大叔说它更像是铺设和修改数据流的管道，管道中的每道工序更像是包含尾递归的状态转移。</p>
<p><img src="/images/image_1725195520043_0.png" alt="image.png"></p>
<p>如果转化成 Clojure 代码，就像是用上了 Thread 宏的管道风格。</p>
<p><img src="/images/image_1725195834338_0.png" alt="image.png"></p>
<p>数据起源于物理世界，从一头流向另一头，最后汇入到有副作用的物理世界。</p>
<h2 id="控制住复杂性？"><a href="#控制住复杂性？" class="headerlink" title="控制住复杂性？"></a>控制住复杂性？</h2><p>没有那么简单。回到最初的原则，编程范式是对编程方式的规范和约束，而方法的孰优孰劣取决于问题的规模和复杂性，也取决于方法固有的复杂性。遇到非状态机（随时序变化）的问题时，两种方法差异不大；遇到状态机的问题，就要根据规模和复杂度琢磨一下。后续，我们在深入对比分析。</p>
<p>大家好，我是鄢倩，我是 Bob 大叔的《架构整洁之道》中文版的技术审校，也是他的扛鼎之作《敏捷软件开发：原则、模式和实践》重制版的译者。当然，再次有幸参与了大叔的新作《函数式设计》的技术审校，我非常高兴能在这里和大家分享我在审校过程中所学所想。</p>
<p><img src="/images/111724213567_.pic_1725196634793_0.jpg" alt="111724213567_.pic.jpg"></p>
<p><img src="/images/FD_%E5%8F%91%E5%B8%83%E4%BC%9A_1725196725606_0.jpeg" alt="FD 发布会.jpeg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2024/08/20/A-Guided-Tour-of-Functional-Design-Part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ryan Qian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鄢倩">
      <meta itemprop="description" content="Senior Consultant | DevOps Master | Blockchain & Web3 Specialist">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 鄢倩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/20/A-Guided-Tour-of-Functional-Design-Part-2/" class="post-title-link" itemprop="url">函数式设计导读系列（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-20 15:39:39" itemprop="dateCreated datePublished" datetime="2024-08-20T15:39:39+08:00">2024-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 12:11:58" itemprop="dateModified" datetime="2025-06-25T12:11:58+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Clojure/" itemprop="url" rel="index"><span itemprop="name">Clojure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="有限与无限的游戏"><a href="#有限与无限的游戏" class="headerlink" title="有限与无限的游戏"></a>有限与无限的游戏</h2><p>美国哲学家詹姆斯·卡斯写过一本书《有限与无限的游戏》，向我们展示了世界上至少有两种类型的“游戏”。有限的游戏，具有明确的开始和结束，其目的在于赢得胜利；无限的游戏，没有固定的开始和结束，旨在让游戏永远进行下去。有限的游戏在边界内玩，无限的游戏玩的就是边界。</p>
<p>Bob 大叔在解释函数式的惰性时，翻出了那款经典的保龄球游戏。今时不同往日，他玩起了无限的游戏。</p>
<p>我们先把保龄球的游戏规则过目一遍，头脑中有个怎么玩的印象就好。</p>
<blockquote>
<p>保龄球每个玩家每局有 10 个计分格(frame)。每个计分格玩家最多有 2 次投球(roll)机会，但第 10 个计分格最多有 3 次投球机会。每个计分格的得分，是击倒的球瓶总数，再加上全中(strike)或补中(spare)的奖励分。全中，指第一球就击倒了所有 10 个球瓶；得分为 10 分，再加上接下来的 2 次投球（属于下一个或之后的计分格）所击倒的球瓶数。补中，指在一个计分格中，用两次投球才击倒所有 10 个球瓶；得分为 10 分，再加上接下来的 1次投球（属于下一个计分格）所击倒的球瓶数。第 10 个计分格有点不同。如果在第 10 个计分格投出全中或补中，则能获得额外的投球机会来完成这个计分格；如果是全中，能获得 2 次额外投球；如果是补中，则能获得 1 次额外投球。这些额外的投球，只用于计算第 10 个计分格的得分。</p>
</blockquote>
<p><img src="/images/BowlingGameJava_1724129511036_0.png" alt="BowlingGameJava.png"></p>
<p>在上面 Java 版本的代码中，几乎是无意识地，我们把得分计算 <code>score +=</code>和投球的次序 <code>frameIndex++</code>揉到了一处。这是自然思考的结果，因为累积 <code>frameIndex</code> 就重现了投球的时序，得分跟着时序在规则（isStrike, isSpare?）的安排下一步步累加。但是事实上，因为不得不识别出影响每个计分格的所有投球，真正时序耦合的是 frameIndex 和当前计分格的得分计算，而不是总得分。所以，这段代码可以重构下，将总得分的计算放到了最后。</p>
<p><img src="/images/BowlingGameRefactorJava_1724135770353_0.png" alt="BowlingGameRefactorJava.png"></p>
<p>重构方式很简单，新增一个 scoresInEachFrame 列表，把每一个计分格的得分加进去，最后做求和。</p>
<p>这样的代码几乎可以很容易地写成像下面一样 Clojure 的 <code>loop...recur</code> 形式。</p>
<p><img src="/images/BowlingGameRefactorClj_1724135788478_0.png" alt="BowlingGameRefactorClj.png"></p>
<p>转换成这种形式之后，我们至少能知道两件事情。第一，frameIndex 这类索引让代码显得很难读；第二，frame 这是个控制量，它不参与实际的计分运算。</p>
<p>对于第一种坏味道，我们可以用列表的解构来解决。这里面凸显一种思想，新的列表是从旧的列表演变出来的，正如 map 函数所做的那样。</p>
<p><img src="/images/BowlingGameFramesClj_1724136529276_0.png" alt="BowlingGameFramesClj.png">{:height 437, :width 476}</p>
<p>代码中 <code>(loop [remaining-rolls frames]...)</code>正是这种思想的延续，在每次递归调用中，remaining-rolls 减少了，而 frames 增加了，它们之间的演化（映射）逻辑就是游戏的计分规则（Strike等）。当然，这段代码和上面的代码并不等价，原因是它没有提前计算每个计分格的得分，而是保留下所有计分格，例如在 Stirke 情况下，frame 是 [10 X Y] 这种形状。</p>
<p>对于第二个问题，既然不参与计分格的计算，最好是忘得越远越好。也就是说，假如我们想永远玩下去，那么这种程序最好也能正确计算出得分，直到我们想终止为止。</p>
<p><img src="/images/BowlingGameClj_1724137596098_0.png" alt="BowlingGameClj.png"></p>
<p>在无限游戏的场景下，rolls 可以无限投掷，我们就可以无限地推迟从计分格中获得总分的决定。遗憾的是，保龄球游戏中有一条定胜负的终止规则，每局只有 10 个计分格，所以它不是无限游戏。在程序计算总分的最后，取出了 10 个计分格。</p>
<h2 id="惰性，无限可能！"><a href="#惰性，无限可能！" class="headerlink" title="惰性，无限可能！"></a>惰性，无限可能！</h2><p>Bob 大叔分析说惰性之所以需要，是因为这样做可以把需要做的事情和需要做的量分离开来。延迟需要多少量这个决定到最终用户的手上。</p>
<p>惰性是实现无限游戏的手段，而无限是帮我们扫清聚焦计算（厌恶那些 indexes 吧）障碍的思维方式。试想，列表元素都无限多了，你还会思考越界吗？你只会想我该怎么这个游戏一直玩下去。</p>
<p>惰性列表时一个知道如何计算下一个值的对象。惰性列表是伪装成列表的迭代器。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2024/08/19/A-Guided-Tour-of-Functional-Design-Part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ryan Qian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鄢倩">
      <meta itemprop="description" content="Senior Consultant | DevOps Master | Blockchain & Web3 Specialist">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 鄢倩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/19/A-Guided-Tour-of-Functional-Design-Part-1/" class="post-title-link" itemprop="url">函数式设计导读系列（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-19 10:07:00" itemprop="dateCreated datePublished" datetime="2024-08-19T10:07:00+08:00">2024-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 11:49:11" itemprop="dateModified" datetime="2025-06-25T11:49:11+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Clojure/" itemprop="url" rel="index"><span itemprop="name">Clojure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我是 Bob 大叔的《架构整洁之道》中文版的技术审校，也是他的扛鼎之作《敏捷软件开发：原则、模式和实践》重制版的译者。当然，再次有幸参与了大叔的新作《函数式设计》的技术审校，我想谈谈过程中个人的所学所想。</p>
<h2 id="浓眉大眼的-OO-叛变革命？"><a href="#浓眉大眼的-OO-叛变革命？" class="headerlink" title="浓眉大眼的 OO 叛变革命？"></a>浓眉大眼的 OO 叛变革命？</h2><p>Bob 大叔成名已久，是面向对象编程领域当之无愧的领军人物。如今，他出一本函数式编程的书籍，我想他的多数读者应该会感到疑惑：没想到你浓眉大眼的，居然也叛变了“革命”。Bob 大叔叛变了吗？他的这本书和他之前的诸多作品文脉想通，有继承也有创新，落脚点还是实用。我用电梯演讲的方式概括了这本书的内容和优势。 对于：Bob 大叔的读者多数是面向对象编程的熟练手</p>
<h2 id="一问三连，一发入魂"><a href="#一问三连，一发入魂" class="headerlink" title="一问三连，一发入魂"></a>一问三连，一发入魂</h2><p>决定读不读一本书，最好的方式是带着疑问去检索答案。我拿到这本书，脑子中闪现的一个问题就是函数式设计是作为面向对象设计的对立面提出来的吗？当我翻开前面几页，发现 Bob 大叔居然用了 Clojure 这门 Lisp 的方言来阐述观点，不由得心头一紧，这门编程语言受众很窄，恐怕会劝退很多读者呀！写过如此之多畅销书的 Bob 大叔不会没有意识到这点，那他的目的何在？我把书从头粗粗地翻到末尾，闭目凝神，回想 2010 至 2020 年这十年间函数式编程语言红极一时又式微的过程，叠加 genAI Copilot 辅助编程的滔天巨浪，不免心有戚戚，喟然叹曰：现在再来讨论编程范式，有用吗？</p>
<p>FD 是作为 OOD 对立面提出来的吗？</p>
<p>Bob 大叔为什么要用 Clojure 语言，这种小众语言我又用不上，学了等于白学？</p>
<p>如果我工作中没有用到函数式编程语言，这本书是不是对我帮助就不大了？</p>
<h2 id="真相只有一个！"><a href="#真相只有一个！" class="headerlink" title="真相只有一个！"></a>真相只有一个！</h2><p>你觉得函数式编程的本质是什么？一切皆函数（注：纯函数）。这个回答怕是贴着面向对象编程的脸喊出来的。Bob 大叔在书中就不这么说的，他的厉害之处就在于：别整这些玄乎饶舌的概念，给我上代码，拉出来溜溜，拿捏几下，我就知道你姓甚名谁，写下来，完了还给自己的前一本书压个韵。</p>
<p>Bob 大叔在《架构整洁之道》中提出了编程范式的真相 —— 约束程序的执行，告诉我们不能做什么。</p>
<p>为什么要对程序的赋值操作做限制呢？原因在于赋值带来程序的时序耦合，显然时序耦合是让程序复杂（难懂）的诱因之一。我们看看一段计算前十个整数的平方和的 Java 程序，这段程序中包含了两个变量并且都有赋值。仔细看这三段注释的 log 函数，其中第二个记录的 sum 和 i 并不是这轮循环的最终状态（sum累加之后，i 必须自增）。具体来说，调用 sumFirstTenSquareHelper(0, 1)，正确的 [sum, i] 状态对是 [0, 1], [1, 2], [5, 3] … [385, 11]，但是第二处记录却是错误的状态对，如 [1, 1]。也就是说，赋值的操作给了时间顺序这个坏蛋以可乘之机，让本应是原子化的变量状态出现不一致。假设放到更加混乱的多线程环境中，这段程序时不时会出现错误，这也被称为竞态条件。竞态条件是指多个线程在访问共享资源时，其执行顺序可能导致结果的不确定性或错误。</p>
<p><img src="/images/sumFirstTenSquareHelperJava_1723958913624_0.png" alt="sumFirstTenSquareHelperJava.png"></p>
<p>既然赋值或称对变量的改变是时序耦合的罪魁祸首，那么明智的做法自然是干掉它。我们解析下赋值的目标是什么？没错，状态的变化。完成状态的变化，通常有两种做法。第一种简单粗暴，用新的直接干掉旧的，让旧的消失于无形，俗称破坏性创新。第二种优雅得多，符合重构（refactoring）十六字心法“旧的不变，新的创建，一键切换，旧的再见”。前者是赋值，后者是替换。说白了，替换不是抹去前任痕迹，而是让旧的依然如故，以旧换新而已。</p>
<p>那么到底该怎么做呢？函数式编程中有两大武器，可以实现以旧换新的便宜操作。第一件是递归函数调用（recursive function call），第二件是持久性数据（persistent data）。我们知道，递归函数调用如果未到达递归出口（一般是 if 条件），那么它的栈桢就会不断累积下去，每一层栈桢都可以看作是一次以旧换新；而持久性数据是一种支持多版本的数据结构，它会尽可能地共享数据结构来避免以旧换新时数据的完全拷贝，毕竟，完全拷贝听上去就很浪费。</p>
<p>我们看看用 Java 程序用这两大武器实现赋值消失术。利用递归，将赋值转换成算出新值，然后作为参数传递给递归函数。因为此处的参数仅是原生类型，对于复合类型，持久性数据的威力才会发挥出来。</p>
<p><img src="/images/sumFirstTenSquareHelperJava-Recursive_1723975974493_0.png" alt="sumFirstTenSquareHelperJava-Recursive.png"></p>
<p>如此看来，我们已经完成了赋值的历史终结任务，但令人不安的是天边似乎还有一朵乌云——递归的代价。我们用 Clojure 同样实现一遍上面的简短程序。然后用 <code>cider-toggle-trace-ns</code>（如果你用 Emacs + Cider 写 Clojure 的话，顺便说一句，有兴趣的人足够多，那我会分享自己的 Emacs + Cider 配置），一旦调用该函数，就会有深深的调用栈出现。递归会让函数 call 栈桢增长，导致栈溢出。</p>
<p><img src="/images/sum-first-ten-squares-helper-clj_1723976287213_0.png" alt="sum-first-ten-squares-helper-clj.png"></p>
<p><img src="/images/sumFirstTenSquareHelper-CljRecursive_1723976829928_0.png" alt="sumFirstTenSquareHelper-CljRecursive.png"></p>
<p>递归有代价，尾递归来优化。我们把上面的程序略作修改，把内部的函数调用名改成 recur，重新求值，再来观察一下调用栈。你会惊喜地发现，深深的栈不见了，尾递归优化（TCO）复用了栈桢，以此达到了循环的目的。所以，你会在这本书的多数程序中发现这样的结构 <code>(loop...recur)</code>。</p>
<p><img src="/images/sum-first-ten-squares-helper-tco-clj_1723976955296_0.png" alt="sum-first-ten-squares-helper-tco-clj.png"></p>
<p><img src="/images/sum-first-ten-squares-helper-tco-stack-clj_1723976968464_0.png" alt="sum-first-ten-squares-helper-tco-stack-clj.png"></p>
<p>我们用两段伪代码来通观下刚刚到底发生了什么事情。对，我们用尾递归去掉了循环赋值。我们回过头来看看。 尾递归看上去很复杂，但其实很简单。上面程序展示了过程式代码改造成函数式尾递归的过程，其中最大的差异点就是消除了变量的赋值。 其实，搞了这么多新奇的手法，又是尾递归优化又是持久性数据，那都是因为计算机的开山老祖是图灵的图灵机而不是阿隆佐·邱奇的 lambda 演算，我们一直在用图灵机的实现模拟 lambda 演算。所以，总结下来就是持久性数据 (persistent data) 在递归参数中的复制以代替赋值，用 TCO 减少栈桢增长。</p>
<p><img src="/images/state-updates-java_1723977516519_0.png" alt="state-updates-java.png"></p>
<p><img src="/images/state-updates-fp_1723977527346_0.png" alt="state-updates-fp.png"></p>
<p><img src="/images/loop-recur-clj_1723980120018_0.png" alt="loop-recur-clj.png"></p>
<p>归根结底，函数式编程遵循一个朴素的原则，追求不变性。甚至可以说，函数式设计的本质就是拿捏不变性。其余的绝妙功法，我们后续再聊。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2024/06/14/mpc-explained/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ryan Qian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鄢倩">
      <meta itemprop="description" content="Senior Consultant | DevOps Master | Blockchain & Web3 Specialist">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 鄢倩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/14/mpc-explained/" class="post-title-link" itemprop="url">多方安全计算的原理解释和代码说明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-06-14 12:40:46 / 修改时间：12:48:05" itemprop="dateCreated datePublished" datetime="2024-06-14T12:40:46+08:00">2024-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/" itemprop="url" rel="index"><span itemprop="name">Blockchain</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="姚期智的百万富翁问题"><a href="#姚期智的百万富翁问题" class="headerlink" title="姚期智的百万富翁问题"></a>姚期智的百万富翁问题</h1><blockquote>
<p>Two millionaires wish to know who is richer; however, they do not want to find out inadvertently any additional information about each other’s weath. How can they carry out such a conversation?</p>
</blockquote>
<p> 假如有两位富翁想知道他俩谁更有钱，但是又不愿意暴露自己有多少钱，那么是否存在一种沟通方式完成这件事呢？这个问题就是著名的姚的百万富翁问题。1982年，在加州伯克利分校任教的姚期智发布了一篇题为《安全计算的协议》（Protocols for Secure Computations）论文[1]，不仅解决了这个问题，同时还开创了密码学的崭新领域，多方安全计算（Secure Multiple-Party Computation），简称为 MPC 或 SMC。</p>
<p> 两位富翁分别叫 Alice 和 Bob，Alice 有 i 百万元，Bob 有 j 百万元，假设 A 和 B 的资产都在一百万到一千万之间，也就是 0 &lt; i, j &lt; 10。</p>
<p> 要解决这个问题，我们可以用一个名为带锁的建议箱的隐喻。富翁 Alice 有10只带锁的箱子并且她有一枚解锁的钥匙，并且 Bob 没有钥匙。Alice 将箱子从左到右依次排列。假设她有 6 百万财富值，即 i &#x3D; 6，于是她从左往右数到第 6 号箱子，并且往第 6 号箱子之前的所有箱子，即 1-5 号箱子，放入标记为 0 的纸条，从第 6 号开始放入标记为 1 的纸条。然后全部上锁离开。这时，Bob 过来看箱子，由于他没有钥匙，所以对箱子中的纸条上的信息一无所知。假设他有 4 百万财富值，即 j &#x3D; 5，他唯一能做的就是从左往右数到第 4 号箱子，同时将剩下的 9 只箱子全部焚毁。接下来，他将这只箱子交给 Alice，因为 Alice 有钥匙，所以她可以打开箱子。打开箱子后有两种纸条，相应地对应着两种结果。如果纸条是 0 ，那说明 Alice 比 Bob 有钱。反之，若纸条是 1，那说明 Bob 要么比 Alice 有钱，要么和 Alice 一样有钱。在我们的假设中，Alice 打开箱子之后，纸条上标记的是 0，所以 Alice 比 Bob 有钱，而事实确实如此，因为 Alice 有 6 百万元，而 Bob 只有 4 百万元。通过使用这种方法，Alice 和 Bob 除了获得谁更有钱的信息之外，都不知道对方财富值。这种让两方或者多方在保证输入私密的情况下计算某个函数的方法被称为多方安全计算。</p>
<p> 当然，我们稍微花费点心思不难发现这个例子中存在泄露秘密的风险。如果 Alice 放入箱子中的是标记 1 - 10 的纸条，那么 Bob 的资产数量就被 Alice 知晓了。这是 MPC 研究的 honest 问题，暂不讨论。</p>
<p> 实际中，这个解法具体是怎么工作的？在密码学中，钥匙和带锁的建议箱对应就是非对称密码学体系。Alice 有钥匙，即 Alice 拥有私钥。</p>
<p> 对于 Bob 来说，他没有私钥，但是可以使用公钥，他进行下列计算<br>Bob 选择一个大数 x，并且加密 E(x) &#x3D; k。<br>计算 k-j+1 &#x3D; m，其中 j 是 Bob 的资产<br>Bob 公开 m 给 Alice，并且告知 m 包含自己的财富值</p>
<p>对于 Alice 来说，她有私钥，需要进行下列计算<br>计算 m, m+1, m+2, m+3, …, m+j-1&#x3D;k, …, m+9<br>也即计算 k-j+1, k-j+2, k-j+3, …, k-j+j, …, k-j+10<br>使用私钥解密 y[u] &#x3D; D(k-j+u), 有 y[j] &#x3D; D(k) &#x3D; x<br>求模 z[u] &#x3D; y[u] mod P，P是质数<br>z[i] 之前的 z[u] 不变，之后的 z[u] 都+1<br>Alice 公开所有的 z[u] 给 Bob</p>
<p>Bob 进行检验<br>若 x mod P  &#x3D; z[j]，那么说明没有进行+1的操作，j &lt;&#x3D; i<br>若 x mod P !&#x3D; z[j]，那么说明进行了+1的操作，j &gt; i</p>
<h1 id="社会主义百万富翁问题-2"><a href="#社会主义百万富翁问题-2" class="headerlink" title="社会主义百万富翁问题[2]"></a>社会主义百万富翁问题[2]</h1><p>两位员工，名叫 Alice 和 Bob。他们做着同样水平的工作，但是怀疑老板优待他们其中一位，所以想知道自己的薪水是否公平。他们不想暴露自己的工资，也不信任第三方机构，那么他们该如何知道自己是否被公平地对待呢？</p>
<p>假设 Alice 和 bob 的薪水在 10, 20, 30, 40 时薪范围内。我们假设 Alice 的时薪是 30 元，Bob 则是 20 元。我们依然使用带锁建议箱的隐喻打比方。</p>
<p>首先，Alice 拿到 4 只带锁的箱子，每个箱子的钥匙都不同。他依次将箱子排开，从左到右的位置表示时薪，即1号箱对应10元时薪，以此类推。然后，Alice 把第 3 号箱子的钥匙保留，代表她的时薪是 30 元，其余的钥匙全部销毁。然后她把打开的箱子交给 Bob。Bob 依次在箱子里放入标记 0 或 1 的纸条。0 代表不是自己的时薪，1 代表是自己的时薪。结果就是他在第 2 号箱子中放入了标记为 1 的纸条，其余的纸条都是 0。然后他把上锁的箱子交给 Alice。Alice 用唯一的钥匙打开了第 3 号箱子，发现里面的纸条是 0。所以她知道了他们两人的时薪并不公平。但是除了这个信息之外，他们对彼此的时薪究竟是多少一无所知。</p>
<p>实际上，这个解法在密码学中被称为不经意传输（Oblivious Transfer，简称 OT）。Bob 给 Alice 发送了多条关于自己时薪是多少的信息，但是 Bob 只能打开那条和自己时薪相关的信息。与此同时，Bob 并没有意识到（Oblivious） Alice 到底想要哪条信息。更一般的定义，不经意传输是一种密码学协议，发送者传输多条消息给接收方，其中只有一条是潜在的消息，但是发送者没法知晓传达到的是哪条消息。不经意传输是由 Maichael O. Robin 在 1981 年首次提出来的。</p>
<p>密码学家 Kilian[3] 已经证明，MPC 和 OT 在理论层面是等价的：给定 OT，可以在不引入其它任何额外假设的条件下构造 MPC，类似地，可以直接应用 MPC 构造 OT。</p>
<h1 id="基本原语"><a href="#基本原语" class="headerlink" title="基本原语"></a>基本原语</h1><p>密码学原语是密码学已经广泛认可的低级别的加密算法，比如单向哈希函数和对称加密、非对称加密和数字签名等。这些原语会时常被用于构建加密协议。 比如说，对称加密和哈希函数就能组成消息验证码这种既保密又完整的协议。</p>
<p>MPC 有个基本原语，秘密分享（secret sharing），秘密分享是很多 MPC 协议的核心构造块。</p>
<p>我们在电影中经常看到这样的场景，若想要开启银行保险柜，需要几个人同时按下指纹。这里所有指纹组成一把开门的钥匙，而每个指纹就是这把钥匙的分片，我们把这种手段叫做密钥分割，秘密分享就可以实现密钥分割。秘密分享简单定义：一个 (t, n) 的秘密分享协议可以将秘密值 s 分成 n 个份额，通过任意 t 个秘密份额都可以完整重建出秘密值 s。少于 t 个秘密份额都无法得到和 s 相关的任何信息。前面提到的银行的例子中 t 就等于 n。秘密分享是 Adi Shamir（RSA 中的 S ） 和 George Blakley 于 1979 年独立发明出来的。</p>
<p>一个关于秘密分享隐喻是带锁的嵌套箱子。假设有 5 只带锁的箱子，分别对应不同的钥匙，分属于 5 个人。他们要分享一条消息 X，于是把消息放进最小的箱子里锁起来，然后把小箱子放到大箱子里依次锁起来。最终得到一个加了 5 把锁的嵌套箱子。如果想要获取 X，就必须一层一层地从外层开始解锁，只有 5 个人的钥匙都用上了全部的箱子才能打开。这样的手段就是一种安全的秘密分享。</p>
<p>实际中，这个问题的解法之一是 Shamir 算法。这个算法用到了 (t-1) 次多项式需要 t 个点的坐标才能求解的特性。举个例子，一次多项式 y(x) &#x3D; kx+b，这个函数代表一条直线，我们都知道两点确定一条直线，只有知道了两个点的坐标才能求解。于是，我们可以令秘密 s 为 b，假设为 5。然后选定斜率为 1。那么这条直线的方程就是 x + 5，此时任取直线上的两个坐标点 (1, 6), (2, 7) 分别给两个人 Alice 和 Bob。Alice 和 Bob 各自拿着坐标点，无法单独推断出方程，所以也就不能获取 s。而只有将两个点合并列方程一起计算，才能得到 s 的值：<br>k+b&#x3D;6<br>2k+b&#x3D;7<br>得到，k &#x3D; 1, b &#x3D; 5，而 b 就是秘密 s。如果是分享给 3 个人，那么只要在该直线上任意找 3 个点就可以完成任何两方都能获取秘密的计算。</p>
<p>推而广之，(t, n) 的秘密共享，那么就需要 t-1 次的多项式。也就是说，为了满足任意三人能够获取秘密，则需要一条抛物线方程（二次方程）。</p>
<h1 id="安全计算"><a href="#安全计算" class="headerlink" title="安全计算"></a>安全计算</h1><p>其实，秘密分享完成了多方安全计算的一部分重要的工作，即保证输入的隐秘性。也就是说，Alice 可以将自己的输入参数以秘密分享的方式分享给 Bob，此时 Bob 只是拿到了 Alice 输入参数的一个份额并不知道原始输入是什么。同理，Bob 也可以将自己的输入一秘密分享的方式公布给 Alice。如果想要完成安全计算，那么还剩下一个问题：如何将这些份额组合起来并运行一个函数，最终得出结果。</p>
<h2 id="加法门"><a href="#加法门" class="headerlink" title="加法门"></a>加法门</h2><p>以加法为例。假设 Alice 的隐私输入是 5，Bob 的隐私输入是 8，我们首先将 5 和 8 分别进行秘密分享。为了方便计算，我们将直线的斜率都设为 -1。也就是说，Alice 的直线为 y&#x3D;5-x, Bob 的直线为 y&#x3D;8-x，因此只需要分别给出两处纵坐标即可。即 Alice 的秘密值 5 可以分成 (2, 3) 和 (3, 2) 简写成纵坐标 3 和 2，而 Bob 的秘密值 8 可以分成 9 和 -1。然后他们之间交换份额，得到：<br>Alice：a[0] &#x3D; 3, b[0] &#x3D; 9<br>Bob：a[1] &#x3D; 2, b[1] &#x3D; -1<br>此时，Alice 拥有了 Bob 的份额 b[0]&#x3D;9，Bob 也有了 Alice 的份额 a[1]&#x3D;2。</p>
<p>直线的加法比较简单，计算过程可以描述成如下形式：<br>a+b &#x3D; (a[0]+a[1]) + (b[0]+b[1])<br>由于满足加法的结合律，故有 a+b&#x3D;(a[0]+b[0]) + (a[1]+b[1])&#x3D;12+1&#x3D;13。<br>其实，Alice 和 Bob 的直线方程相加之后得到 y&#x3D;13-2x，13 就是秘密值 5 和 8 相加的结果。</p>
<h2 id="乘法门"><a href="#乘法门" class="headerlink" title="乘法门"></a>乘法门</h2><p>乘法相对而言比较复杂，原因在于计算的过程中，需要获取对方保留在本地不对外公布的份额，这就违背了安全计算的定义。如下：<br>a <em>b &#x3D; (a[0] + a[1])</em> (b[0] + b[1]) &#x3D; (a[0] <em>b[0]) + (a[0]</em> b[1]) + (a[1] <em>b[0]) + (a[1]</em> b[1])<br>其中， (a[0] <em>b[0]) 和 (a[1]</em> b[1]) 都可以顺利在 Alice 和 Bob 本地完成，但是 (a[0] <em>b[1]) 和 (a[1]</em> b[0]) 会要求对方保留的份额，而这部分是不能够共享的，否则就会暴露各自的输入。</p>
<p>为了应对这个问题，我们需要进行遮掩（Masking）处理。此时，需要引入一个第三方来生成一组数用于遮掩彼此不想分享的数据。对于 Alice 而言，就得遮掩 b[1]，对于 Bob 而言，就得遮掩 a[1]。</p>
<p>第三方首先生成一个三元组(s, t, st)，其中 st&#x3D;s*t。例如：s&#x3D;7, t&#x3D;11, st&#x3D;77。然后分别将这三个元素进行秘密分享。<br>对于 s，我们有 s[0]&#x3D;4, s[1]&#x3D;3；对于 t，t[0]&#x3D;5, t[1]&#x3D;6；而 st，则有 st[0]&#x3D;44, st[1]&#x3D;33。接下来，第三方将 s[0] 和 t[0] 发送给 Alice，而将 s[1] 和 t[1] 发送给 Bob。<br>Alice 需要计算一个算式，我们记为 z[0]：</p>
<p>z[0] &#x3D; st[0] + (s[0] <em>beta) + (alpha</em> t[0]) + (alpha <em>beta)<br>Bob 需要计算另一个算式，记为 z[1]：<br>z[1] &#x3D; st[1] + (s[1]</em> beta) + (alpha * t[1])</p>
<p>其中，最为有意思的事情发生了，<br>alpha &#x3D; (a[0]-s[0]) + (a[1]-s[1])<br>beta &#x3D; (b[0]-t[0]) + (b[1]-t[1])<br>由于，Alice 只有 s[0] 和 t[0]，所以她可以计算 alpha 和 beta 式子左边的算式。同理，Bob 可以计算右边的算式。之后，他们双方可以分享这个各自的结果，注意此过程中，a 和 b 的任何信息都没有暴露。在本例中，alpha &#x3D; -2, beta&#x3D;-3.</p>
<p>我们开始计算 z[0] 和 z[1]<br>z[0] &#x3D; st[0] + (s[0] <em>beta) + (alpha</em> t[0]) + (alpha <em>beta) &#x3D; 44 + (4</em> -3) + (-2 <em>5) + (-2</em> -3) &#x3D; 28<br>z[1] &#x3D; st[1] + (s[1] <em>beta) + (alpha</em> t[1]) &#x3D; 33 + (3*-3)+(-2*6)&#x3D;12</p>
<p>最终的结果就是 z[0]+z[1] &#x3D; 40。也就是我们想计算 5 * 8 的结果。这种乘法也被叫做 Beaver 乘法。</p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>我们使用 HoneyBadgerMPC 的 Python 代码来实现乘法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">beaver_multiply</span>(<span class="params">ctx, x: Share, y: Share</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;The hello world of MPC: beaver multiplication  </span></span><br><span class="line"><span class="string">Linear operations on Share objects are easy</span></span><br><span class="line"><span class="string">Shares of random values are available from preprocessing</span></span><br><span class="line"><span class="string">Opening a Share returns a GFElementFuture</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line">  s, t, st = ctx.preproc.get_triples(ctx)  </span><br><span class="line">  </span><br><span class="line">  Alpha = <span class="keyword">await</span> (x - s).<span class="built_in">open</span>()  </span><br><span class="line">  </span><br><span class="line">  Beta = <span class="keyword">await</span> (y - t).<span class="built_in">open</span>()  </span><br><span class="line"><span class="comment"># Alpha*Beta is multiplying GFElements</span></span><br><span class="line"><span class="comment"># Alpha*t, Beta*s are multiplying GFElement x Share -&gt; Share</span></span><br><span class="line"><span class="comment"># st is a Share</span></span><br><span class="line"><span class="comment"># overall the sum is a Share</span></span><br><span class="line">  </span><br><span class="line">  xy = (Alpha * Beta) + (Alpha * t) + (Beta * s) + st  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> xy</span><br></pre></td></tr></table></figure>

<p>调用的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x = ctx.Share(<span class="number">5</span>) + ctx.preproc.get_zero(ctx)</span><br><span class="line">y = ctx.Share(<span class="number">7</span>) + ctx.preproc.get_zero(ctx)</span><br><span class="line"></span><br><span class="line">xy = <span class="keyword">await</span> beaver_multiply(ctx, x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check openings of the multiplied values</span></span><br><span class="line"></span><br><span class="line">X = <span class="keyword">await</span> x.<span class="built_in">open</span>()</span><br><span class="line"></span><br><span class="line">Y = <span class="keyword">await</span> y.<span class="built_in">open</span>()</span><br><span class="line"></span><br><span class="line">XY = <span class="keyword">await</span> xy.<span class="built_in">open</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> XY == X * Y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[<span class="subst">&#123;ctx.myid&#125;</span>] Beaver Multiplication OK&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>beaver_multiply 函数中进行了封装，我们可以拆解还原计算过程。<br><code>s, t, st = ctx.preproc.get_triples(ctx)</code><br>这里就是获取 s, t 和 st 的步骤，代码中省略了初始化三元组的过程。<br><code>Alpha = await (x - s).open()</code><br>对应上面说到的算式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alpha = (a[0]-s[0]) + (a[1]-s[1])</span><br></pre></td></tr></table></figure>

<p>需要注意的是，(a[1]-s[1]) 来自 Bob，所以需要异步通信获取 Bob 计算的结果，即 await..open.<br><code>Beta = await (y - t).open()</code><br>对应的算式是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beta = (b[0]-t[0]) + (b[1]-t[1])</span><br></pre></td></tr></table></figure>

<p>计算过程同 alpha 一致。</p>
<p>接着我们观察乘法门中算式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z[0]+z[1] = st[0] + (s[0] * beta) + (alpha* t[0]) + (alpha * beta) + st[1] + (s[1] * beta) + (alpha * t[1])</span><br></pre></td></tr></table></figure>

<p>然后对比代码中的算式<br><code>(Alpha * Beta) + (Alpha * t) + (Beta * s) + st</code><br>不难发现，(Alpha <em>t) 对应了(alpha</em> t[0]) + (alpha <em>t[1]) 的算式，而 (Beta</em> s) 对应了算式 (s[0] <em>beta) + (s[1]</em> beta) 的结果，而 st 则是 st[0] + st[1] 的结果。顺便计算下这里面到底沟通了多少次?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x: 1</span><br><span class="line">y: 1</span><br><span class="line">s: 2</span><br><span class="line">t: 2</span><br><span class="line">st: 2</span><br><span class="line">Alpha: 1</span><br><span class="line">Beta: 1</span><br><span class="line">(Alpha * Beta): 1</span><br><span class="line">(Alpha * t): 1</span><br><span class="line">(Beta * s): 1</span><br><span class="line">st: 1</span><br></pre></td></tr></table></figure>

<p>总计有 14 次来自三方的通信。不过，至此我们理解了 beaver_multiply 和我们在乘法门中分析的算法一致。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>MPC 的基本原语除了秘密分享之外，还有随机预言机（Random Oracle，简称RO）以及混淆（乱码 Garbled Circuit）电路。另外，构造 MPC 协议的功能函数还有几种广泛的应用，例如前文提及的不经意传输和零知识证明等。严格意义上讲，零知识证明并不是 MPC 的必要组成成分，加密学中将零知识证明划归为外包计算（Outsourced Computation），原因是相较于 MPC，因为零知识证明只需要一方提供加密数据，而另一方进行计算，最后将计算的结果返回给数据所有方，而 MPC 则要求多方输入数据，协同完成计算。不过全同态加密依然可以用来实现 MPC。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a target="_blank" rel="noopener" href="http://research.cs.wisc.edu/areas/sec/yao1982-ocr.pdf">Protocols for Secure Computation</a></li>
<li><a target="_blank" rel="noopener" href="http://twistedoakstudios.com/blog/Post3724_explain-it-like-im-five-the-socialist-millionaire-problem-and-secure-multi-party-computation">Socialist millionaires’ Problem</a></li>
<li><a target="_blank" rel="noopener" href="https://link.springer.com/content/pdf/10.1007/978-3-540-85174-5_32.pdf">Kilian, J. 1988 Founding Cryptography on Oblivious Transfer</a></li>
<li><a target="_blank" rel="noopener" href="https://www.wikiwand.com/en/Secret_sharing">Secret sharing</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/initc3/HoneyBadgerMPC">HoneyBadgerMPC</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2022/01/16/What-drives-an-engineer%E2%80%99s-sense-of-mission/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ryan Qian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鄢倩">
      <meta itemprop="description" content="Senior Consultant | DevOps Master | Blockchain & Web3 Specialist">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 鄢倩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/16/What-drives-an-engineer%E2%80%99s-sense-of-mission/" class="post-title-link" itemprop="url">工程师的使命感从何而来？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-16 11:11:51" itemprop="dateCreated datePublished" datetime="2022-01-16T11:11:51+08:00">2022-01-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 11:24:12" itemprop="dateModified" datetime="2025-06-25T11:24:12+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>技术塑造了我们现在的生活，那么又是什么在塑造技术自身呢？很多人会联想到程序员在其中起到的作用。但是，如果我们把人从技术的整体里分离出来，去探究技术内生的秩序或规律，或许答案就不那么直观了。而且从长远来看，这种方法比争论是人主导技术还是技术主导人更能增强个体的主体意识，因为排除个性的技术能帮我们避免陷入权威和神性的陷阱。</p>
<h1 id="什么是技术"><a href="#什么是技术" class="headerlink" title="什么是技术"></a>什么是技术</h1><p>在谈论什么塑造了技术之前，我们不得不回答一个前置问题：技术是什么？布兰恩·阿瑟的《技术的本质》中给出了一个我认为比较合理的定义。</p>
<ol>
<li>技术都是由已有的系统组件组合而成的</li>
<li>技术的每个组件自身也是微缩的技术</li>
<li>所有的技术都会利用或开发某种效应</li>
</ol>
<p>第一点，技术是由已有的系统组件组合而成的，这话不难理解，我们做软件项目也会引用很多外部组件。那么组件又是什么呢？所以他紧接着给出了第二点解释，技术的每个组件自身也是微缩的技术。这才是该定义最有趣的地方——递归解释。我们知道凡是递归总得有个出口，所以他最后给出了第三点解释，所有的技术都会利用或开发某种效应。也就是说，每一个技术都能发挥某种功能。</p>
<p>听完这番解释，是否有一种不明觉厉，又有一种听君一席话如听一席话的感觉？是的话，咱也先别急着否定。看看下面的这张图，它是著名的计算机科学的入门书《计算机程序的构造和解释》，简称SICP，关于解释器工作原理的图示。解释器就是利用 Eval 和 Apply 两个函数相互递归解释的。在软件的世界里，类似的例子还有很多。例如，编译器实现自举——利用老的语言写新的编译器，再用新的编译器编译出新的语言。</p>
<p><img src="/images/SICP.png" alt="Eval_Apply"></p>
<p>如果从软件的规模这个角度来考察这个定义，我们就会发现软件可以无限庞大下去。基于这样的假设，我们可以推论出软件并不是一种物理现象。1972年，荷兰计算机科学家迪杰斯特拉（Edsger W. Dijkstra）将软件描述为“分层系统”，因为我们需要用分层来解释和实现我们所构造的现象，而不是经由物理规律来考验这些现象。所以 SICP 一书中将软件称为“程序认知论”（阿贝尔森和萨斯曼）就非常有道理了。</p>
<p>软件工程师常常把分层系统看做是解决某些复杂软件问题的良药，然而事实上，软件其实就是分层系统，基于 OSI(Open System Interconnection) 模型的技术栈就是一种典型的例子。在 OSI 出现之前，曾经有项目尝试适配各种主机以完成各种异构网络之间的联通，但是均以失败告终。而 OSI 引领的标准让世界各地的工程师们协作起来逐步推进了网络技术栈的发展。现如今，我们操作图片时，已经完全无法想象它和比特之间的关联，因为它们已经相差得太远了。远到我们无需考虑有比特这么回事，更不用说底层的半导体控制的电流开关。</p>
<h1 id="技术革命结构里的危机"><a href="#技术革命结构里的危机" class="headerlink" title="技术革命结构里的危机"></a>技术革命结构里的危机</h1><p>1962年，美国著名科学哲学家库恩在《科学革命的结构》提到是范式危机引发了科学革命，例如海森堡的测不准原理对物理学的冲击，在经典物理学无法解释微观现象时科学革命发生了。我们承认自工业革命以来，技术发生了巨大的变化。如果假定技术的发展也存在范式革命，那么其中的危机是什么呢？爱德华·阿什福德·李的《柏拉图与技术呆子》一书给出了两点总结，他认为软件日益增加的复杂性和意想不到的功能是技术革命中的危险和机遇。</p>
<p>复杂性体现在以前可以工作良好的工具和模型，在更复杂的情况下，不能很好地工作，甚至崩溃。比如应付几十人并发的系统在面对上万人的并发时很容易就崩溃了。另一个表现则是项目失败的可能性增加了。比如，用瀑布过程开发大型系统，这种管理复杂性的方式会导致在需求设计阶段的异想天开，更可能招致错误和失败。</p>
<p>至于意想不到的功能，就是想常人不敢想、做常人不敢做的事情。2007年，苹果公司推出的苹果手机。它的创新性在于突破了手机是用来打电话的惯性思维，原来手机可以当电脑使用，反而原来打电话的功能才是附加功能。事实上，苹果手机最具革命性的一点是引入了应用程序的开发平台，这就让全球数百万富有创造力的程序员能够为苹果手机开发各种应用程序。程序员、苹果公司的应用商店和用户就形成了良性的服务网络，从此开启了移动互联网的时代。与苹果手机相近的创新就要数区块链网络了。它的意想不到之处在于货币居然可以由个人发行。区块链网络自带生态快速形成了以开发者、投资（ji）者和矿（Miner）工为一体的服务网络。</p>
<p>危机是技术革命结构重要的组成部分，但是如何清晰、准确和精准地界定危机依然是个麻烦的问题。当事物发展到复杂难懂的地步时，我们应当回到最初的基本假设上重新思考，这个过程也被称为第一性原理思维。在信息技术的历史学脉络中，我们能迅速地把握到几个关键的定律。</p>
<p>首先是摩尔定律。1965年，八叛徒之一、英特尔的联合创始人戈登、摩尔做出一个著名的预测，集成电路中的元件的数量将在未来每18个月翻一番。这一定律就一直是半导体行业的指导原则，而且延续至今。不过，大家有没有思考过一个问题，那就是既然摩尔定律一直起作用，那么要么硬件逐渐便宜下去，我们怎么还没有实现硬件自由呢？</p>
<p>因此，我们不得不提到另一个安迪-比尔定律。这个定律的原话是安迪所给的，比尔全都拿走。其中的安迪就是今天全球最大的个人计算机零件和CPU制造商英特尔公司的创始人兼当时的 CEO 安迪·格鲁夫，而比尔就是比尔盖茨。这条定律的意思是微软等软件公司的新软件总是比从前的软件更加耗费资源，以至于完全抵消了英特尔等硬件公司带来的性能提升。我们的切身体验也是，你拿着老旧的手机去运行现在的软件会感觉慢得不要不要的。</p>
<p>摩尔定律和安迪-比尔定律带来的最直接影响就是在产业上规定了技术的发展会越来越复杂。</p>
<p>另一个比较关键的定律就是梅特卡夫定律。 1980年，3com公司的联合创始人罗伯特·梅特卡夫提出一个现在被称为梅特卡夫的定律，该定律认为，网络的价值与网络上兼容的通信设备的数量的平方成正比。如果单台设备的价格为1块钱，那么一个连接10台设备的网络的价值就是 100 块，100台就是1w块，以此类推。</p>
<p>梅特卡夫定律在经济层面上肯定了网络的规模效应，互联网或区块链行业都是这一定律的实践者。</p>
<h1 id="技术发展的-Z-字模型"><a href="#技术发展的-Z-字模型" class="headerlink" title="技术发展的 Z 字模型"></a>技术发展的 Z 字模型</h1><p>如图所示。Z 字模型，其上层是技术革命的危与机，下层是技术发展的基本定律，而中间这条线就是从基础规律寻求技术革命的攀爬梯。如果把技术发展比作修仙小说，底下三条定律就是筑基，上面那条线就是羽化成仙，也就是凡人的终极目标。</p>
<p>在 Z 字模型中，危机并不是一蹴而就的，虽然三条基本定律告诉我们危机迟早会发生，但是依然需要做很多的工作，而这些工作都是由工程师完成的。</p>
<p>工程师们的日常工作到底是什么呢？我知道有人会说写代码，但更为清晰的描述是《技术的本质》中的标准工程：</p>
<blockquote>
<p>标准执行一个新项目时，在已知可接受的原则下聚集方法和设备的过程，是对已有技术的新的计划、试制和集成过程。</p>
</blockquote>
<p>这个描述比较拗口，我实例化一下。以敏捷软件工程为例，我们在执行一个新项目时，在时间、资源和成本的约束原则之下，通过 Discovery、Inception 等方法快速识别问题并启动项目，购买云服务资源，整备环境，管理和配置持续集成服务器，使用 DDD 建模，TDD 持续交付可工作的软件。整个过程中，我们会评估和选择满足功能及跨功能需求依赖的技术组件，试验和探究新的技术组件，并且集成遗留的系统、多个代码分支、多套测试和发布环境。</p>
<p>根据康威定律，当项目较大时，标准工程就演变成了一种企业组织形式，此时项目的成败会更加依赖围绕其周遭的利益关系网：技术团队、业务部门、财务预算、部门领导以及其他利益相关者。</p>
<p>总而言之，技术发展要求工程师处理的事务更加多元化，也更加复杂。优秀的工程师是什么样的呢？这就不得不提《浪潮之巅》的作者吴军划分出的工程师的五个等级说。</p>
<h1 id="工程师的五个等级"><a href="#工程师的五个等级" class="headerlink" title="工程师的五个等级"></a>工程师的五个等级</h1><p><img src="/images/Pyramid_of_engineers.png" alt="Pyramid Of Engineers"></p>
<p>吴军借鉴了前苏联著名物理学家朗道提出来的朗道等级。朗道曾经根据物理学家的贡献把他们分成了五级，每一级之间的贡献相差一个数量级。对于工程师，也可以做同样的划分。</p>
<ol>
<li>第五等工程师，能够独立设计和实现一项功能的人。如果需要别人告诉他怎么做，最多算是助理工程师或者技工，不在工程师之列。</li>
<li>第四等工程师，需要产品头脑，也就是说他们在做一件事之前，要知道所做出来的东西是否有用、易用，是否便于维护，是否性能稳定，等等。除了要具备产品设计方面的基本知识，还要具有一定的领导才能，能在整个产品的生命周期从头到尾讲一个产品负责到底。</li>
<li>第三等工程师，可以做出行业里最好的产品。他们与第四等工程师有着质的差别，这不仅反映在技术水平、对市场的了解、对用户心理的了解以及组织能力等诸多方面，而且也反映在悟性的差异上。</li>
<li>第二等工程师，是那些可以给世界带来惊喜的人。比如：第一台实用化个人电脑的实现者沃兹尼亚克，他们和第三四五等工程师的差别在于其工作的原创性以及对世界的影响力。不过，他们的工作不同于科学研究。</li>
<li>第一等工程师，是开创一个全新行业的人，历史上有爱迪生、特斯拉、福特，二战后有保时捷（Ferdinand Porsche，1875-1951）博士，本田宗一郎（1906-1991）和硅谷的诺伊斯等人。这些工程师不仅在技术和产品等各个方向上与第二等的工程师有了质的差别，而且在经验和管理上也是好手，他们通常是企业家，并通过自己的产品改变了世界。</li>
</ol>
<p>从这个等级阶梯上，我们看得出来，成为拔尖的工程师有多难。每个等级的工程师之间的差距是数十倍的。好的企业想要获得第二等甚至第一等的工程师，就需要一个由工程师构建的完整金字塔：要想出几个第一等的工程师，就需要有足够数量的第二等工程师，以此类推。</p>
<h1 id="技术的助产婆"><a href="#技术的助产婆" class="headerlink" title="技术的助产婆"></a>技术的助产婆</h1><p>苏格拉底曾经说过“我是思想的助产婆”，他说的是自己能够通过苏格拉底似的提问引发别人积极思考。那么，工程师们则可以理直气壮地说“我们是技术的助产婆”，工程师必须学会迎接软件复杂性的挑战，坚定地不放过任何细小的机遇荡起的涟漪。在标准工程的日常工作中，一脚把新生的技术踹出去。</p>
<p>所以，自信点，我们工程师的使命无上光荣。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2019/09/23/Rust-rocks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ryan Qian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鄢倩">
      <meta itemprop="description" content="Senior Consultant | DevOps Master | Blockchain & Web3 Specialist">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 鄢倩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/23/Rust-rocks/" class="post-title-link" itemprop="url">Rust 入门（Rust rocks）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-09-23 09:32:14 / 修改时间：10:01:43" itemprop="dateCreated datePublished" datetime="2019-09-23T09:32:14+08:00">2019-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>缘起</li>
<li>实践出真知<ul>
<li>快速获取</li>
<li>澄清概念<ul>
<li>Ownership</li>
<li>Move</li>
<li>Reference</li>
<li>Mutable reference</li>
</ul>
</li>
<li>解释错误</li>
<li>数据竞态条件</li>
<li>构建树状结构</li>
<li>渲染树状结构</li>
</ul>
</li>
<li>总结</li>
<li><a target="_blank" rel="noopener" href="https://github.com/qianyan/tree/blob/master/tree.rs">源码 Github</a></li>
</ul>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>做区块链的基本几乎没有人不知道 Rust 这门编程语言，它非常受区块链底层开发人员的青睐。说来也奇怪，Rust 起源于 Mazilla，唯一大规模应用就是 Firefox，作为小众语言却在区块链圈子里火了。这其中应该和以太坊的发起人 Govin Wood 创建的 Parity 项目有关，Parity 是一款用 Rust 编写的以太坊客户端。</p>
<p>最初接触 Rust 的时间大概是 2015 年，当年有同事发了一封“是否对 Rust 编程语言感兴趣的”的邮件。当时年少<del>不懂事</del>热血，觉得这门语言因为它小众很酷，所以特别适合拿来练功，所以就激情地回应了邮件，结果之后就没有了下文，想必那位同事也因为响应的人数太少而兴致缺缺。</p>
<p>第二次关注 Rust 是因为陈天在自己的公众号中提到了这门语言。我比较欣赏陈天，当初学习 Elixir 也是受他影响，所以也跟着他的步伐去听了张汉东的知乎Live，然后加入了他的读者群（魅力Rust），在这个群中潜水了大半年，一直很惊叹这个群的活跃度。</p>
<p>2019年，区块链圈中的一次大事件是 Facebook 要发非主权货币 Libra，随之而来是基于 Rust 之上的 Move 编程语言。这个 Move 说白了就是 Move 的一种 DSL，用比较学术的话说是指称（denotational）语义，用简单的编译器把 Move 的语法翻译成 Rust 的语法然后借助 Rust 的编译器生成二进制码。这个过程没有什么惊喜，不过 Move 语言显然是借鉴了 Rust 中移交（Move）主权（Ownership）的概念，它表征了这样一种事实——数字资产只能有一个主人，一旦移动，就会发生主权转移，以前的主人就丧失了该主权。这种想法和 Rust 中主权管理非常契合，所以不难理解为什么 Libra 的开发团队把名字也照搬过来了。当然，Libra 的底层区块链也用的是 Rust。这个大事件加上以太坊 Parity 的珠玉在前，对于程序员这群天生喜欢新鲜事物的人类而言，学习 Rust 的热情必然水涨船高。</p>
<p>大概就是在这种契机下，我开始学习 Rust 的。依照老规矩，我还是会从 tree 这个命令行程序入手，在试错中逐步学习 Rust 这门语言。包含它的基本数据类型，组合数据类型，控制流，模块（函数）以及文件和集合操作，还有最关键的 Ownership 的应用。</p>
<h2 id="实践出真知"><a href="#实践出真知" class="headerlink" title="实践出真知"></a>实践出真知</h2><p>学习 Rust 最深刻的体验莫过于和编译器较劲，这也是我听到过最多的抱怨。我想许多新手看到这么多警告或者错误，嘴上不说，心里应该很不是滋味。但是这也是 Rust 引以为豪的设计哲学，每一门新进的语言都有自己的本质原因（Rationale）或者设计哲学，比如 Lisp 家族的 Clojure 就有 <em>Elegance and familiarity are orthogonal</em> 的玄言妙语；往远古追溯，Java 的 <em>Write Once, Run Anywhere</em> 豪言壮语；而 Rust 的基本设计哲学是 <em>If it compiles, then it works</em>，这个条件有多苛刻我们稍微想一想就能知道——动态弱类型语言向静态强类型语言的逐步趋同态势，基本已经宣告了类型系统的胜利，但即便如此，现代软件工程也还是处处强调程序员要手写各种测试确保代码运行时的正确性——从单元测试到集成测试，从冒烟测试到回归测试，从 Profiling 到性能测试。这些测试方法和工具已经深入到软件工程的方方面面，然而各类软件还是漏洞百出。Rust 发出这种高调宣言，不免有夜郎自大之嫌疑。不过程序届是个能造概念也能落地概念的神奇圈子，高调的牛吹着吹着也就实现了。况且，Rust 充分诠释了现代编程语言的核心思想——约束程序员，不是劝劝你的意思，是憋死你的意思。</p>
<p>我在<a href="/2018/07/18/the-joy-of-learning-new-programming-language/">《我是如何学习新的编程语言》</a>中说过学习的最好方式是有目的地试错，我时常拿来练手的程序叫<em>tree - list contents of directories in a tree-like format.</em> 这段程序需要用到的 Rust 基本构件有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">基础概念</span><br><span class="line">1. 变量 - let</span><br><span class="line">2. ownership borrow - &amp;</span><br><span class="line">3. 可变性 - mut</span><br><span class="line">4. 可变引用 - &amp;mut</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复合数据类型</span><br><span class="line">1. String - String::from(&quot;&quot;) // 非基本类型</span><br><span class="line">2. Slice - &quot;&quot; or vec[..]</span><br><span class="line">2. struct - struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">集合及其操作</span><br><span class="line">1. Vec&lt;_&gt; - Vec::new() // 考虑到集合需要自动扩展</span><br><span class="line">2. iter()</span><br><span class="line">3. .map()</span><br><span class="line">4. .enumerate()</span><br><span class="line">5. .flatten()</span><br><span class="line">6. .collect()</span><br><span class="line">7. .extend() //集合拼接</span><br><span class="line"></span><br><span class="line">控制语句</span><br><span class="line">1. if Expressions - if &#123;&#125; else &#123;&#125;</span><br><span class="line">2. recursions</span><br><span class="line"></span><br><span class="line">模块</span><br><span class="line">1. fn - fn x(s: String) -&gt; Vec&lt;String&gt;</span><br><span class="line"></span><br><span class="line">功能组件</span><br><span class="line">1. Path</span><br><span class="line">2. fs</span><br><span class="line">3. env</span><br></pre></td></tr></table></figure>
<p>当尝试寻找这些元素时，我发现 Rust 或者诸如此类的编译型语言都有一个让人不舒服的地方——验证的前置步骤耗时太长。因为没有<em>repl</em>，所以想去了解一些概念的使用方法，就不得不另外创建一个项目（我可不想污染当前项目的代码），在它的 main 函数里编写试验程序，这比起具有快速反馈能力的<em>repl</em>，着实太慢了。不过这里的慢也是相对的，Rust 也有一个显著的优势，在出现编译错误时，编译器不仅能向你解释原因，还能推荐潜在的修改方式，这就比 Javascript 一类的动态语言要清晰和高明得多。再利用内置的 <code>assert_eq!</code> 等断言函数预判结果，又比单独写测试省事。所以，总体而言，学习的过程还是很愉悦的。</p>
<h3 id="快速获取"><a href="#快速获取" class="headerlink" title="快速获取"></a>快速获取</h3><p>这里举个例子，为了解如何拼接两个集合时，需要事先搞明白几个问题：</p>
<ol>
<li>集合的构造？</li>
<li>集合的拼接？</li>
<li>结果的断言？</li>
</ol>
<p>在没有<em>repl</em>的条件下，唯一快速上手的工具就是文档，在 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/">https://doc.rust-lang.org/std/</a> 的官方标准库中，可以搜到<code>Struct std::vec::Vec</code>的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html">详细解释</a>。</p>
<p>通过例子程序，可以很快知道集合的构造方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let mut v = vec![1, 2, 3];</span><br><span class="line">v.reverse();</span><br><span class="line">assert_eq!(v, [3, 2, 1]);</span><br></pre></td></tr></table></figure>
<p><code>vec!</code> 宏可以快速构造出一个集合来，顺便试验下它的<code>reverse</code>方法。那么集合如何拼接呢？为了解答这个问题，我一般会用搜索引擎，或者深入文档，查找如 <code>concat</code>，<code>append</code>等关键字，每每总有收获。</p>
<p>在不考虑非功能需求的前提下，我们先用最直接的方式实现，例如：文档中给出的样例<code>extend</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let v = vec![1, 2, 3];</span><br><span class="line">v.extend([1, 2, 3].iter().cloned()); // 编译错误</span><br></pre></td></tr></table></figure>
<p>注意，这里编译失败。Rust 编译器会直截了当地给出错误信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0596]: cannot borrow `v` as mutable, as it is not declared as mutable</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:13:5</span></span><br><span class="line">   |</span><br><span class="line">12 |     let v = vec![1, 2, 3];</span><br><span class="line">   |         - help: consider changing this to be mutable: `mut v`</span><br><span class="line">13 |     v.extend([1, 2, 3].iter().cloned());</span><br><span class="line">   |     ^ cannot borrow as mutable</span><br></pre></td></tr></table></figure>
<p>错误信息中透露出我们的程序在尝试借用（borrow）一个不可变的变量。<em>borrow</em>和 <em>mutable</em>都是新的概念。对于新的概念，我们会习惯地用熟知的知识去类比。如果套用函数式编程中不可变的特性，大体可以猜到 Rust 中的变量默认是不可变的。但是 <em>cannot borrow as mutable</em> 中 <em>borrow</em> 确实是有点超出认知范围。那么此时弄清定义是非常有必要的。</p>
<h3 id="澄清概念"><a href="#澄清概念" class="headerlink" title="澄清概念"></a>澄清概念</h3><p><strong>学习语言的过程中最需要注意的事项就是澄清概念</strong>。当遇到崭新的概念时，我们得停下先去补充这部分的知识，然后再回过头来理解和解决实际遇到的问题。因为每一门编程语言都有本门派的哲学原理，它本身就萃取了多种理论和实践的成果，所以必须学习这些概念。学习的过程其实就是逐步澄清概念的过程。</p>
<p>在学习（尝试定义）<em>borrow</em> 的过程中，我又先后接触到了 <em>ownership</em>, <em>move</em>, <em>reference</em>, <em>mutable reference</em> 等概念。所以我定义了这些概念：</p>
<h4 id="Ownership"><a href="#Ownership" class="headerlink" title="Ownership"></a>Ownership</h4><p>变量拥有它指称的值的所有权。<br>在 Rust 当中，变量拥有它指称的值，即变量（variable）是它指称值（value）的主人（owner），值一次只能有一个主人，一旦主人离开作用域它的值就会被销毁。</p>
<h4 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h4><p>把一个变量的值重新赋值给另一个变量的行为。<br>根据 Ownership 的定义，值一次只能有一个主人，所以此时该值的所有权会被<strong>转移</strong>给另一个变量，原来的变量就丧失了对这个值的所有权，导致的直接影响就是这个变量此后不再可用。</p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>一个变量指向（refer to）值而非拥有该值的所有权的状态。<br>在很多赋值的场景，包括变量赋值或者函数参数赋值，我们并不希望之后原来的变量不再可用，此时可以通过<code>&amp;</code>(ampersands创建一个指向值的引用，将引用进行赋值时不会发生 <em>Move</em>，所以原来的变量依旧可用。这种赋值行为被称为<em>borrow</em>（借用）。结合实际，我们拥有的物品可以出借给别人，别人享有该物品的使用权（Possession），而非所有权（Ownership）。</p>
<h4 id="Mutable-reference"><a href="#Mutable-reference" class="headerlink" title="Mutable reference"></a>Mutable reference</h4><p>标识该引用的值是可变的。</p>
<p>很多场景下，我们希望引用传递的值是可以改变的。此时我们就必须通过<code>&amp;mut</code>标识该引用，否则不允许修改操作发生。值得注意的是，<code>&amp;mut</code>标识要求原来的变量也必须是<code>mut</code>的，这很好理解，可变的变量的引用也得可变。而且为了防止数据竞态条件的发生，在同一个作用域下，<code>&amp;mut</code>的引用只能有一个，因为一旦出现多个可变引用，就可能遭遇不可重复读风险（注意，Rust 保证这里没有并行修改的风险）。而且同一个值的<code>&amp;mut</code>和<code>&amp;</code>的引用不能共存，因为我们不希望一个只读<code>&amp;</code>的值同时还能被写<code>&amp;mut</code>，这样会导致歧义。</p>
<h3 id="解释错误"><a href="#解释错误" class="headerlink" title="解释错误"></a>解释错误</h3><p>澄清了必要概念以后，我们再来回顾上面的代码。先去看一下这个<code>extend</code>函数的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn extend&lt;I&gt;(&amp;mut self, iter: I)</span><br><span class="line">where</span><br><span class="line">    I: IntoIterator&lt;Item = T&gt;, </span><br><span class="line">Extends a collection with the contents of an iterator...</span><br></pre></td></tr></table></figure>
<p>原来<code>v.extend</code>只是一个语法糖，真正的方法调用会把<code>self</code>作为第一个参数传递到<code>extend(&amp;mut self, iter: I)</code>当中。可变引用作为函数参数赋值，那么自然原来的变量也必须声明成可变的。</p>
<p>所以我们照着它的指示修正如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mut v = vec![1, 2, 3]; // 加上一个mut修饰符</span><br><span class="line">v.extend([1, 2, 3].iter().cloned());</span><br></pre></td></tr></table></figure>
<p>这回编译器消停了，利用<code>assert_eq!</code>，我们来验证<code>extend</code>操作的正确性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert_eq!(v, [1, 2, 3, 1, 2, 3]);</span><br></pre></td></tr></table></figure>
<p>另外，值得注意的是，Rust 和我们熟悉的函数式编程有些不同，集合的拼接不会产生一个新的集合，而是对原有的集合进行修改。一般情况下，我们都会警惕可能会出现数据的竞态条件——<strong>多个线程对该集合进行写入操作怎么办？</strong>带着这个问题，我们反思一下什么是数据的竞态条件。</p>
<h3 id="数据竞态条件"><a href="#数据竞态条件" class="headerlink" title="数据竞态条件"></a>数据竞态条件</h3><p>数据竞态条件发生的必要条件有：</p>
<ol>
<li>多个引用同时指向相同的数据；</li>
<li>至少有一个引用在写数据；</li>
<li>对于数据的访问没有同步机制。</li>
</ol>
<p><strong>考察1和2：</strong><br>假如此处有两个引用指向同一个集合，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let mut v = vec![1, 2, 3];</span><br><span class="line">let r1 = &amp;mut v;</span><br><span class="line">let r2 = &amp;mut v;</span><br><span class="line">assert_eq!(r1, r2);</span><br></pre></td></tr></table></figure>
<p>编译器会立即给出编译错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `v` as mutable more than once at a time</span><br><span class="line">--&gt; src/main.rs:13:10</span><br><span class="line">|</span><br><span class="line">12 | let r1 = &amp;mut v;</span><br><span class="line">|          ------ first mutable borrow occurs here</span><br><span class="line">13 | let r2 = &amp;mut v;</span><br><span class="line">|          ^^^^^^ second mutable borrow occurs here</span><br><span class="line">14 | assert_eq!(r1, r2);</span><br><span class="line">| ------------------- first borrow later used here</span><br></pre></td></tr></table></figure>
<p>也就是说，在指定的作用域下只能有一个可变引用。为什么要如此设计呢？在单线程下，这好像并不会出现数据竞争的问题<a target="_blank" rel="noopener" href="https://www.reddit.com/r/rust/comments/95ky6u/why_arent_multiple_mutable_references_allowed_in/">^1</a>。不过考虑到下面这种场景的语义，我们思考一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let mut v = vec![1, 2, 3];</span><br><span class="line">let r1 = &amp;mut v;</span><br><span class="line">let r2 = &amp;mut v;</span><br><span class="line">assert_eq!(r2[1], 2);</span><br><span class="line">*r1 = vec![0]</span><br><span class="line">assert_eq!(r2[1], 2); // 失效</span><br></pre></td></tr></table></figure>
<p>一旦允许r1改变数据，那对于r2而言，它先前持有的数据就已经发生改变甚至失效，再拿来使用就有问题了，在上面这个例子当中，<code>*r1</code>解除引用后被重新赋值，导致v的值随之改变，但是r2并不知情，依旧使用<code>r2[1]</code>导致此处越界。这个问题和数据库中事务的不可重复读（提交读）的隔离级别类似，但是在单线程下这并不能算作充分的理由，只是说在语义层面有细微的不自然，留待后续研究。</p>
<p>蹊跷的是，如果我将两个可变引用放到不同的函数中，同样的逻辑却可以绕过编译器错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = vec![1, 2, 3];</span><br><span class="line">    mut1(&amp;mut v);</span><br><span class="line">    mut2(&amp;mut v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn mut1(v: &amp;mut Vec&lt;i32&gt;) &#123;</span><br><span class="line">    *v = vec![0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn mut2(v: &amp;mut Vec&lt;i32&gt;) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, v[1]); // panicked at &#x27;index out of bounds&#x27; 运行时错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，上述的论述并没有解释清楚在单线程下同一个作用域下限制多个可变引用的根本原因。</p>
<p>对于<code>&amp;mut</code>和<code>&amp;</code>其实也可以做同样的解释。所以<code>&amp;mut</code>和<code>&amp;</code>在 Rust 同一个作用域中无法共存。</p>
<p><strong>考察3：</strong><br>至于在多线程的环境下，是否会出现数据竞态条件，我们得看 Rust 在线程使用方面的限制。在 Rust 的上下文里，使用<code>Thread::spawn</code>的线程时必须 <em>Move</em> 所有权<a target="_blank" rel="noopener" href="http://squidarth.com/rc/rust/2018/06/04/rust-concurrency.html">^2</a>，因为在 Rust 看来，Thread 的 <em>LifeTime</em>（生命周期）会比调用它的函数的生命周期的长，如果不 <em>Move</em> 所有权，那么线程中数据就会在调用函数结束后释放掉变量的内存，导致线程中的数据无效。所以，这样的限制是很有必要的，但反过来想，一旦数据的所有权发生转移，那么多个线程并行修改同样数据的可能性也就不复存在。</p>
<h3 id="构建树状结构"><a href="#构建树状结构" class="headerlink" title="构建树状结构"></a>构建树状结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct Entry &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    children: Vec&lt;Entry&gt; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn tree(path: &amp;Path) -&gt; Entry &#123;</span><br><span class="line">    Entry&#123;</span><br><span class="line">        name: path.file_name()</span><br><span class="line">            .and_then(|name| name.to_str())</span><br><span class="line">            .map_or(String::from(&quot;.&quot;), |str| String::from(str)),</span><br><span class="line">       </span><br><span class="line">        children: if path.is_dir() &#123;</span><br><span class="line">            children(path)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Vec::new()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然是树状结构，定义的结构体就是递归的。这里的<code>struct Entry &#123;&#125;</code>就是一种递归的结构。我想实现的树状结构大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry :: &#123;name, [child]&#125;</span><br><span class="line">child :: entry</span><br></pre></td></tr></table></figure>
<p>Rust 中没有显式的return，最后一个表达式的结果会被当成返回值，所以此处整个<code>Entry</code>结构体会被返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.file_name()</span><br><span class="line"> .and_then(|name| name.to_str())</span><br><span class="line"> .map_or(String::from(&quot;.&quot;), |str| String::from(str)),</span><br></pre></td></tr></table></figure>
<p>这段代码看上去很复杂，但实现的功能其实很简单，目的是为了获取当前文件的文件名。那么逻辑为何如此绕呢？这是由于 Rust 中的多种字符串表示导致的问题，暂按不表。先去看看各个函数的定义。</p>
<p><strong>Path.file_name 的定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub fn file_name(&amp;self) -&gt; Option&lt;&amp;OsStr&gt;</span><br></pre></td></tr></table></figure>
<p><code>and_then</code>是我们常见的<code>flat_map</code>操作在 Rust 中的命名，其目的是为了在两个<code>Option</code>之间实现转换。</p>
<p><strong>OsStr.to_str 的定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub fn to_str(&amp;self) -&gt; Option&lt;&amp;str&gt;</span><br></pre></td></tr></table></figure>
<p>上面的<code>path.file_name().and_then(|name| name.to_str())</code>最终转变成了<code>Option&lt;&amp;str&gt;</code>，在其上调用<code>Option.map_or</code>方法并提供默认值：字符串<code>&quot;.&quot;</code>。为什么要提供默认值呢？这和<code>OsStr</code>到<code>Str</code>的转换密切相关，当我们传入参数<code>&quot;.&quot;</code>时，<code>Path.file_name</code>返回的其实是一个<code>None</code>。</p>
<p>构建了父级的树状结构，我们需要把子级的树状结构也一并完成，最终通过递归，构建出一棵内存中的目录树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fn children(dir: &amp;Path) -&gt; Vec&lt;Entry&gt; &#123;</span><br><span class="line">    fs::read_dir(dir)</span><br><span class="line">        .expect(&quot;unable to read dir&quot;)</span><br><span class="line">        .into_iter()</span><br><span class="line">        .map(|e| e.expect(&quot;unable to get entry&quot;))</span><br><span class="line">        .filter(|e| is_not_hidden(&amp;e))</span><br><span class="line">        .map(|e| e.path())</span><br><span class="line">        .map(|e| tree(&amp;e))</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn is_not_hidden(entry: &amp;DirEntry) -&gt; bool &#123;</span><br><span class="line">    entry</span><br><span class="line">         .file_name()</span><br><span class="line">         .to_str()</span><br><span class="line">         .map(|s| !s.starts_with(&quot;.&quot;))</span><br><span class="line">         .unwrap_or(false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也存在挺多的转换操作，我们一一解释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs::read_dir(dir).expect(&quot;unable to read dir&quot;)</span><br></pre></td></tr></table></figure>
<p>使用<code>expect</code>是因为<code>fs::read_dir</code>返回的是一个<code>Result&lt;ReadDir&gt;</code>，在其上调用<code>expect</code>会尝试解开其中的值，如果有错则会抛出错误。解开的结果类型是<code>ReadDir</code>，它是<code>io::Result&lt;DirEntry&gt;</code>的迭代器，也就是一个目录下的所有类目，可以在上面调用<code>into_iter()</code>创建出可以被消费的迭代器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.map(|e| e.expect(&quot;unable to get entry&quot;))</span><br><span class="line">.filter(|e| is_not_hidden(e))</span><br><span class="line">.map(|e| e.path())</span><br><span class="line">.map(|e| tree(&amp;e))</span><br></pre></td></tr></table></figure>

<p>接着，解开<code>Result&lt;DirEntry&gt;</code>之后，我们把隐藏文件过滤掉，因为<code>filter</code>接收的一个闭包，这个闭包的类型声明是<code>P: FnMut(&amp;Self::Item) -&gt; bool</code>，所以filter接收的所有元素都是引用类型，故调用时无需需声明成<code>is_not_hidden(&amp;e)</code>。</p>
<p>然后利用<code>e.path()</code>获取每个文件的全路径，并依次交给<code>tree</code>去递归构建。经过<code>tree</code>和<code>children</code>两个函数的交替递归，内存中的一棵目录树就被构建出来了。</p>
<p>有了内存中的树状结构，我们接下来就可以渲染这个结构了。具体的做法如下：</p>
<ol>
<li>对于第一层目录名，如果它是最后一个目录，则前缀修饰为<code>L_branch = &quot;└── &quot;</code>；反之，装饰成 <code>T_branch = &quot;├── &quot; </code>。</li>
<li>对于有子目录，如果是其父目录是父级最后一个目录，则前缀装饰为<code>SPACER   = &quot;    &quot;</code>；反之，前缀装饰成 <code>I_branch = &quot;│   &quot;</code>。</li>
</ol>
<h3 id="渲染树状结构"><a href="#渲染树状结构" class="headerlink" title="渲染树状结构"></a>渲染树状结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn render_tree(tree: &amp;Entry) -&gt; Vec&lt;String&gt; &#123;</span><br><span class="line">    let mut names = vec![tree.name]; // error</span><br><span class="line">    let children = &amp;tree.children;</span><br><span class="line">    let children: Vec&lt;_&gt; = children</span><br><span class="line">        .iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .map(|(i, child)| decorate(children.len() - 1 == i, render_tree(child)))</span><br><span class="line">        .flatten()</span><br><span class="line">        .collect();</span><br><span class="line">    </span><br><span class="line">    names.extend(children);</span><br><span class="line"></span><br><span class="line">    names</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会有编译错误，错误信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error[e0507]: cannot move out of `tree.name` which is behind a shared reference</span><br><span class="line">  --&gt; src/main.rs:48:26</span><br><span class="line">   |</span><br><span class="line">48 |     let mut names = vec![tree.name];</span><br><span class="line">   |                          ^^^^^^^^^ move occurs because `tree.name` has type `std::string::string`, which does not implement the `copy` trait</span><br></pre></td></tr></table></figure>
<p>由于<code>tree.name</code>不是标量类型（Scalar Type），它没有实现<code>copy</code> trait（见提示），又因为<code>tree</code>本身是复合类型（Compound Type），<code>tree.name</code>如果发生 <em>Move</em> 的话，包含它的<code>tree</code>就有问题了。为了避免发生这种情况，我们不得不去引用<code>&amp;tree.name</code>。但是一旦加上引用，又会出现类型不匹配的编译错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">59 |     names</span><br><span class="line">   |     ^^^^^ expected struct `std::string::String`, found reference</span><br><span class="line">      |</span><br><span class="line">         = note: expected type `std::vec::Vec&lt;std::string::String&gt;`</span><br><span class="line">                       found type `std::vec::Vec&lt;&amp;std::string::String&gt;`</span><br></pre></td></tr></table></figure>

<p>我们期待的是<code>Vec&lt;String&gt;</code>而不是<code>Vec&lt;&amp;String&gt;</code>，所以需要重新构建出一个<code>String</code>出来。可以使用<code>String::from(&amp;String)</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mut names = vec![String::from(&amp;tree.name)];</span><br></pre></td></tr></table></figure>
<p>这样修改下来，才能保证编译完全通过。但事实上，Rust 给我们提供了一个更加便捷的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mut names = vec![tree.name.to_owned()]</span><br></pre></td></tr></table></figure>
<p>使用<code>to_owned()</code>表示重新拷贝了一份数据，和重新构建一个<code>String</code>出来别无二致。</p>
<h3 id="组合调用"><a href="#组合调用" class="headerlink" title="组合调用"></a>组合调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use std::env;</span><br><span class="line">use std::path::Path;</span><br><span class="line">use std::fs::&#123;self, DirEntry&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let args: Vec&lt;String&gt; = env::args().collect();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, render_tree(&amp;tree(Path::new(&amp;args[1]))).join(&quot;\n&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>render_tree</code> 返回的是<code>Vec&lt;String&gt;</code>，所以为了打印出来，我们将所有元素用<code>&quot;\n&quot;</code> <code>join</code>到一起。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── target</span><br><span class="line">│   └── debug</span><br><span class="line">│       ├── tree</span><br><span class="line">│       ├── incremental</span><br><span class="line">│       │   ├── tree-emhx2ztsyouq</span><br><span class="line">│       │   │   ├── s-fg6t1j15rq-rcdkil.lock</span><br><span class="line">│       │   │   └── s-fg6t1j15rq-rcdkil-2guhg58bq8usk</span><br><span class="line">│       │   │       ├── 2y5hmosay7v21uaa.o</span><br><span class="line">│       │   │       ├── 3bc30huj642htvsl.o</span><br><span class="line">│       │   │       ├── os4trg3bosufhmz.o</span><br><span class="line">│       │   │       ├── 24gploi4fp7jtlzq.o</span><br><span class="line">│       │   │       ├── query-cache.bin</span><br><span class="line">│       │   │       ├── dep-graph.bin</span><br><span class="line">│       │   │       ├── 4x450fwi8c4bpcw1.o</span><br><span class="line">│       │   │       └── work-products.bin</span><br><span class="line">│       │   └── tree-145pnmzdafxnt</span><br><span class="line">│       │       ├── s-fg7zukct1x-1q6vl1v.lock</span><br><span class="line">│       │       └── s-fg7zukct1x-1q6vl1v-2bl7ybv3bt926</span><br><span class="line">│       │           ├── 1hr1ye57pnkjmrbq.o</span><br><span class="line">│       │           ├── 27h2hp0z2xow1ues.o</span><br><span class="line">│       │           ├── 5ed0wukafi4fahkg.o</span><br><span class="line">│       │           ├── 2f0ihwts74qcmxow.o</span><br><span class="line">│       │           ├── 330o0ei85brt7kr4.o</span><br><span class="line">│       │           ├── 4v9apptkodzb8xa6.o</span><br><span class="line">│       │           ├── 1g9e2frs3e2z69pv.o</span><br><span class="line">│       │           ├── 37b06wzocgbel481.o</span><br><span class="line">│       │           ├── 4l05de8rviyudi4f.o</span><br><span class="line">│       │           ├── h6fn9swczh7498b.o</span><br><span class="line">│       │           ├── 316xpau62mt4is8d.o</span><br><span class="line">│       │           ├── 5ekvjec2kf4lmbtt.o</span><br><span class="line">│       │           ├── 1futuyfy32uf6fso.o</span><br><span class="line">│       │           ├── 2h1ucudwsaw3ps8a.o</span><br><span class="line">│       │           ├── 1gotohk3wwy2f6dy.o</span><br><span class="line">│       │           ├── 3b9tgf3uo9qj9m4l.o</span><br><span class="line">│       │           ├── 11nu5z6vt7pkotko.o</span><br><span class="line">│       │           ├── 1iwt54u59d6ic7px.o</span><br><span class="line">│       │           ├── 2knnbzs842y8uh0j.o</span><br><span class="line">│       │           ├── 3ifvzvvypros5ggf.o</span><br><span class="line">│       │           ├── 2z2hec5yokv1i4dp.o</span><br><span class="line">│       │           ├── ya9r48v2sak0pg6.o</span><br><span class="line">│       │           ├── 155em2p8h2hm19ng.o</span><br><span class="line">│       │           ├── 32v7dlio50845m8.o</span><br><span class="line">│       │           ├── 4c1hc1pxl75vi07x.o</span><br><span class="line">│       │           ├── 2yqijaid0vje1zn1.o</span><br><span class="line">│       │           ├── 4vjgrzm4xto1375t.o</span><br><span class="line">│       │           ├── 21iztlljbl6euh9m.o</span><br><span class="line">│       │           ├── 20v9k1fk8kja961x.o</span><br><span class="line">│       │           ├── 4z53k2t8wxm10fyq.o</span><br><span class="line">│       │           ├── bhyzck3ll360qet.o</span><br><span class="line">│       │           ├── 1y3hdwm9ww9b9y5i.o</span><br><span class="line">│       │           ├── 3c44aga3rejf73f6.o</span><br><span class="line">│       │           ├── rj0yv7mdi9un1aq.o</span><br><span class="line">│       │           ├── 50x9vm1j7pl93o9s.o</span><br><span class="line">│       │           ├── 217lokaaxwdhlrx9.o</span><br><span class="line">│       │           ├── 4wnp20b81q6iaxux.o</span><br><span class="line">│       │           ├── 3r82h5ttm93ejtxf.o</span><br><span class="line">│       │           ├── 3ot3q95g45ci1vo6.o</span><br><span class="line">│       │           ├── query-cache.bin</span><br><span class="line">│       │           ├── 39sf80jvxavwpxo3.o</span><br><span class="line">│       │           ├── 8oeuahm3962nobh.o</span><br><span class="line">│       │           ├── cik7i0re2dlsxhk.o</span><br><span class="line">│       │           ├── 1waoie6zpkzqj4ct.o</span><br><span class="line">│       │           ├── 19luckbhcaquztt8.o</span><br><span class="line">│       │           ├── 3g7vkdnj0ai0qhcm.o</span><br><span class="line">│       │           ├── 1rp337sq8mpirnfu.o</span><br><span class="line">│       │           ├── 1b3x8y2m27htwxg6.o</span><br><span class="line">│       │           ├── 41wp4wr46haq7yo6.o</span><br><span class="line">│       │           ├── gupfi67uepu20cm.o</span><br><span class="line">│       │           ├── dep-graph.bin</span><br><span class="line">│       │           ├── 5btmoqde9gzs48ku.o</span><br><span class="line">│       │           ├── 4vmtr5p2n2ar0hfj.o</span><br><span class="line">│       │           ├── work-products.bin</span><br><span class="line">│       │           ├── 2jd13r5ry01uwce0.o</span><br><span class="line">│       │           ├── 54om8xu4dcwmt36o.o</span><br><span class="line">│       │           ├── 3pjvdh4zm61wtvac.o</span><br><span class="line">│       │           ├── 21mzfl756r7eb753.o</span><br><span class="line">│       │           ├── 57o4bjq3o18zq3ji.o</span><br><span class="line">│       │           ├── 4lh6qwni3j9cdda6.o</span><br><span class="line">│       │           └── 4rj8jramt231qg09.o</span><br><span class="line">│       ├── native</span><br><span class="line">│       ├── tree-e27a55060278e1c5.dSYM</span><br><span class="line">│       │   └── Contents</span><br><span class="line">│       │       ├── Resources</span><br><span class="line">│       │       │   └── DWARF</span><br><span class="line">│       │       │       └── tree-e27a55060278e1c5</span><br><span class="line">│       │       └── Info.plist</span><br><span class="line">│       ├── tree.dSYM</span><br><span class="line">│       │   └── Contents</span><br><span class="line">│       │       ├── Resources</span><br><span class="line">│       │       │   └── DWARF</span><br><span class="line">│       │       │       └── tree-5fa2575d1085e7f2</span><br><span class="line">│       │       └── Info.plist</span><br><span class="line">│       ├── tree-e27a55060278e1c5.d</span><br><span class="line">│       ├── examples</span><br><span class="line">│       ├── tree-e27a55060278e1c5</span><br><span class="line">│       ├── deps</span><br><span class="line">│       │   ├── tree-5fa2575d1085e7f2.dSYM</span><br><span class="line">│       │   │   └── Contents</span><br><span class="line">│       │   │       ├── Resources</span><br><span class="line">│       │   │       │   └── DWARF</span><br><span class="line">│       │   │       │       └── tree-5fa2575d1085e7f2</span><br><span class="line">│       │   │       └── Info.plist</span><br><span class="line">│       │   ├── tree-5fa2575d1085e7f2.d</span><br><span class="line">│       │   ├── tree-e27a55060278e1c5.dSYM</span><br><span class="line">│       │   │   └── Contents</span><br><span class="line">│       │   │       ├── Resources</span><br><span class="line">│       │   │       │   └── DWARF</span><br><span class="line">│       │   │       │       └── tree-e27a55060278e1c5</span><br><span class="line">│       │   │       └── Info.plist</span><br><span class="line">│       │   ├── tree-5fa2575d1085e7f2</span><br><span class="line">│       │   ├── tree-e27a55060278e1c5.d</span><br><span class="line">│       │   └── tree-e27a55060278e1c5</span><br><span class="line">│       ├── build</span><br><span class="line">│       └── tree.d</span><br><span class="line">├── Cargo.lock</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习下来的一些主观感觉是 Rust 中的概念繁杂，有些地方的设计确实让人有些迷惑。再加上类型众多（如：OsStr, String），代码很难通过直觉判断写出，需要大量查阅文档才能让编译器消停。所以学习曲线相对陡峭。</p>
<p>不过，语言约束的越多，某种程度上讲，对于程序员而言却是福音。<em>If it compiles, then it works.</em> 的哲学理念在前。学习道阻且长，努力加餐饭。</p>
<hr>
<p><strong>提示</strong><br>一般标量类型都实现了<code>copy</code> trait.</p>
<ul>
<li>所有的整，如：u32</li>
<li>布尔类型，如：true 或 false</li>
<li>字符类型，如：char</li>
<li>浮点数类型，如：f64</li>
<li>当且仅当所有元素都是Copy的元组，如：(i32, i32)是Copy，但是(i32, String)就不是Copy的。</li>
</ul>
<hr>
<p>于2019年9月22日</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2019/05/07/try-embark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ryan Qian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鄢倩">
      <meta itemprop="description" content="Senior Consultant | DevOps Master | Blockchain & Web3 Specialist">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 鄢倩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/07/try-embark/" class="post-title-link" itemprop="url">区块链DApp开发环境 embark 初探</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-05-07 22:42:39 / 修改时间：22:43:49" itemprop="dateCreated datePublished" datetime="2019-05-07T22:42:39+08:00">2019-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/" itemprop="url" rel="index"><span itemprop="name">Blockchain</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="embark是什么"><a href="#embark是什么" class="headerlink" title="embark是什么"></a>embark是什么</h2><p><a target="_blank" rel="noopener" href="http://embark.status.im/">embark</a>是一款特定于Ethereum区块链平台的DApp开发环境，辅助开发者创建、构建编译、测试和部署DApp，可无缝集成计算（EVM）、存储（IPFS&#x2F;Swarm）和网络（Whisper）资源。</p>
<h2 id="embark的便捷之处"><a href="#embark的便捷之处" class="headerlink" title="embark的便捷之处"></a>embark的便捷之处</h2><p>在尝试embark并和truffle框架进行对比之后，我总结以下几个方面的优势：功能全面，上手迅速，反馈快速，可视化程度高，合约可调试。</p>
<h3 id="功能全面"><a href="#功能全面" class="headerlink" title="功能全面"></a>功能全面</h3><p>正如embark<a target="_blank" rel="noopener" href="https://embark.status.im/docs/overview.html">概览</a>所言，embark并不仅仅是一款只提供构建编译、测试部署功能的开发工具，还是一整套的开发环境。它包含了智能合约自动部署，客户端(UI)开发，测试，DApp分布式托管（IPFS&#x2F;Swarm），点对点通信（Whipser）和组件监控、在线IDE及代码调试（Cockpit）等功能。</p>
<p>如果和truffle框架比较，embark几乎包含了它提供的所有功能。不过，embark缺失了truffle在migration方面的功能，基于对不可变基础设施的考量，embark有必要拥抱这项标准实践。</p>
<p>embark考虑了单独开发智能合约的可能性，所以允许开发者在创建项目时只创建智能合约项目结构，通过启用<code> --contracts-only</code>选项。而且在构建编译时，也可以指定<code>embark build --contracts</code>命令单独构建智能合约。</p>
<h3 id="上手迅速"><a href="#上手迅速" class="headerlink" title="上手迅速"></a>上手迅速</h3><p>这个维度虽然有点主观，但是很值得拿出来说。一般学习新的工具，需要花很多时间看文档学习基本概念和操作流程，最恼火的就是熟悉各种配置项，当你左支右绌，手忙脚乱让工具程序跑起来，除了浪费时间，也侧面证明该工具不够成熟、对开发者不友好。</p>
<p>很意外的是，本来以为这么一个大而全的开发环境设置起来一定得耗费不少时间，结果却是除了用<code>yarn global add embark</code>报出一个compiler和yarn不兼容后，改成了<code>npm install -g embark</code>安装，就再没有特别恼人的问题出现了。</p>
<hr>
<p><strong>注意：</strong><br>上面的安装错误其实是因为embark对于yarn的版本有一定的要求，从embark源码中可以得到如下前置条件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;engines&quot;: &#123;</span><br><span class="line">  &quot;node&quot;: &quot;&gt;=8.12.0&quot;,</span><br><span class="line">  &quot;npm&quot;: &quot;&gt;=6.4.1&quot;,</span><br><span class="line">  &quot;yarn&quot;: &quot;&gt;=1.12.3&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>我当前的yarn版本是<em>1.6.0</em>，使用<code>brew upgrade yarn</code>升级到<em>1.15.2</em>就可以全局安装了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn global add embark</span><br><span class="line">...</span><br><span class="line">embark version</span><br><span class="line">4.0.2</span><br></pre></td></tr></table></figure>

<hr>
<p><code>embark run</code>会启动一个命令行中可视化界面，里面会告诉你当前Dapp的状态，包括智能合约是否部署，哪些组件服务可用，最最重要的是它会告诉你接下来你该做什么！在<em>Logs</em>视窗中，embark试图告诉你开发环境确实哪些依赖服务，比如geth节点没有启动（事实上，可以用gananche-cli代替），ipfs节点未侦测到，Cockpit Web UI所在端口还有Dapp服务的入口等等。而console视窗则是命令交互入口，一条<code>help</code>命令就能展示很多有用信息。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-f683bed1ef30c0e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dashboard"><br>以上这些信息都无需查看文档便可以获得，个人觉得从尝试中学习是特别有趣的事情。</p>
<p>我一般拿从零到写出第一行程序的时间作为上手快慢的标准。这行程序是用来试验，未必得手写，所以我选用了truffle自带的样例<code>MetaCoin.sol</code>和<code>ConvertLib.sol</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ConvertLib.sol</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">library ConvertLib&#123;</span><br><span class="line">  function convert(uint amount,uint conversionRate) public pure returns (uint convertedAmount) &#123;</span><br><span class="line">    return amount * conversionRate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// MetaCoin.sol</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line">import &quot;./ConvertLib.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MetaCoin &#123;</span><br><span class="line">  mapping (address =&gt; uint) balances;</span><br><span class="line"></span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _value);</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    balances[msg.sender] = 10001;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendCoin(address receiver, uint amount) public returns(bool sufficient) &#123;</span><br><span class="line">    if (balances[msg.sender] &lt; amount) return false;</span><br><span class="line">    balances[msg.sender] -= amount;</span><br><span class="line">    balances[receiver] += amount;</span><br><span class="line">    emit Transfer(msg.sender, receiver, amount);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getBalanceInEth(address addr) public view returns(uint) &#123;</span><br><span class="line">    return ConvertLib.convert(getBalance(addr), 4);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getBalance(address addr) public view returns(uint) &#123;</span><br><span class="line">    return balances[addr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当把这两个智能合约文件放到项目根目录下<em>contracts&#x2F;<em>目录中后，合约代码被自动编译，并在</em>Contracts</em>视窗中展示出来，状态为<strong>Deployed</strong>，这表明智能合约已经被部署到区块链网络里。之后，我进入Cockpit Web UI，惊喜地发现这个服务俨然就是一个高配版的<a target="_blank" rel="noopener" href="https://etherscan.io/">etherscan.io</a>，通过它不仅可以查看部署之后的合约，甚至还可以调用合约方法。</p>
<p>估算下来，我用embark写完第一行代码的时间基本可以忽略不计。</p>
<h3 id="反馈快速"><a href="#反馈快速" class="headerlink" title="反馈快速"></a>反馈快速</h3><p>写程序都希望其可行性能被快速验证，因为只有这样才能方便快速地迭代出正确功能的程序。我所知道的前端开发者是把这个过程做到极致的群体，比如Liveloading；embark对于智能合约也提供了一致的功能。当修改合约文件并保存时，embark会自动检测变更同时重新编译再部署，这个过程非常快速（当然，embark对于哪些修改的合约需要重新部署是有一定限制的，而且据我观察，这里面有些潜在的bug，比如修改合约constructor中的内容就不会触发重新构建，即便用<code>embark reset</code>也不行，这个和文档的描述有些出入，值得花时间研究下）。</p>
<p>自动重新构建和部署合约对程序员的效率提升很有帮助，但是无法快速验证同样达不到目的。所幸的是，embark不仅提供了Cockpit这样的可视化工具辅助验证合约的正确性，而且还提供embark console，在console中可以调用部署合约的实例，比如：输入<code>Embark (Development) &gt; MetaCoin &lt;ENTER&gt;</code>就能获取部署好的实例，有了合约实例就可以调用其上的方法进行数据校验。</p>
<p>同样重要的是，embark支持js和sol版本测试，我可以像使用truffle一样使用TDD的方式开发DApp了。</p>
<h3 id="可视化程度高"><a href="#可视化程度高" class="headerlink" title="可视化程度高"></a>可视化程度高</h3><p>当在终端中运行<code>embark run</code>时，embark会自动进入<a target="_blank" rel="noopener" href="https://embark.status.im/docs/dashboard.html">可视化界面</a>（dashboard）。这里面监控的信息会实时告诉你DApp开发的状态。除此之外，embark还提供了DApp的Web server，Cockpit Web UI页面，这些绝对是开发DApp极大的助力。</p>
<p>如果不想使用dashboard，可以通过<code>embark run --nodashboard</code>禁用。不过，根据我的经验，禁用dashboard的结果是没法直接拿到进入Cockpit的访问token，还需要运行<code>embark console</code>进入命令行单独获取。</p>
<p>从上面这点来看，embark在组件化方面做得相当出色，虽然功能大而全，但是并没有限制你删减不必要的组件、独立启用感兴趣的组件</p>
<h3 id="合约可调试"><a href="#合约可调试" class="headerlink" title="合约可调试"></a>合约可调试</h3><p>调试合约在以前的开发过程中还是比较难的，不过借助于Cockpit，embark也提供了在线调试的能力。Cockpit内置一个编辑器，它和本地的开发目录保持一致，该编辑器就提供了debug功能。另外，进入Explorer页，我们甚至可以对某次的tx进行debug验证这次合约调用的真实数据流转情况。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-c8292962071caab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Explorer &amp; Debug"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总的来说，embark是一款优秀的区块链开发环境。相比较truffle的专注于合约工程化的努力，embark的功能更加丰富，而且各组件组合性很强。对于开发者而言，快速开发出DApp才是真的诉求，而embark显然在这一方面具备很大的优势。</p>
<h2 id="怎么快速玩转embark"><a href="#怎么快速玩转embark" class="headerlink" title="怎么快速玩转embark"></a>怎么快速玩转embark</h2><p>工具版本号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yarn --version</span><br><span class="line">1.15.2</span><br><span class="line">npm -v</span><br><span class="line">6.4.1</span><br><span class="line">node -v</span><br><span class="line">v10.15.3</span><br><span class="line">embark version</span><br><span class="line">4.0.2</span><br></pre></td></tr></table></figure>
<h3 id="快速使用DApp"><a href="#快速使用DApp" class="headerlink" title="快速使用DApp"></a>快速使用DApp</h3><p>embark默认开发时都是 development 环境，为了对接正确的ganache-cli（模拟以太坊客户端）端口，我们需要修改<code>config/contract.js</code>文件中<code>development/port</code>到ganache-cli默认的8545端口。</p>
<p>先执行<code>embark build  --pipeline development</code>，然后启动<code>embark run</code>，此时就可以在<code>http://localhost:8000</code>查看DApp的界面了。</p>
<h3 id="IPFS分布式托管"><a href="#IPFS分布式托管" class="headerlink" title="IPFS分布式托管"></a>IPFS分布式托管</h3><p>首先得安装IPFS的客户端，然后运行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ipfs init</span><br><span class="line">ipfs daemon</span><br><span class="line">...</span><br><span class="line">Daemon is ready</span><br></pre></td></tr></table></figure>
<p>当ipfs启动完成后，embark的dashboard会显示ipfs节点已连接。此时执行<code>embark upload</code>，构建出来的<em>dist</em>目录就会被分发到ipfs网络，然后就可以通过内容寻址（content-addressed）的方式访问这个静态网站了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-8007519cf8fff2e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IPFS distribution of static pages"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2019/01/24/Digital-wallet-3-mnemonic-sentence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ryan Qian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鄢倩">
      <meta itemprop="description" content="Senior Consultant | DevOps Master | Blockchain & Web3 Specialist">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 鄢倩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/24/Digital-wallet-3-mnemonic-sentence/" class="post-title-link" itemprop="url">创建数字钱包（三）助记词</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-24 22:39:13" itemprop="dateCreated datePublished" datetime="2019-01-24T22:39:13+08:00">2019-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-05-07 22:46:22" itemprop="dateModified" datetime="2019-05-07T22:46:22+08:00">2019-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/" itemprop="url" rel="index"><span itemprop="name">Blockchain</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="BIP39解释"><a href="#BIP39解释" class="headerlink" title="BIP39解释"></a>BIP39解释</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>BIP39<a href="%5BBIP39%5D(https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)">^1</a>定义了一种将计算机产生的随机数翻译成人类可读的方式，初衷很简单：结合BIP32<a href="%5BBIP32%5D(https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)">^2</a>，辅助人类记忆产生主密钥的种子。</p>
<h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><ol>
<li>initial entropy (ENT)</li>
<li>check sum (CS)</li>
<li>mnemonic sentence (MS)</li>
<li>wordlists</li>
</ol>
<p>这三者的长度关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS = ENT/32</span><br><span class="line">MS = (ENT + CS)/11 化简成 MS = 3 * CS</span><br></pre></td></tr></table></figure>
<p>举个例子，如果初始熵长度为 128，ENT&#x2F;CS&#x2F;MS组成的关系表格填充如下：</p>
<table>
<thead>
<tr>
<th align="center">ENT</th>
<th align="center">CS</th>
<th align="center">MS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">128</td>
<td align="center">4</td>
<td align="center">12</td>
</tr>
</tbody></table>
<h4 id="初始熵-initial-entropy"><a href="#初始熵-initial-entropy" class="headerlink" title="初始熵 initial entropy"></a>初始熵 initial entropy</h4><p>初始熵可以通过随机数生成器生成，允许的大小在 128-256 bits 范围之内。</p>
<h4 id="校验码-check-sum"><a href="#校验码-check-sum" class="headerlink" title="校验码 check sum"></a>校验码 check sum</h4><p>校验码利用初始熵经过哈希得出，而且长度必须是$ENT&#x2F;32$。</p>
<h4 id="助记词-mnemonic-sentence"><a href="#助记词-mnemonic-sentence" class="headerlink" title="助记词 mnemonic sentence"></a>助记词 mnemonic sentence</h4><p>助记词需要将初始熵和校验码拼接，然后切分成每11位为一组，每一组二进制数转换成十进制数作为索引wordlists的下标，以便提取对应的词汇。以128位的ENT为例，它最终会产生12个词汇。</p>
<h4 id="词汇表-wordlists"><a href="#词汇表-wordlists" class="headerlink" title="词汇表 wordlists"></a>词汇表 wordlists</h4><p>词汇表的构成是有原则可遵守的，其一，词汇之间可辨识性强，英文的词汇在前4个词汇就能有很快速的区分；其二，避免相似的词语，人毕竟是健忘的；其三，词汇应该排过序，便于二分查找。</p>
<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><p>下面利用Nodejs版本的BIP39<a href="%5BNodeJS-BIP39%5D(https://github.com/bitcoinjs/bip39)">^3</a>解释</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">generateMnemonic</span> (strength, rng, wordlist) &#123;</span><br><span class="line">  strength = strength || <span class="number">128</span></span><br><span class="line">  <span class="keyword">if</span> (strength % <span class="number">32</span> !== <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="variable constant_">INVALID_ENTROPY</span>)</span><br><span class="line">  rng = rng || randomBytes</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">entropyToMnemonic</span>(<span class="title function_">rng</span>(strength / <span class="number">8</span>), wordlist)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>generateMnemonic(...)</code>函数的参数rng全称是random number generator，即随机数发生器，默认是randomBytes。此处，ENT的默认长度是128位，运行<code>randomBytes(128/8)</code>将产生了16字节的随机数。然后调用<code>entropyToMnemonic(...)</code>函数生成助记词。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">entropyToMnemonic</span> (entropy, wordlist) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Buffer</span>.<span class="title function_">isBuffer</span>(entropy)) entropy = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(entropy, <span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">  wordlist = wordlist || <span class="variable constant_">DEFAULT_WORDLIST</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 128 &lt;= ENT &lt;= 256</span></span><br><span class="line">  <span class="keyword">if</span> (entropy.<span class="property">length</span> &lt; <span class="number">16</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="variable constant_">INVALID_ENTROPY</span>)</span><br><span class="line">  <span class="keyword">if</span> (entropy.<span class="property">length</span> &gt; <span class="number">32</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="variable constant_">INVALID_ENTROPY</span>)</span><br><span class="line">  <span class="keyword">if</span> (entropy.<span class="property">length</span> % <span class="number">4</span> !== <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="variable constant_">INVALID_ENTROPY</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> entropyBits = <span class="title function_">bytesToBinary</span>([].<span class="property">slice</span>.<span class="title function_">call</span>(entropy))</span><br><span class="line">  <span class="keyword">var</span> checksumBits = <span class="title function_">deriveChecksumBits</span>(entropy)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> bits = entropyBits + checksumBits</span><br><span class="line">  <span class="keyword">var</span> chunks = bits.<span class="title function_">match</span>(<span class="regexp">/(.&#123;1,11&#125;)/g</span>)</span><br><span class="line">  <span class="keyword">var</span> words = chunks.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">binary</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="title function_">binaryToByte</span>(binary)</span><br><span class="line">    <span class="keyword">return</span> wordlist[index]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wordlist === <span class="variable constant_">JAPANESE_WORDLIST</span> ? words.<span class="title function_">join</span>(<span class="string">&#x27;\u3000&#x27;</span>) : words.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>entropyBits是entropy的二进制表示；checksumBits是entropy经由SHA256计算得到的哈希值再截断到CS的长度得来的，调用<code>deriveChecksumBits(...)</code>函数产生checksumBits的逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deriveChecksumBits</span> (entropyBuffer) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">ENT</span> = entropyBuffer.<span class="property">length</span> * <span class="number">8</span></span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">CS</span> = <span class="variable constant_">ENT</span> / <span class="number">32</span></span><br><span class="line">  <span class="keyword">var</span> hash = <span class="title function_">createHash</span>(<span class="string">&#x27;sha256&#x27;</span>).<span class="title function_">update</span>(entropyBuffer).<span class="title function_">digest</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">bytesToBinary</span>([].<span class="property">slice</span>.<span class="title function_">call</span>(hash)).<span class="title function_">slice</span>(<span class="number">0</span>, <span class="variable constant_">CS</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的计算和前面长度关系规则完全吻合，checksumBits通过<code>slice(0, CS)</code>截断得到4位的二进制数。</p>
<p>计算得到entropyBits和checksumBits之后，把它们拼接到一起，得到一组bits，然后按每组11bits分隔，这里使用了正则表达式 <code>bits.match(/(.&#123;1,11&#125;)/g)</code>，正则表达式<code>(.&#123;1,11&#125;)</code>表示对任意1-11个bit进行分组，由于正则默认是最长匹配，所以每11位就被分成了一组。最终，每组二进制数都会被转成十进制数，进而作为词汇表的下标索引对应的词汇，详细见上文的<code>chunks.map(function (binary) ...</code> 过程。</p>
<h3 id="中文词汇表"><a href="#中文词汇表" class="headerlink" title="中文词汇表"></a>中文词汇表</h3><p>BIP39其实并没有定义词汇表，所以不同的自然语言都可以自行实现自己的词汇表。NodeJS版本的BIP39<a href="%5BNodeJS-BIP39%5D(https://github.com/bitcoinjs/bip39)">^3</a>就支持中文的词汇表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mnemonic = bip39.<span class="title function_">generateMnemonic</span>(<span class="number">160</span>, <span class="literal">null</span>, bip39.<span class="property">wordlists</span>.<span class="property">chinese_simplified</span>)</span><br><span class="line">-&gt;</span><br><span class="line"><span class="string">&#x27;定 过 丘 搭 斥 紫 遍 官 寿 穿 贯 别 讯 卵 符&#x27;</span></span><br></pre></td></tr></table></figure>
<p>除了中文的词汇表，它还支持下列词汇，如：繁体中文等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">wordlists</span>: &#123;</span><br><span class="line">    <span class="attr">EN</span>: string[];</span><br><span class="line">    <span class="attr">JA</span>: string[];</span><br><span class="line">    <span class="attr">chinese_simplified</span>: string[];</span><br><span class="line">    <span class="attr">chinese_traditional</span>: string[];</span><br><span class="line">    <span class="attr">english</span>: string[];</span><br><span class="line">    <span class="attr">french</span>: string[];</span><br><span class="line">    <span class="attr">italian</span>: string[];</span><br><span class="line">    <span class="attr">japanese</span>: string[];</span><br><span class="line">    <span class="attr">spanish</span>: string[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="生成BIP32种子"><a href="#生成BIP32种子" class="headerlink" title="生成BIP32种子"></a>生成BIP32种子</h3><p>拿到助记词之后，就可以从助记词生成种子。这里其实使用了pbkdf2算法，不过有趣的是，参数mnemonic反而是pdkdf2算法中的password参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function mnemonicToSeed (mnemonic, password) &#123;</span><br><span class="line">  var mnemonicBuffer = Buffer.from(unorm.nfkd(mnemonic), &#x27;utf8&#x27;)</span><br><span class="line">  var saltBuffer = Buffer.from(salt(unorm.nfkd(password)), &#x27;utf8&#x27;)</span><br><span class="line"></span><br><span class="line">  return pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, &#x27;sha512&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2019/01/24/Digital-wallet-2-hd-wallet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ryan Qian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鄢倩">
      <meta itemprop="description" content="Senior Consultant | DevOps Master | Blockchain & Web3 Specialist">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 鄢倩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/24/Digital-wallet-2-hd-wallet/" class="post-title-link" itemprop="url">创建数字钱包（二）HD Wallet</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-24 22:37:28" itemprop="dateCreated datePublished" datetime="2019-01-24T22:37:28+08:00">2019-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-05-07 22:47:54" itemprop="dateModified" datetime="2019-05-07T22:47:54+08:00">2019-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/" itemprop="url" rel="index"><span itemprop="name">Blockchain</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>BIP 全称是 Bitcoin Improvement Proposals，相当于互联网中RFC (Request for Comments)，它是用来记录草案或者标准的。</p>
<h2 id="BIP32解释"><a href="#BIP32解释" class="headerlink" title="BIP32解释"></a>BIP32解释</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>BIP32定义了Hierarchical deterministic wallets (HD Wallets)，HD指出了这类钱包的两大特征。</p>
<p>第一点特征是层级结构，钱包一般会存储一组key-pair对，这组key-pair对是链状存储，但是HD钱包是树状存储，也就是说它的结构中有根节点，根节点会派生出子节点，子节点又可以派生出子节点。这样做的优势是它可以有选择的把某个层级的一组key-pair对分配出去，这样就可以和组织结构匹配，比如：总部保留根密钥，其它分部用总部派生的密钥；也可以和用途匹配，比如：花钱的和收钱的地址可以分开。</p>
<p>第二点特征是确定性，因为所有的key-pair对都是从同一个根派生出来的，所以只要妥善保管好根（主密钥）就可以在其它的系统中快速地恢复钱包。</p>
<p>层级结构和确定性如下图示：<br><img src="https://upload-images.jianshu.io/upload_images/217988-02f038826fdc3e69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HD Wallets"></p>
<h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><ol>
<li>Master key</li>
<li>Chain Code</li>
<li>Extended key</li>
</ol>
<h4 id="主密钥及其生成"><a href="#主密钥及其生成" class="headerlink" title="主密钥及其生成"></a>主密钥及其生成</h4><p>主密钥是从一串长度在128到256位的比特序列（种子）中生成的，然后使用HMAC-SHA512计算出64字节序列（称为I），左边32字节（称为IL）作为主私钥，右边32字节（称为IR）作为主Chain Code。</p>
<p>大致步骤如下：</p>
<ol>
<li>生成熵为128 - 256bit 的种子</li>
<li>I &#x3D; HMAC-SHA512(key&#x3D;”Bitcoin seed”, data &#x3D; seed)</li>
<li>&lt;&lt;IL :: bytes(32), LR :: bytes(32) &gt;&gt; &#x3D; I</li>
<li>MasterSecretKey &#x3D; IL &amp; MasterChainCode &#x3D; IR</li>
</ol>
<p>这里有个问题值得探讨，这样生成的 MasterSecretKey 是符合 secp256k1 定义的利用ECDSA算法生成的私钥吗？我们可以利用secp256k1.privateKeyVerify(…)方法验证，结果是正确的。</p>
<h4 id="额外的熵-Chain-Code"><a href="#额外的熵-Chain-Code" class="headerlink" title="额外的熵 Chain Code"></a>额外的熵 Chain Code</h4><p>因为每个父密钥都可以派生出很多子密钥，所以为了避免子密钥直接依赖父密钥，需要引入额外的熵（chain code）去增强父密钥，这个额外的熵，或者说，随机的256位的比特序列就是 Chain Code。</p>
<h4 id="扩展密钥-Extended-Key"><a href="#扩展密钥-Extended-Key" class="headerlink" title="扩展密钥 Extended Key"></a>扩展密钥 Extended Key</h4><p>根据定义，父密钥和Chain Code的组合 (k, c) 就是扩展私钥，而扩展公钥则是 (K, c)，其中的 K 是通过 secp256k1 计算私钥 k 得到的。</p>
<p>Extended Key 在序列化的地方也值得关注，具体的规则，可以细读BIP32。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// publicKey</span><br><span class="line">03795fd38bbffdddb24b72af417cf3fa540db8f60783dd32f61f0ca5af464fd492</span><br><span class="line">// ExtendedPublicKey</span><br><span class="line">xpub6GmbjntbdLF4JNhBxwoRBrdw2BBujvJ514tRHFMQaoFA5eSRaWwr6CQSGq1HtirLGSTT8SHqMGWQk4rbZLJsVFA4NLZZYUR25ZEdhnGJ7R1</span><br></pre></td></tr></table></figure>
<p>序列化之后的publicKey的首部4比特是版本号，比如此处的xpub就是mainnet的意思。</p>
<p>每个扩展密钥都有$2^{31}$个普通子密钥和$2^{31}$个Hardened子密钥，一般会用i+$2^{31}$表示Hardened子密钥，记为$I_H$。</p>
<h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>这里，我们使用hdkey[^1]进行代码解释。</p>
<h4 id="主密钥及其生成-1"><a href="#主密钥及其生成-1" class="headerlink" title="主密钥及其生成"></a>主密钥及其生成</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">MASTER_SECRET</span> = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;Bitcoin seed&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">HDKey</span>.<span class="property">fromMasterSeed</span> = <span class="keyword">function</span> (<span class="params">seedBuffer, versions</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> I = crypto.<span class="title function_">createHmac</span>(<span class="string">&#x27;sha512&#x27;</span>, <span class="variable constant_">MASTER_SECRET</span>).<span class="title function_">update</span>(seedBuffer).<span class="title function_">digest</span>()</span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">IL</span> = I.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">IR</span> = I.<span class="title function_">slice</span>(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> hdkey = <span class="keyword">new</span> <span class="title class_">HDKey</span>(versions)</span><br><span class="line">  hdkey.<span class="property">chainCode</span> = <span class="variable constant_">IR</span></span><br><span class="line">  hdkey.<span class="property">privateKey</span> = <span class="variable constant_">IL</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hdkey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>seedBuffer是128-256bit的随机序列作为种子，然后利用HMAC-SHA512生成I值，分割出的IL和IR分别赋值给privateKey和chainCode。</p>
<h4 id="Chain-code"><a href="#Chain-code" class="headerlink" title="Chain code"></a>Chain code</h4><p>Chain code 会在派生子密钥的时候起作用，derive(path) -&gt; deriveChild(index) 是派生子密钥的过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>([<span class="variable language_">this</span>.<span class="property">publicKey</span>, indexBuffer])</span><br><span class="line"><span class="keyword">var</span> I = crypto.<span class="title function_">createHmac</span>(<span class="string">&#x27;sha512&#x27;</span>, <span class="variable language_">this</span>.<span class="property">chainCode</span>).<span class="title function_">update</span>(data).<span class="title function_">digest</span>()</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IL</span> = I.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IR</span> = I.<span class="title function_">slice</span>(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hd = <span class="keyword">new</span> <span class="title class_">HDKey</span>(<span class="variable language_">this</span>.<span class="property">versions</span>)</span><br><span class="line"><span class="comment">// Private parent key -&gt; private child key</span></span><br><span class="line"><span class="comment">// ki = parse256(IL) + kpar (mod n)</span></span><br><span class="line">hd.<span class="property">privateKey</span> = secp256k1.<span class="title function_">privateKeyTweakAdd</span>(<span class="variable language_">this</span>.<span class="property">privateKey</span>, <span class="variable constant_">IL</span>)</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看到，chainCode用来作为HMAC-SHA512的密钥对data进行了哈希处理。最终子密钥privateKey通过secp256k1.privateKeyTweakAdd(…)生成，这个函数来自secp256k1[^2]库，主要功能是拼接，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">privateKeyTweakAdd</span> = <span class="keyword">function</span> (<span class="params">privateKey, tweak</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> bn = <span class="variable constant_">BN</span>.<span class="title function_">fromBuffer</span>(tweak)</span><br><span class="line">  <span class="keyword">if</span> (bn.<span class="title function_">isOverflow</span>()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(messages.<span class="property">EC_PRIVATE_KEY_TWEAK_ADD_FAIL</span>)</span><br><span class="line"></span><br><span class="line">  bn.<span class="title function_">iadd</span>(<span class="variable constant_">BN</span>.<span class="title function_">fromBuffer</span>(privateKey))</span><br><span class="line">  <span class="keyword">if</span> (bn.<span class="title function_">isOverflow</span>()) bn.<span class="title function_">isub</span>(<span class="variable constant_">BN</span>.<span class="property">n</span>)</span><br><span class="line">  <span class="keyword">if</span> (bn.<span class="title function_">isZero</span>()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(messages.<span class="property">EC_PRIVATE_KEY_TWEAK_ADD_FAIL</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bn.<span class="title function_">toBuffer</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，在derive(path)函数中，我们会看到Hardened判断的条件是是否带有单引号，例如：<code>44&#39;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var hardened = (c.length &gt; 1) &amp;&amp; (c[c.length - 1] === &quot;&#x27;&quot;)</span><br><span class="line">var childIndex = parseInt(c, 10) // &amp; (HARDENED_OFFSET - 1)</span><br><span class="line">assert(childIndex &lt; HARDENED_OFFSET, &#x27;Invalid index&#x27;)</span><br><span class="line">if (hardened) childIndex += HARDENED_OFFSET</span><br><span class="line"></span><br><span class="line">hdkey = hdkey.deriveChild(childIndex)</span><br></pre></td></tr></table></figure>
<p>在后续介绍BIP44的过程中，我们会明白这样处理的含义，Path为<code>m/44&#39;/60&#39;/0&#39;/0/0</code>在BIP44中有特定的含义，这种表示法和BIP32的结合点就在这里。</p>
<h3 id="Extended-key"><a href="#Extended-key" class="headerlink" title="Extended key"></a>Extended key</h3><p>Extended key 可以分为 privateExtendedKey 和 publicExtendedKey，这里以 privateExtendedKey 为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cs.<span class="title function_">encode</span>(<span class="title function_">serialize</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">versions</span>.<span class="property">private</span>, <span class="title class_">Buffer</span>.<span class="title function_">concat</span>([<span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="variable language_">this</span>.<span class="property">privateKey</span>])))</span><br></pre></td></tr></table></figure>
<p>其中versionls.private，默认值是0x0488ADE4，encode操作可以忽略，具体的序列化逻辑发生在serialize中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">serialize</span> (hdkey, version, key) &#123;</span><br><span class="line">  <span class="comment">// =&gt; version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)</span></span><br><span class="line">  <span class="keyword">var</span> buffer = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="variable constant_">LEN</span>)</span><br><span class="line"></span><br><span class="line">  buffer.<span class="title function_">writeUInt32BE</span>(version, <span class="number">0</span>)</span><br><span class="line">  buffer.<span class="title function_">writeUInt8</span>(hdkey.<span class="property">depth</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fingerprint = hdkey.<span class="property">depth</span> ? hdkey.<span class="property">parentFingerprint</span> : <span class="number">0x00000000</span></span><br><span class="line">  buffer.<span class="title function_">writeUInt32BE</span>(fingerprint, <span class="number">5</span>)</span><br><span class="line">  buffer.<span class="title function_">writeUInt32BE</span>(hdkey.<span class="property">index</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">  hdkey.<span class="property">chainCode</span>.<span class="title function_">copy</span>(buffer, <span class="number">13</span>)</span><br><span class="line">  key.<span class="title function_">copy</span>(buffer, <span class="number">45</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量<code>LEN</code>为78，这就是序列化的结构大小。需要注意的点是，按照定义这里的字节序都是大端（Big Endian，也成为网络字节序）。</p>
<h2 id="BIP44解释"><a href="#BIP44解释" class="headerlink" title="BIP44解释"></a>BIP44解释</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>BIP44 定义了逻辑上的层级结构，所谓逻辑，就是人为赋予意义。BIP44综合了BIP32的HD Wallet设计和BIP43[^3]的Purpose约定，使得HD Wallet能够表达多币种，多账号，账号的外部或内部key-pair对构成的组，外部指的是地址对外可见，专门用来接收或发送数字货币的地址；而内部则是对外不可见，多用来表达找零 (change) 的概念。</p>
<h3 id="主要概念-1"><a href="#主要概念-1" class="headerlink" title="主要概念"></a>主要概念</h3><p>BIP44在BIP32的路径中定义了5个层级：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m / purpose&#x27; / coin_type&#x27; / account&#x27; / change / address_index</span><br></pre></td></tr></table></figure>
<ul>
<li>Purpose: <code>44&#39;</code>or 0x8000002C 这表明后面的子密钥都遵从BIP44的约定</li>
<li>Coin type: <code>0&#39;</code> 代表比特币，<code>60&#39;</code> 代表以太币</li>
<li>Account: 代表不同的用户身份，比如：储蓄或者收款账户，以及各种开支账户</li>
<li>Change: 0 表示外部key-pair组；1 代表内部key-pair组，比如专门用来找零的地址</li>
<li>Address_index: 根据BIP32，地址会生成多个，可以从0开始索引</li>
</ul>
<p>Purpose, Coin type以及Account都有单引号，意味着它们都是Hardened密钥，而Change和Address_index则是Normal的密钥。这样做是为了安全，BIP32中提到了一个事实，如果知道了父级的ExtendedPublicKey及其派生出来的Non-hardened private key，就等于知道了父级的ExtendedPrivateKey，这就是Hardened密钥存在的理由。引文如下：</p>
<blockquote>
<p>One weakness that may not be immediately obvious, is that knowledge of a parent extended public key plus any non-hardened private key descending from it is equivalent to knowing the parent extended private key (and thus every private and public key descending from it). This means that extended public keys must be treated more carefully than regular public keys. It is also the reason for the existence of hardened keys, and why they are used for the account level in the tree. This way, a leak of account-specific (or below) private key never risks compromising the master or other accounts.</p>
</blockquote>
<h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><p>继续使用hdkey[^1]来解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let hdWallet = hdkey.fromMasterSeed(seed)</span><br><span class="line">let key = hdWallet.derivePath(&quot;m/44&#x27;/60&#x27;/0&#x27;/0/0&quot;)</span><br><span class="line">console.log(&quot;publicKey:&quot;, key1._hdkey._publicKey.toString(&quot;hex&quot;), &quot;\nextendPublicKey:&quot;, key1.publicExtendedKey())</span><br><span class="line">-&gt;</span><br><span class="line">publicKey: 03795fd38bbffdddb24b72af417cf3fa540db8f60783dd32f61f0ca5af464fd492 </span><br><span class="line">extendPublicKey: xpub6GmbjntbdLF4JNhBxwoRBrdw2BBujvJ514tRHFMQaoFA5eSRaWwr6CQSGq1HtirLGSTT8SHqMGWQk4rbZLJsVFA4NLZZYUR25ZEdhnGJ7R1</span><br></pre></td></tr></table></figure>
<p>依据前面提到的定义，通过路径<code>m/44&#39;/60&#39;/0&#39;/0/0</code>派生出了以太坊某个外部账户下的第一个地址。</p>
<p>[^1]: <a target="_blank" rel="noopener" href="https://github.com/cryptocoinjs/hdkey">NodeJS - hdkey</a></p>
<p>[^2]: <a target="_blank" rel="noopener" href="https://github.com/cryptocoinjs/secp256k1-node">NodeJS - secp256k1</a></p>
<p>[^3]: <a target="_blank" rel="noopener" href="https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki">BIP43 - Purpose scheme</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2019/01/23/Digital-wallet-1-generate-accounts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ryan Qian">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鄢倩">
      <meta itemprop="description" content="Senior Consultant | DevOps Master | Blockchain & Web3 Specialist">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 鄢倩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/23/Digital-wallet-1-generate-accounts/" class="post-title-link" itemprop="url">创建数字钱包（一）账号生成</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-23 22:35:30" itemprop="dateCreated datePublished" datetime="2019-01-23T22:35:30+08:00">2019-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-05-07 22:46:07" itemprop="dateModified" datetime="2019-05-07T22:46:07+08:00">2019-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/" itemprop="url" rel="index"><span itemprop="name">Blockchain</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="椭圆曲线数字签名算法生成私钥"><a href="#椭圆曲线数字签名算法生成私钥" class="headerlink" title="椭圆曲线数字签名算法生成私钥"></a>椭圆曲线数字签名算法生成私钥</h2><p><a target="_blank" rel="noopener" href="https://en.bitcoin.it/wiki/Secp256k1">Secp256k1</a><br>通过椭圆曲线数字签名算法生成私钥和公钥，其中SEC（Standards for Efficient Cryptography）是专门利用ECDSA或者其可选项Schnorr算法来产生高效的加密方法。<br>特点是生成密钥很快。</p>
<p>Scep256k1 基本特性</p>
<ul>
<li>secp256k1 ECDSA signing&#x2F;verification and key generation.</li>
<li>Adding&#x2F;multiplying private&#x2F;public keys.</li>
<li>Serialization&#x2F;parsing of private keys, public keys, signatures.</li>
<li>Constant time, constant memory access signing and pubkey generation.</li>
<li>Derandomized DSA (via RFC6979 or with a caller provided function.)</li>
<li>Very efficient implementation.</li>
</ul>
<h2 id="讲解代码"><a href="#讲解代码" class="headerlink" title="讲解代码"></a>讲解代码</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>生成私钥</li>
<li>加密私钥</li>
<li>生成 keyObject 对象</li>
<li>从keyObject对象中恢复私钥</li>
</ol>
<h3 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h3><p>下面利用 keythereum[^1] 产生符合以太坊的密钥，并产生keyObject文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123; <span class="attr">keyBytes</span>: <span class="number">32</span>, <span class="attr">ivBytes</span>: <span class="number">16</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;privateKey, salt, iv&#125; = keythereum.<span class="title function_">create</span>(params);</span><br></pre></td></tr></table></figure>
<p>keythereum可以产生私钥，以及后面加密私钥所用的PBKDF2算法需要的salt，和加密aes-128-ctr私钥的iv值。</p>
<p>得到私钥之后，我们可以通过私钥生成公钥。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> privateKeyBuffer = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(privateKey, <span class="string">&quot;hex&quot;</span>) <span class="comment">// or &quot;base64&quot;</span></span><br><span class="line"><span class="keyword">let</span> publicKey = secp256k1.<span class="title function_">publicKeyCreate</span>(privateKeyBuffer, <span class="literal">false</span>).<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> address = <span class="string">&quot;0x&quot;</span> + <span class="title function_">keccak256</span>(publicKey).<span class="title function_">slice</span>(-<span class="number">20</span>).<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="加密私钥"><a href="#加密私钥" class="headerlink" title="加密私钥"></a>加密私钥</h3><p>利用KDF算法基于password派生出密钥，然后利用这个密钥加密我们的私钥。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> password = <span class="string">&quot;Hello,Ethereum&quot;</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">kdf</span>: <span class="string">&quot;pbkdf2&quot;</span>,</span><br><span class="line">    <span class="attr">cipher</span>: <span class="string">&quot;aes-128-ctr&quot;</span>,</span><br><span class="line">    <span class="attr">kdfparams</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="number">262144</span>,</span><br><span class="line">        <span class="attr">dklen</span>: <span class="number">32</span>,</span><br><span class="line">        <span class="attr">prf</span>: <span class="string">&quot;hmac-sha256&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> keyObject = keythereum.<span class="title function_">dump</span>(password, privateKey, salt, iv, options);</span><br></pre></td></tr></table></figure>
<p>这就是产生keyObject基本思路。我们在看看dump函数到底做了什么</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">marshal</span>(<span class="variable language_">this</span>.<span class="title function_">deriveKey</span>(password, salt, options), privateKey, salt, iv, options);</span><br></pre></td></tr></table></figure>
<p>deriveKey(…) 的源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">crypto</span>.<span class="title function_">pbkdf2Sync</span>(</span><br><span class="line">        password,</span><br><span class="line">        salt,</span><br><span class="line">        options.<span class="property">kdfparams</span>.<span class="property">c</span> || <span class="variable language_">this</span>.<span class="property">constants</span>.<span class="property">pbkdf2</span>.<span class="property">c</span>,</span><br><span class="line">        options.<span class="property">kdfparams</span>.<span class="property">dklen</span> || <span class="variable language_">this</span>.<span class="property">constants</span>.<span class="property">pbkdf2</span>.<span class="property">dklen</span>,</span><br><span class="line">        prf <span class="comment">//hmac-sha256</span></span><br><span class="line">      );</span><br></pre></td></tr></table></figure>
<p>这里基于password生成的derivedKey，这个密钥并不是我们要用的私钥，而是用来加密先前生成的privateKey的，加密的过程在marshal函数中调用的encrypt函数里。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ciphertext = <span class="variable language_">this</span>.<span class="title function_">encrypt</span>(privateKey, derivedKey.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">16</span>), iv, algo).<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>encrypt函数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var cipher, ciphertext;</span><br><span class="line">algo = algo || this.constants.cipher;</span><br><span class="line">if (!this.isCipherAvailable(algo)) throw new Error(algo + &quot; is not available&quot;);</span><br><span class="line"></span><br><span class="line">//加密过程</span><br><span class="line">cipher = this.crypto.createCipheriv(algo, this.str2buf(key), this.str2buf(iv));</span><br><span class="line">ciphertext = cipher.update(this.str2buf(plaintext));</span><br><span class="line"></span><br><span class="line">return Buffer.concat([ciphertext, cipher.final()]);</span><br></pre></td></tr></table></figure>
<p>此处的ciphertext代表的是privateKey，而key则是derivedKey</p>
<h3 id="生成-keyObject-对象"><a href="#生成-keyObject-对象" class="headerlink" title="生成 keyObject 对象"></a>生成 keyObject 对象</h3><p>得到了加密后的ciphertext之后，开始组装keyObject对象并返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">keyObject = &#123;</span><br><span class="line">      address: this.privateKeyToAddress(privateKey).slice(2),</span><br><span class="line">      crypto: &#123;</span><br><span class="line">        cipher: options.cipher || this.constants.cipher,</span><br><span class="line">        ciphertext: ciphertext,</span><br><span class="line">        cipherparams: &#123; iv: iv.toString(&quot;hex&quot;) &#125;,</span><br><span class="line">        mac: this.getMAC(derivedKey, ciphertext)</span><br><span class="line">      &#125;,</span><br><span class="line">      id: uuid.v4(), // random 128-bit UUID</span><br><span class="line">      version: 3</span><br><span class="line">    &#125;;</span><br><span class="line">keyObject.crypto.kdf = &quot;pbkdf2&quot;;</span><br><span class="line">      keyObject.crypto.kdfparams = &#123;</span><br><span class="line">        c: options.kdfparams.c || this.constants.pbkdf2.c,</span><br><span class="line">        dklen: options.kdfparams.dklen || this.constants.pbkdf2.dklen,</span><br><span class="line">        prf: options.kdfparams.prf || this.constants.pbkdf2.prf,</span><br><span class="line">        salt: salt.toString(&quot;hex&quot;)</span><br><span class="line">      &#125;;    </span><br></pre></td></tr></table></figure>
<p>privateKeyToAddress(…)方法里首先通过privateKey产生publicKey，然后使用keccak256哈希publicKey得到地址。</p>
<p>具体实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> privateKeyBuffer = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(privateKey);</span><br><span class="line"><span class="keyword">let</span> publicKey = secp256k1.<span class="title function_">publicKeyCreate</span>(privateKeyBuffer, <span class="literal">false</span>).<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> address = <span class="string">&quot;0x&quot;</span> + <span class="title function_">keccak256</span>(publicKey).<span class="title function_">slice</span>(-<span class="number">20</span>).<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>keccak256(publicKey) 产生了32bytes，截取尾部20bytes转换成十六进制之后就是40字符，加上前导0x之后，就是42个字符的以太坊地址，比如：<em>0x0f645438395206b408e52be4fcf4bc21c330bfa2</em></p>
<h3 id="从keyObject对象中恢复私钥"><a href="#从keyObject对象中恢复私钥" class="headerlink" title="从keyObject对象中恢复私钥"></a>从keyObject对象中恢复私钥</h3><p>有了keyObject和密码就可以恢复原来的私钥</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> privateKey = keythereum.<span class="title function_">recover</span>(password, keyObject)</span><br></pre></td></tr></table></figure>
<p>可以想到，recover方法中，首先会利用password和keyObject中的salt派生出当初的密钥derivedKey，然后把加密过的私钥ciphertext和derivedKey, iv作为原来加密算法aes-128-ctr的输入参数，成功解密后返回明文的私钥。</p>
<p>具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">verifyAndDecrypt</span>(<span class="variable language_">this</span>.<span class="title function_">deriveKey</span>(password, salt, keyObjectCrypto), salt, iv, ciphertext, algo)</span><br></pre></td></tr></table></figure>
<p>这里首先得到了derivedKey，然后验证并解密kyeObject中的ciphertext，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">verifyAndDecrypt</span>(<span class="params">derivedKey, salt, iv, ciphertext, algo</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> key;</span><br><span class="line">  <span class="keyword">if</span> (self.<span class="title function_">getMAC</span>(derivedKey, ciphertext) !== keyObjectCrypto.<span class="property">mac</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;message authentication code mismatch&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (keyObject.<span class="property">version</span> === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">    key = <span class="title function_">keccak256</span>(derivedKey.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">16</span>)).<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    key = derivedKey.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self.<span class="title function_">decrypt</span>(ciphertext, key, iv, algo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的mac值比较，确保了ciphertext没有被人篡改才有解密的必要。</p>
<h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/cryptocoinjs/secp256k1-node">NodeJS</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/bitcoin-core/secp256k1">Bitcoin-core</a><br>[^1]: <a target="_blank" rel="noopener" href="https://github.com/ethereumjs/keythereum">Keythereum</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Ryan Qian</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>






  <script src="/js/third-party/addtoany.js"></script>

  





</body>
</html>
