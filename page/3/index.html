<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qianyan.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Elegance and familiarity are orthogonal">
<meta property="og:type" content="website">
<meta property="og:title" content="λ">
<meta property="og:url" content="https://qianyan.github.io/page/3/index.html">
<meta property="og:site_name" content="λ">
<meta property="og:description" content="Elegance and familiarity are orthogonal">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lambeta">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://qianyan.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>λ</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">λ</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">(conj clojurians me)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lambeta</p>
  <div class="site-description" itemprop="description">Elegance and familiarity are orthogonal</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2017/09/17/release-jar-to-clojars/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/09/17/release-jar-to-clojars/" class="post-title-link" itemprop="url">如何发布jar到clojars</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-17 21:39:40" itemprop="dateCreated datePublished" datetime="2017-09-17T21:39:40+08:00">2017-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2017-09-20 07:28:25" itemprop="dateModified" datetime="2017-09-20T07:28:25+08:00">2017-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Clojure/" itemprop="url" rel="index"><span itemprop="name">Clojure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Clojars-介绍"><a href="#Clojars-介绍" class="headerlink" title="Clojars 介绍"></a>Clojars 介绍</h2><p>Clojars 是一个为开源 Clojure 类库打造的仓库，截止2017年9月17日，大概有19831个项目发布在上面。整个网站也是用 Clojure 编写的。</p>
<h2 id="发布-Clojure-library"><a href="#发布-Clojure-library" class="headerlink" title="发布 Clojure library"></a>发布 Clojure library</h2><h3 id="1-注册-clojars"><a href="#1-注册-clojars" class="headerlink" title="1. 注册 clojars"></a>1. 注册 clojars</h3><p>前往 <a target="_blank" rel="noopener" href="https://clojars.org/register">clojars</a> 注册</p>
<h3 id="2-lein-部署"><a href="#2-lein-部署" class="headerlink" title="2. lein 部署"></a>2. lein 部署</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lein deploy clojars # lein deploy [repository name], here the repo name is clojars.</span><br></pre></td></tr></table></figure>
<p>如果不想加上 <code>clojars</code> 参数，则需要在当前项目下的 <em>project.clj</em> 添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;:deploy-repositories [[&quot;releases&quot; :clojars]</span><br><span class="line">                       [&quot;snapshots&quot; :clojars]]&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里注意一点：</strong><br>这里使用 <code>:deploy-repositories</code> 而非 <code>:repositories</code>，原因是 <code>:repositories</code> 除了用于部署还会作为依赖源被项目使用。所以，如若必要，还是职责单一点好。这样，也可以加入 <em>:user profile (~&#x2F;.lein&#x2F;profiles.clj)</em> 供所有本地项目发布使用。</p>
<p>这个时候可以执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ lein deploy</span><br><span class="line">No credentials found for snapshots(did you mean `lein deploy clojars`?) </span><br><span class="line"># 这里应该是 leiningen 的 bug，提示信息 `lein deploy clojars` 显得很奇怪，可以忽略之。</span><br><span class="line">See `lein help deploying` for how to configure credentials to avoid prompts.</span><br><span class="line">Username: username</span><br><span class="line">Password: password</span><br></pre></td></tr></table></figure>
<p>如上，这时会弹出用户名和密码输入框。为了节省时间，避免每次输入，最好把用户凭证 (credentials) 以文件的形式存放到用户范围的目录下，即*~&#x2F;.lein&#x2F;credentials.clj*，并做加密处理。</p>
<h3 id="3-设置全局的-credentials-map"><a href="#3-设置全局的-credentials-map" class="headerlink" title="3. 设置全局的 credentials map"></a>3. 设置全局的 credentials map</h3><p>首先，把如下的 credentials map 写入 <em>~&#x2F;.lein&#x2F;credentials.clj</em></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="regex">#&quot;https://clojars.org/repo&quot;</span> &#123;<span class="symbol">:username</span> <span class="string">&quot;username_on_clojars&quot;</span> <span class="symbol">:password</span> <span class="string">&quot;password_on_clojars&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>其次，使用 gpg 加密该文件</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --default-recipient-self -e \</span><br><span class="line">    ~/.lein/credentials.clj &gt; ~/.lein/credentials.clj.gpg</span><br></pre></td></tr></table></figure>
<p>加密后，即可删除原文件 <em>~&#x2F;.lein&#x2F;credentials.clj</em>。然后在<code>:deploy-repositories</code> map 中指定 <code>:creds :gpg</code></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="symbol">:deploy-repositories</span> [[<span class="string">&quot;releases&quot;</span> <span class="symbol">:clojars</span></span><br><span class="line">                        <span class="symbol">:creds</span> <span class="symbol">:gpg</span>]]</span><br><span class="line">                       [<span class="string">&quot;snapshots&quot;</span> <span class="symbol">:clojars</span></span><br><span class="line">                        <span class="symbol">:creds</span> <span class="symbol">:gpg</span>]]&#125;</span><br></pre></td></tr></table></figure>
<p>完成上述，<code>lein deploy</code> 的时候即可解密 <code>~/.lein/credentials.clj.gpg</code>，从中获取对应仓库的<code>username</code>和<code>password</code>（<strong>注：</strong>为了便于索引查找，credentials 使用正则表达式 #”<a target="_blank" rel="noopener" href="https://clojars.org/repo">https://clojars.org/repo</a>“ 作为 key）</p>
<h2 id="Error-gpg-agent-timeout"><a href="#Error-gpg-agent-timeout" class="headerlink" title="Error: gpg agent timeout"></a>Error: gpg agent timeout</h2><p>有时候，deploy 时会出现 gpg agent 超时的错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ lein deploy</span><br><span class="line">gpg: problem with the agent: Timeout</span><br><span class="line">gpg: decryption failed: No secret key</span><br><span class="line">Could not decrypt credentials from /Users/qianyan/.lein/credentials.clj.gpg</span><br><span class="line">nil</span><br><span class="line">See `lein help gpg` for how to install gpg.</span><br></pre></td></tr></table></figure>
<p>仔细搜索<a target="_blank" rel="noopener" href="https://github.com/technomancy/leiningen/blob/master/doc/DEPLOY.md#gpg">文档</a>会发现下面这句很重要的话</p>
<blockquote>
<p>Due to a bug in gpg you currently need to use gpg-agent and have already unlocked your key before Leiningen launches, but with gpg-agent you only have to enter your passphrase periodically; it will keep it cached for a given period.</p>
</blockquote>
<p>大意是，leiningen 需要用到 gpg-agent，而且在 <code>lein deploy</code> 之前，就应该解锁密钥。</p>
<p>不实际操作的话，还是很难弄懂这句话具体的指代。我们不妨思考一下。</p>
<h3 id="1-看看后台是否有个进程叫做-gpg-agent？"><a href="#1-看看后台是否有个进程叫做-gpg-agent？" class="headerlink" title="1. 看看后台是否有个进程叫做 gpg-agent？"></a>1. 看看后台是否有个进程叫做 gpg-agent？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef |grep gpg</span></span><br><span class="line">  501 87095     1   0  8:27PM ??         0:00.00 gpg-agent --daemon</span><br></pre></td></tr></table></figure>
<p>嗯，还真有！</p>
<h3 id="2-gpg-直接解密-credentials-clj-gpg"><a href="#2-gpg-直接解密-credentials-clj-gpg" class="headerlink" title="2. gpg 直接解密 credentials.clj.gpg"></a>2. gpg 直接解密 credentials.clj.gpg</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --decrypt ~/.lein/credentials.clj.gpg</span></span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Yan Qian (lambeta) &lt;qianyan.lambda@gmail.com&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID E13DFD8A, created 2016-05-14 (main key ID 3C5030FF)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来，漫无止境的等待中...</span></span><br></pre></td></tr></table></figure>
<p>这奇怪的等待让我不安，所以我使出了杀手锏 <code>kill -9</code>，直接把 gpg-agent 干掉。</p>
<h3 id="3-重新-gpg-–decrypt"><a href="#3-重新-gpg-–decrypt" class="headerlink" title="3. 重新 gpg –decrypt"></a>3. 重新 gpg –decrypt</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --decrypt ~/.lein/credentials.clj.gpg</span></span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Yan Qian (lambeta) &lt;qianyan.lambda@gmail.com&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID E13DFD8A, created 2016-05-14 (main key ID 3C5030FF)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里要输入 passphrase</span></span><br><span class="line">gpg: encrypted with 2048-bit RSA key, ID E13DFD8A, created 2016-05-14</span><br><span class="line">      &quot;Yan Qian (lambeta) &lt;qianyan.lambda@gmail.com&gt;&quot;</span><br><span class="line">&#123; #&quot;https://clojars.org/repo&quot; &#123;:username &quot;username_on_clojars&quot; :password &quot;password_on_clojars&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>终于可以输入 passphrase 了，解密完成。这大概就是上面引文所说的 unlock your key before Leiningen launches.</p>
<h3 id="4-重新部署"><a href="#4-重新部署" class="headerlink" title="4. 重新部署"></a>4. 重新部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lein deploy</span></span><br><span class="line">Created /Users/qianyan/Projects/clojure-pr/clj-moco/target/clj-moco-0.1.0-SNAPSHOT.jar</span><br><span class="line">Wrote /Users/qianyan/Projects/clojure-pr/clj-moco/pom.xml</span><br><span class="line">Retrieving clj-moco/clj-moco/0.1.0-SNAPSHOT/maven-metadata.xml</span><br><span class="line">    from https://clojars.org/repo/</span><br><span class="line">Sending clj-moco/clj-moco/0.1.0-SNAPSHOT/clj-moco-0.1.0-20170917.122837-4.jar (10k)</span><br><span class="line">    to https://clojars.org/repo/</span><br><span class="line">Sending clj-moco/clj-moco/0.1.0-SNAPSHOT/clj-moco-0.1.0-20170917.122837-4.pom (3k)</span><br><span class="line">    to https://clojars.org/repo/</span><br><span class="line">Retrieving clj-moco/clj-moco/maven-metadata.xml</span><br><span class="line">    from https://clojars.org/repo/</span><br><span class="line">Sending clj-moco/clj-moco/0.1.0-SNAPSHOT/maven-metadata.xml (1k)</span><br><span class="line">    to https://clojars.org/repo/</span><br><span class="line">Sending clj-moco/clj-moco/maven-metadata.xml (1k)</span><br><span class="line">    to https://clojars.org/repo/</span><br></pre></td></tr></table></figure>
<p>没有出现 gpg-agent timeout 的错误，部署完成。</p>
<hr>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--default-recipient-self</span><br><span class="line">    Use the default key as default recipient if option --recipient is not used and don’t ask if this is a valid one.</span><br><span class="line">    The default key is the first one from the secret keyring or the one set with --default-key.</span><br></pre></td></tr></table></figure></h2><p>参考链接<br>[1] <a target="_blank" rel="noopener" href="https://github.com/technomancy/leiningen/blob/master/doc/DEPLOY.md">Leiningen Deployment</a><br>[2] <a target="_blank" rel="noopener" href="https://www.gnupg.org/documentation/manuals/gnupg-devel/GPG-Configuration-Options.html#GPG-Configuration-Options">GPG: How to change the configuration</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2017/09/15/release-jar-to-maven-central-repository/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/09/15/release-jar-to-maven-central-repository/" class="post-title-link" itemprop="url">如何发布Jar包到Maven Central Repository</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-15 22:29:07" itemprop="dateCreated datePublished" datetime="2017-09-15T22:29:07+08:00">2017-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2017-09-18 21:40:57" itemprop="dateModified" datetime="2017-09-18T21:40:57+08:00">2017-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="太长不读篇"><a href="#太长不读篇" class="headerlink" title="太长不读篇"></a>太长不读篇</h2><ol>
<li>在 <a target="_blank" rel="noopener" href="https://issues.sonatype.org/secure/Signup!default.jspa">issues tracker</a> 上注册</li>
<li>创建 <a target="_blank" rel="noopener" href="https://issues.sonatype.org/browse/OSSRH-33944">issues</a></li>
<li>配置 <a target="_blank" rel="noopener" href="https://github.com/qianyan/underscore.string.java/blob/master/build.gradle">build.gradle</a></li>
<li>gpg 生成 key pair 以便签名</li>
<li>上传 Release Archive</li>
<li>关闭并验证 <a target="_blank" rel="noopener" href="https://oss.sonatype.org/">Staging 环境</a>的 Archive</li>
<li>发布 Archive</li>
<li>通知 issue 管理员开启同步</li>
</ol>
<h2 id="细读篇"><a href="#细读篇" class="headerlink" title="细读篇"></a>细读篇</h2><h3 id="1-注册"><a href="#1-注册" class="headerlink" title="1. 注册"></a>1. 注册</h3><p>Maven Central 网站并不提供注册的功能，你需要到 Sonatype 网站上进行注册。而事实上，Sonatype 网站也没有直接提供一个注册链接。真正的注册入口在 <a target="_blank" rel="noopener" href="https://issues.sonatype.org/secure/Signup!default.jspa">issues tracker</a> 上。一旦完成注册后，你需要创建包含待发布包信息的 issue。</p>
<h3 id="2-创建-issue"><a href="#2-创建-issue" class="headerlink" title="2. 创建 issue"></a>2. 创建 issue</h3><p><img src="http://upload-images.jianshu.io/upload_images/217988-502c1f4fc580c120.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建 issues"><br>在 Sonatype 的 <a target="_blank" rel="noopener" href="https://issues.sonatype.org/secure/Dashboard.jspa">dashboard</a> 上点击创建按钮，根据弹出框的提示，填写简介、描述、GroupId、Project URL、SCM url 以及你在 jira 上的用户名。创建完毕后，会被自动跳转到该 issue 的详情页并分配一个唯一的ID，如：OSSRH-33944。余下的时间只需要等待，一般在两个工作日之内，Sonatype 的工作人员就会着手处理，然后他会在该 issue 底下的评论区留言。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-29e35a58393f39ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建成功的 issue"></p>
<p>如果代码是托管在 github 上，按照惯例，GroupId 应该取 github 上的域名，比如：com.github.qianyan。不过，这里我预备上传的包的 GroupId 是 com.lambeta，这是我购买的域名。审核者对此有所顾虑，所以很贴心地留言如下：</p>
<blockquote>
<p>Do you own the domain lambeta.com? If not, please read:<br><a target="_blank" rel="noopener" href="http://central.sonatype.org/pages/choosing-your-coordinates.html">http://central.sonatype.org/pages/choosing-your-coordinates.html</a><br>You may also choose a groupId that reflects your project hosting, in this case, something like io.github.qianyan or com.github.qianyan</p>
</blockquote>
<p>在回复这个域名确实为我所有之后，工作人员就贴出不同环境的仓库地址。</p>
<blockquote>
<p>Configuration has been prepared, now you can:<br>Deploy snapshot artifacts into repository <a target="_blank" rel="noopener" href="https://oss.sonatype.org/content/repositories/snapshots">https://oss.sonatype.org/content/repositories/snapshots</a><br>Deploy release artifacts into the staging repository <a target="_blank" rel="noopener" href="https://oss.sonatype.org/service/local/staging/deploy/maven2">https://oss.sonatype.org/service/local/staging/deploy/maven2</a><br>Promote staged artifacts into repository ‘Releases’<br>Download snapshot and release artifacts from group <a target="_blank" rel="noopener" href="https://oss.sonatype.org/content/groups/public">https://oss.sonatype.org/content/groups/public</a><br>Download snapshot, release and staged artifacts from staging group <a target="_blank" rel="noopener" href="https://oss.sonatype.org/content/groups/staging">https://oss.sonatype.org/content/groups/staging</a><br><strong>please comment on this ticket when you promoted your first release, thanks</strong></p>
</blockquote>
<p><strong>最后一句很重要</strong>，说的是，当我第一次正式发布的时候，需要留言告知工作人员，以便他们开启中央仓库的同步，这样我的包才会在 Maven Central 仓库中可见。</p>
<h3 id="3-配置项目的-build-gradle"><a href="#3-配置项目的-build-gradle" class="headerlink" title="3. 配置项目的 build.gradle"></a>3. 配置项目的 build.gradle</h3><p>拿到仓库地址，我们就需要在自己的项目中进行一些必要的配置，包含：jar、sourcesJar、javadocJar 以及对这些产物的 signing（签名）。</p>
<h4 id="maven-插件"><a href="#maven-插件" class="headerlink" title="maven 插件"></a>maven 插件</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven&#x27;</span></span><br></pre></td></tr></table></figure>
<p>maven 插件提供了 uploadArchives task，我们需要在这个 task 中配置仓库地址，以及 pom 的相关信息，因为上载到 maven 仓库的包必须要有 pom 文件，否则无法查找或被依赖。具体配置如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            beforeDeployment &#123; deployment -&gt; signing.signPom(deployment) &#125;</span><br><span class="line"></span><br><span class="line">            repository(<span class="attr">url:</span> <span class="string">&quot;https://oss.sonatype.org/service/local/staging/deploy/maven2/&quot;</span>) &#123;</span><br><span class="line">                authentication(<span class="attr">userName:</span> ossrhUsername, <span class="attr">password:</span> ossrhPassword)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            snapshotRepository(<span class="attr">url:</span> <span class="string">&quot;https://oss.sonatype.org/content/repositories/snapshots&quot;</span>) &#123;</span><br><span class="line">                authentication(<span class="attr">userName:</span> sonatypeUsername, <span class="attr">password:</span> sonatypePassword)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pom.project &#123;</span><br><span class="line">                name project.name</span><br><span class="line">                packaging <span class="string">&#x27;jar&#x27;</span></span><br><span class="line">                description <span class="string">&#x27;underscore string in java&#x27;</span></span><br><span class="line">                url <span class="string">&#x27;https://github.com/qianyan/underscore.string.java&#x27;</span></span><br><span class="line"></span><br><span class="line">                scm &#123;</span><br><span class="line">                    url <span class="string">&#x27;https://github.com/qianyan/underscore.string.java&#x27;</span></span><br><span class="line">                    connection <span class="string">&#x27;https://github.com/qianyan/underscore.string.java.git&#x27;</span></span><br><span class="line">                    developerConnection <span class="string">&#x27;git@github.com:qianyan/underscore.string.java.git&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name <span class="string">&#x27;MIT Licence&#x27;</span></span><br><span class="line">                        url <span class="string">&#x27;https://raw.githubusercontent.com/qianyan/underscore.string.java/master/LICENSE&#x27;</span></span><br><span class="line">                        distribution <span class="string">&#x27;repo&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        id <span class="string">&#x27;lambeta&#x27;</span></span><br><span class="line">                        name <span class="string">&#x27;Yan Qian&#x27;</span></span><br><span class="line">                        email <span class="string">&#x27;qianyan.lambeta@gmail.com&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应生成的 pom.xml 大致如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>underscore.string.java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>underscore string in java<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/qianyan/underscore.string.java<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>MIT Licence<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://raw.githubusercontent.com/qianyan/underscore.string.java/master/LICENSE<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>lambeta<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Yan Qian<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">email</span>&gt;</span>qianyan.lambeta@gmail.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">connection</span>&gt;</span>https://github.com/qianyan/underscore.string.java.git<span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>git@github.com:qianyan/underscore.string.java.git<span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/qianyan/underscore.string.java<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> <code>authentication(userName: ossrhUsername, password: ossrhPassword)</code> 和 <code>authentication(userName: sonatypeUsername, password: sonatypePassword)</code>，这里的用户名和密码其实就是在 Sonatype 上注册的用户名和密码。为了让 gradle 脚本顺利执行，需要在当前工程下的 gradle.properties 文件中设置对应的变量，如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sonatypeUsername=</span><br><span class="line">sonatypePassword=</span><br><span class="line">ossrhUsername=</span><br><span class="line">ossrhPassword=</span><br></pre></td></tr></table></figure>
<p>这份文件会作为源代码的一部分提交，所以聪明的我们不会傻傻地把自己的用户名和密码 push 到 github 上面。和大部分 *nix 系统上的工具类似，gradle 也有本地配置，我们可以新建一份 gradle.properties 文件到 <code>~/.gradle/gradle.properties</code>，然后把用户名和密码写入其中。这样，实际运行时，本地配置就会覆盖项目下对应的这些变量值。</p>
<h4 id="4-设置-gpg-以签名-Archive"><a href="#4-设置-gpg-以签名-Archive" class="headerlink" title="4. 设置 gpg 以签名 Archive"></a>4. 设置 gpg 以签名 Archive</h4><p><a target="_blank" rel="noopener" href="https://gnupg.org/">gpg</a> 生成的 key pair 主要是供签名使用的。假定本机已经安装 gpg，首先使用 gpg 生成 key pair。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --gen-key</span></span><br></pre></td></tr></table></figure>
<p>然后，查找你的 keyId：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --list-keys</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-&gt;</span></span><br><span class="line">pub   2048R/XXXXXX 2017-09-14 [expires: 2018-05-14]</span><br><span class="line">uid       [ultimate] Yan Qian (lambeta) &lt;qianyan.lambeta@gmail.com&gt;</span><br></pre></td></tr></table></figure>
<p>其中 XXXXXX 就是你的 keyId。接下来必须发布你的公钥：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --keyserver hkp://pgp.mit.edu --send-keys XXXXXX</span></span><br></pre></td></tr></table></figure>
<p>验证公钥已经发布成功：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --keyserver hkp://pgp.mit.edu --search-keys qianyan.lambeta@gamil.com <span class="comment"># user email address</span></span></span><br></pre></td></tr></table></figure>
<p>当然，上述操作都可以使用 <a target="_blank" rel="noopener" href="https://gpgtools.org/">gpg tools</a> 在 UI 上完成。</p>
<h4 id="signing-插件"><a href="#signing-插件" class="headerlink" title="signing 插件"></a>signing 插件</h4><p>完成上述步骤之后，我们需要在 build.gradle 中添加 signing 插件及其配置，如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;signing&#x27;</span></span><br><span class="line"></span><br><span class="line">signing &#123;</span><br><span class="line">    required &#123; gradle.taskGraph.hasTask(<span class="string">&quot;uploadArchives&quot;</span>) &#125;</span><br><span class="line">    sign configurations.archives</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置明确了 gradle task 的 DAG 中必须含有 uploadArchives，之后针对 archives 进行签名。</p>
<p>signing 插件如何同 gpg 生成 key pair 交互呢？这就需要在<code>~/.gradle/gradle.properties</code>再声明三个变量，如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signing.keyId=XXXXXX</span><br><span class="line">signing.password=your_key_pair_password</span><br><span class="line">signing.secretKeyRingFile=<span class="regexp">/Users/</span>your_name<span class="regexp">/.gnupg/</span>secring.gpg</span><br></pre></td></tr></table></figure>
<p>还剩下最后的一步，归档 Jar，sourceJar（源代码）和javadocJar（API 文档），这些是需要签名的对象。</p>
<h4 id="archive"><a href="#archive" class="headerlink" title="archive"></a>archive</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span></span><br><span class="line"></span><br><span class="line">task sourcesJar(<span class="attr">type:</span> Jar) &#123;</span><br><span class="line">    classifier = <span class="string">&#x27;sources&#x27;</span></span><br><span class="line">    from sourceSets.main.allSource</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task javadocJar(<span class="attr">type:</span> Jar, <span class="attr">dependsOn:</span> javadoc) &#123;</span><br><span class="line">    classifier = <span class="string">&#x27;javadoc&#x27;</span></span><br><span class="line">    from <span class="string">&#x27;build/docs/javadoc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives jar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">    archives javadocJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归档产物最终都会被签名，生成以 .asc 为后缀的签名文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">build/libs</span><br><span class="line">├── underscore.string.java-0.0.1-javadoc.jar</span><br><span class="line">├── underscore.string.java-0.0.1-javadoc.jar.asc</span><br><span class="line">├── underscore.string.java-0.0.1-sources.jar</span><br><span class="line">├── underscore.string.java-0.0.1-sources.jar.asc</span><br><span class="line">├── underscore.string.java-0.0.1.jar</span><br><span class="line">└── underscore.string.java-0.0.1.jar.asc</span><br></pre></td></tr></table></figure>
<p>这些产出物在最终发布的时候，需要经过验证，如果验证失败，比如：缺少 javadoc 或者某个 *.asc 文件，则不被允许发布。</p>
<h3 id="5-上传-Release-Archives"><a href="#5-上传-Release-Archives" class="headerlink" title="5. 上传 Release Archives"></a>5. 上传 Release Archives</h3><p>根据的 maven 的标准，日常开发我们会使用 snapshot 版本，如：0.0.1-SNAPSHOT；发布时，去掉后缀-SNAPSHOT，即：0.0.1。而 maven 会根据这个特点，机智地辨识是上传到 snapshotRepository 还是 releaseRepository 的。因为我们得发布包，所以修改版本为 0.0.1 之后，我们只需要简单地执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gradle uploadArchives <span class="comment"># or `gradle uA` this is a shortcut.</span></span></span><br></pre></td></tr></table></figure>
<h3 id="6-关闭并验证-Staging-环境上的-Archive"><a href="#6-关闭并验证-Staging-环境上的-Archive" class="headerlink" title="6. 关闭并验证 Staging 环境上的 Archive"></a>6. 关闭并验证 Staging 环境上的 Archive</h3><p><img src="http://upload-images.jianshu.io/upload_images/217988-c6a888ec20e93530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="staging Repo"></p>
<p>登录 Sonatype 的 <a target="_blank" rel="noopener" href="https://oss.sonatype.org/">Nexus Repository Manager</a>，然后点击左边侧边栏的 Staging Repositories，搜索<code>comlambeta</code> (GroupId 去掉中间的’.’)。接下来查看 Content tab，重点检查 pom 或者签名文件是否遗漏！当确认无误后，即可关闭 (Close) 这个 Repo。关闭过程中，Nexus 会逐项检查产物是否合规，如果出现验证错误，则在 Activity tab 中显示具体失败的步骤及原因。</p>
<h3 id="7-发布-Archive"><a href="#7-发布-Archive" class="headerlink" title="7. 发布 Archive"></a>7. 发布 Archive</h3><p>如果上面的验证通过，上面本来不可用的 Release 按钮会变为可用。点击 Release 按钮，直接发布包。</p>
<h3 id="8-通知-issue-管理员开启同步"><a href="#8-通知-issue-管理员开启同步" class="headerlink" title="8. 通知 issue 管理员开启同步"></a>8. 通知 issue 管理员开启同步</h3><p>发布包之后，就可以通知管理员开启同步。我在原来的 issue 的评论区留言：</p>
<blockquote>
<p>I have a first release version 0.0.1 for this library.</p>
</blockquote>
<p>很快地，管理员就回复同步已经开启：</p>
<blockquote>
<p>Central sync is activated for com.lambeta. After you successfully release, your component will be published to Central, typically within 10 minutes, though updates to search.maven.org can take up to two hours.</p>
</blockquote>
<p>不过，由于当时所用 gradle2.1 的版本，导致了上传时 pom 文件被遗漏，在 search.maven.org 中搜索不到。管理员很热心地解释了这个现象：</p>
<blockquote>
<p>search.maven.org needs a valid POM file to be a part of your uploaded artifacts. Browsing Maven Central directly:<br><a target="_blank" rel="noopener" href="http://repo1.maven.org/maven2/com/lambeta/underscore.string.java/0.0.1/">http://repo1.maven.org/maven2/com/lambeta/underscore.string.java/0.0.1/</a><br>it appears that a POM file is missing.</p>
</blockquote>
<p>遂升级到 3.1 版本，重新上传之后就能在 <a target="_blank" rel="noopener" href="http://search.maven.org/#search%7Cga%7C1%7Ccom.lambeta">search.maven.org</a> 中看到。</p>
<h3 id="9-检查同步成功"><a href="#9-检查同步成功" class="headerlink" title="9. 检查同步成功"></a>9. 检查同步成功</h3><p>除了通过 <a target="_blank" rel="noopener" href="http://search.maven.org/#search%7Cga%7C1%7Ccom.lambeta">search.maven.org</a> 检查同步是否成功之外，查询<a target="_blank" rel="noopener" href="http://mvnrepository.com/search?q=com.lambeta">mvnrepository</a>也是常用的搜索方式。不过，值得一提的是，mvnrepository 相较于 search.maven.org 同步会更慢点，原因是 mvnrepository 引用了 central.maven.org 仓库。而 <code>central.maven.org == repo1.maven.org</code>，两个域名对应的 IP 是一样的，而这个 repo1.maven.org 就是默认的 Maven central repository，也就是 search.maven.org 的仓库。<br>所以，你可以在以下两个仓库看到发布包：<br><a target="_blank" rel="noopener" href="http://central.maven.org/maven2/com/lambeta/underscore.string.java/">http://central.maven.org/maven2/com/lambeta/underscore.string.java/</a><br><a target="_blank" rel="noopener" href="http://repo1.maven.org/maven2/com/lambeta/underscore.string.java/">http://repo1.maven.org/maven2/com/lambeta/underscore.string.java/</a></p>
<hr>
<p>参考链接<br>[1] <a target="_blank" rel="noopener" href="http://zserge.com/blog/gradle-maven-publish.html">simple library publishing with gradle</a><br>[2] <a target="_blank" rel="noopener" href="http://central.sonatype.org/pages/releasing-the-deployment.html">release deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2017/09/06/Underscore-string-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/09/06/Underscore-string-java/" class="post-title-link" itemprop="url">一个Java中操作字符串的类库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-06 23:02:28" itemprop="dateCreated datePublished" datetime="2017-09-06T23:02:28+08:00">2017-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2017-10-15 20:03:36" itemprop="dateModified" datetime="2017-10-15T20:03:36+08:00">2017-10-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Underscore-string-java-是什么？"><a href="#Underscore-string-java-是什么？" class="headerlink" title="Underscore.string.java 是什么？"></a>Underscore.string.java 是什么？</h2><p><a target="_blank" rel="noopener" href="https://github.com/qianyan/underscore.string.java">underscore.string.java</a> 是一个Java中方便操作字符串的类库，提供了众多帮助方法。</p>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>写过 Javascript 代码的人，估计没有几个不知道 <a target="_blank" rel="noopener" href="http://underscorejs.org/">underscore</a> 这个类库的，因为它太好（有）用了，尽管现如今由于实现上不够优雅的缘故，已经被<a target="_blank" rel="noopener" href="https://lodash.com/">lodash</a>所取代。而我想介绍的是 github 上 star 3000+的 <a target="_blank" rel="noopener" href="https://github.com/epeli/underscore.string">underscore.string</a>，它原本是 underscore 的扩展，不过现在已经演变成独立的库。顾名思义，它的作用就是弥补 Javascript 本身对于字符串操作支持的匮乏。<br>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slugify = <span class="built_in">require</span>(<span class="string">&quot;underscore.string/slugify&quot;</span>);</span><br><span class="line"><span class="title function_">slugify</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">-&gt; hello-world</span><br></pre></td></tr></table></figure>
<p><code>slugify</code>是一种规整字符串的操作，常用于把url中的非法字符规整成 <em>word-word</em> 的模样。比如，我的这篇 blog 是通过 hexo 生成的 <code>hexo new &quot;Underscore.string.java&quot;</code>，它会自动帮我转换成 <em>2017-09-06-Underscore-string-java</em> 这样的亲和url的格式。</p>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>接触这个类库的时候，我正在使用 google <a target="_blank" rel="noopener" href="https://github.com/google/guava">guava</a>，惊讶于这里头的各类操作，包括 ImmutableList、CharMatcher、Strings 等等。一来准备针对 guava 练练手，二来确实想学习一下 underscore.string 的操作，所以就开始着手写起了 <a target="_blank" rel="noopener" href="https://github.com/qianyan/underscore.string.java">underscore.string.java</a> 这个项目。编写的过程中确实学到了不少平常不太可能接触到的设计方法。</p>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>这个类库已经正式发布在 Maven Central Repository. 最新版本是 <a target="_blank" rel="noopener" href="http://search.maven.org/#search%7Cga%7C1%7Cunderscore.string.java">0.2.0</a>.</p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ul>
<li>java &gt;&#x3D; 1.6</li>
<li>guava 18.0</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&#x27;com.lambeta:underscore.string.java:0.2.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lambeta<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>underscore.string.java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="支持的特性"><a href="#支持的特性" class="headerlink" title="支持的特性"></a>支持的特性</h2><ul>
<li>capitalize</li>
<li>slugify</li>
<li>count</li>
<li>trim</li>
<li>ltrim</li>
<li>rtrim</li>
<li>repeat</li>
<li>decapitalize</li>
<li>join</li>
<li>reverse</li>
<li>clean</li>
<li>chop</li>
<li>splice</li>
<li>pred</li>
<li>succ</li>
<li>titleize</li>
<li>camelize</li>
<li>dasherize</li>
<li>underscored</li>
<li>classify</li>
<li>humanize</li>
<li>quote</li>
<li>unquote</li>
<li>surround</li>
<li>numberFormat</li>
<li>strRight</li>
<li>strRightBack</li>
<li>strLeft</li>
<li>strLeftBack</li>
<li>toSentence</li>
<li>truncate</li>
<li>lpad</li>
<li>rpad</li>
<li>lrpad</li>
<li>words</li>
<li>prune</li>
<li>isBlank</li>
<li>replaceAll</li>
<li>swapCase</li>
<li>naturalSort</li>
<li>naturalCmp</li>
<li>dedent</li>
<li>commonPrefix</li>
<li>commonSuffix</li>
<li>chopPrefix</li>
<li>chopSuffix</li>
<li>screamingUnderscored</li>
<li>stripAccents</li>
<li>pascalize</li>
<li>translate</li>
<li>mixedCase</li>
<li>collapseWhitespaces</li>
<li>ascii</li>
<li>chomp</li>
<li>startsWith</li>
<li>endsWith</li>
<li>levenshtein</li>
<li>hamming</li>
<li>longestCommonSubstring</li>
</ul>
<h2 id="New-Features-in-0-2-1-SNAPSHOT"><a href="#New-Features-in-0-2-1-SNAPSHOT" class="headerlink" title="New Features in 0.2.1-SNAPSHOT"></a>New Features in 0.2.1-SNAPSHOT</h2><h3 id="gradle-1"><a href="#gradle-1" class="headerlink" title="gradle"></a>gradle</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url <span class="string">&#x27;https://oss.sonatype.org/content/groups/public&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> (<span class="string">&quot;com.lambeta:underscore.string.java:0.2.1-SNAPSHOT&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="maven-1"><a href="#maven-1" class="headerlink" title="maven"></a>maven</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-repo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>sonatype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://oss.sonatype.org/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lambeta<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>underscore.string.java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>replaceZeroWidthDelimiterWith</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2017/04/27/How-to-active-different-profiles-in-SpringBootTest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/04/27/How-to-active-different-profiles-in-SpringBootTest/" class="post-title-link" itemprop="url">如何在SpringBootTest中启用不同的profiles</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-27 08:39:56" itemprop="dateCreated datePublished" datetime="2017-04-27T08:39:56+08:00">2017-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2017-09-25 16:35:28" itemprop="dateModified" datetime="2017-09-25T16:35:28+08:00">2017-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul>
<li>测试类标注@ActiveProfiles(resolver &#x3D; ProfilesResolver.class)</li>
<li>自定义类 ProfilesResolver 实现接口 ActiveProfilesResolver，并实现接口中唯一的方法<code>resolve(Class&lt;?&gt; targetClass)</code></li>
<li>maven-surefire-plugin 插件中配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;systemPropertyVariables&gt;</span><br><span class="line">    &lt;spring.profiles.active&gt;$&#123;spring.profiles.active&#125;&lt;/spring.profiles.active&gt;</span><br><span class="line">&lt;/systemPropertyVariables&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>实现如下：</p>
<h3 id="1-标注启用"><a href="#1-标注启用" class="headerlink" title="1. 标注启用"></a>1. 标注启用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes = &#123;PetstoreApp.class&#125;, // 我们的 application 名为 PetstoreApp</span><br><span class="line">    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line">@ActiveProfiles(resolver = ProfilesResolver.class)</span><br><span class="line">public abstract class BaseResourceTest &#123;</span><br><span class="line">    @BeforeClass</span><br><span class="line">    public static void setUp() &#123;</span><br><span class="line">        String activeProfiles = System.getProperty(&quot;spring.profiles.active&quot;);</span><br><span class="line">        System.out.println(String.format(&quot;Resource Tests resolved profiles are [%s]&quot;, activeProfiles));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类存在的意义就是为了让其它类别的 ResourceTest 继承它，并在一次启动当中运行完所有的集成测试。避免每个 ResourceTest 都初始化启动 Application，造成运行速度变慢。</p>
<p><strong>注意<code>abstract</code>关键字</strong><br>如果不使用<code>abstract</code>关键字，那么maven-surefire-plugin就会抛出如下错误：</p>
<blockquote>
<p>Tests in error:<br>  BaseResourceTest.initializationError »  No runnable methods</p>
</blockquote>
<h3 id="2-实现自定义类-ProfilesResolver，如下："><a href="#2-实现自定义类-ProfilesResolver，如下：" class="headerlink" title="2. 实现自定义类 ProfilesResolver，如下："></a>2. 实现自定义类 ProfilesResolver，如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.test.context.ActiveProfilesResolver;</span><br><span class="line"></span><br><span class="line">public class ProfilesResolver implements ActiveProfilesResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] resolve(Class&lt;?&gt; aClass) &#123;</span><br><span class="line">        String activeProfiles = System.getProperty(&quot;spring.profiles.active&quot;);</span><br><span class="line"></span><br><span class="line">        return new String[] &#123;activeProfiles != null ? activeProfiles : &quot;local&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里表示我们会从系统变量当中读取<em>spring.profiles.active</em>，但是这个变量从什么地方来呢？<br>我首先想到的是 maven 的 profiles 中设置 properties，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;profile&gt;</span><br><span class="line">        &lt;id&gt;local&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;spring.profiles.active&gt;local&lt;/spring.profiles.active&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">&lt;/profile&gt;</span><br></pre></td></tr></table></figure>
<p>如此，当我们在命令行中运行<code>mvn test -Plocal</code>的时候，就表明启用了 local 这个 profile。相应地，在 maven 的上下文当中，<em>spring.profiles.active</em>变量的值就是<em>local</em>。</p>
<p>但是运行测试的时候，我们 ProfilesResolver 中的<code> System.getProperty(&quot;spring.profiles.active&quot;)</code>返回的始终是<code>null</code>。其实道理很简单，maven 中定义的 properties 全是给 maven 自己（包含各类插件）用的，它并不会<strong>传递</strong>给应用程序使用。</p>
<p><strong>注意：</strong></p>
<hr>
<p>properties 中定义的 spring.profiles.active 其实主要是给插件 maven-resources-plugin 使用的，具体请参看备注。</p>
<hr>
<h3 id="3-定义systemPropertyVariables"><a href="#3-定义systemPropertyVariables" class="headerlink" title="3. 定义systemPropertyVariables"></a>3. 定义<code>systemPropertyVariables</code></h3><p>所以我们需要定义<code>systemPropertyVariables</code>，顾名思义，这是系统变量的定义，在应用程序中就可以使用<code>System.getProperty(&quot;spring.profiles.active&quot;)</code>获得。</p>
<p>放在哪里合适呢？跑测试的插件中最合适！</p>
<p>所以，我们有如下的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;runOrder&gt;alphabetical&lt;/runOrder&gt;</span><br><span class="line">    &lt;systemPropertyVariables&gt;</span><br><span class="line">        &lt;spring.profiles.active&gt;$&#123;spring.profiles.active&#125;&lt;/spring.profiles.active&gt;</span><br><span class="line">    &lt;/systemPropertyVariables&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结合上面 properties 的配置，当我们再次运行<code>mvn test -Plocal</code>的时候，就会得到一个名为<em>spring.profiles.active</em>的系统变量，它的值由<code>$&#123;spring.profiles.active&#125;</code>决定。此处，就是local。</p>
<hr>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p><strong>properties 中 spring.profiles.active 的另外用途</strong><br>只要 maven 的 properties 中定义了 <em>spring.profiles.active</em> ，运行<code>mvn spring-boot:run -Plocal</code>的时候，spring boot 就会启用<code>applicaiton-local.yml</code> profile 文件。</p>
<p>为什么会这样的呢？按常理推断，应该是<em>spring-boot-maven-plugin</em>的配置项自动读取了我们设置的 properties <code>spring.profiles.active</code>，但是只要看一眼这个插件的<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/current/maven-plugin/run-mojo.html#profiles">文档</a>就会发现，除非显式地在插件的<em>configuration</em>下配置了<em>profiles</em>参数或者手动传入<em>run.profiles</em>系统变量<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/current/maven-plugin/examples/run-profiles.html">example</a>，否则插件本身（可以像我一样扫一眼插件的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-tools/spring-boot-maven-plugin/src/main/java/org/springframework/boot/maven/AbstractRunMojo.java">源码</a>）并无法感知到底启用 spring 的哪个 profile！所以这个假设不成立。</p>
<p><strong>答案在<em>bootstrap.yml</em>当中！</strong><br>以下是<em>resources&#x2F;config&#x2F;bootstrap.yml</em>中的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: petstore</span><br><span class="line">    profiles:</span><br><span class="line">        # The commented value for `active` can be replaced with valid Spring profiles to load.</span><br><span class="line">        # *注意底下这句话*</span><br><span class="line">        # Otherwise, it will be filled in by maven when building the WAR file</span><br><span class="line">        # Either way, it can be overridden by `--spring.profiles.active` value passed in the commandline or `-Dspring.profiles.active` set in `JAVA_OPTS`</span><br><span class="line">        active: #spring.profiles.active#</span><br></pre></td></tr></table></figure>
<p>这里的注释很有用，明确地告诉我们在构建 WAR 包的时候，maven 会帮我们把<code>#spring.profiles.active#</code>替换成真正的值。</p>
<p>这又是怎么做到的呢？一切归功于<em>maven-resources-plugin</em>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;maven-resources-plugin.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;default-resources&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;validate&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;copy-resources&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;</span><br><span class="line">                &lt;useDefaultDelimiters&gt;false&lt;/useDefaultDelimiters&gt;</span><br><span class="line">                &lt;delimiters&gt;</span><br><span class="line">                    &lt;delimiter&gt;#&lt;/delimiter&gt; &lt;!-- 看这里 --&gt;</span><br><span class="line">                &lt;/delimiters&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;directory&gt;src/main/resources/&lt;/directory&gt;</span><br><span class="line">                        &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">                        &lt;includes&gt;</span><br><span class="line">                            &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">                            &lt;include&gt;**/*.yml&lt;/include&gt;</span><br><span class="line">                        &lt;/includes&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;directory&gt;src/main/resources/&lt;/directory&gt;</span><br><span class="line">                        &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">                        &lt;excludes&gt;</span><br><span class="line">                            &lt;exclude&gt;**/*.xml&lt;/exclude&gt;</span><br><span class="line">                            &lt;exclude&gt;**/*.yml&lt;/exclude&gt;</span><br><span class="line">                        &lt;/excludes&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                &lt;/resources&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>这个插件除了简单的 copy 功能之外，还能进行 <em>Filtering</em> <a target="_blank" rel="noopener" href="https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html">操作</a>。</p>
<blockquote>
<p>Filtering<br>Variables can be included in your resources. These variables, denoted by the ${…} delimiters, can come from the system properties, your project properties, from your filter resources and from the command line.</p>
</blockquote>
<p>大意是说，你可以在 resources 文件定义自己的变量，这些变量可以来自系统属性、maven 工程属性，你过滤的 resources 文件和命令行。</p>
<p>说白了，就是在 copy 资源文件的时候，同时帮你把文件中的变量（占位符）替换成真实的值。而这里就是通过<code>&lt;delimiter&gt;#&lt;/delimiter&gt;</code>来规定变量格式的！换句话说，在文件中只要是以<code>#</code>开头和结尾的字符串都会被替换掉（变量有定义的情况下；否则保持原样）。</p>
<p>这里，由于绑定了生命周期——validate，可以直接运行<code>mvn validate -Plocal</code>这样的命令进行快速验证。得到的<em>bootstrap.yml</em>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: petstore</span><br><span class="line">    profiles:</span><br><span class="line">        # The commented value for `active` can be replaced with valid Spring profiles to load.</span><br><span class="line">        # Otherwise, it will be filled in by maven when building the WAR file</span><br><span class="line">        # Either way, it can be overridden by `--spring.profiles.active` value passed in the commandline or `-Dspring.profiles.active` set in `JAVA_OPTS`</span><br><span class="line">        active: dev # 替换成功</span><br></pre></td></tr></table></figure>

<p>回到最开始的疑问，为什么只要 maven 的 properties 中定义了 <em>spring.profiles.active</em> ，运行<code>mvn spring-boot:run -Plocal</code>的时候，就可以spring boot 就会启用<code>applicaiton-local.yml</code> profile 文件呢？</p>
<p>因为，maven 在运行命令之前已经做了 copy-resources 的操作，那时候就已经把<em>bootstrap.yml</em>中的<em>spring.profiles.active</em>替换成 local 了，所以启动 springboot application 的时候，它会启用<em>spring.profiles.active</em>代表的值，此处就是 local，那么启用的文件自然就是<em>application-local.yml</em>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2017/04/18/Techniques-for-Efficiently-Learning-Programming-Languages/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/04/18/Techniques-for-Efficiently-Learning-Programming-Languages/" class="post-title-link" itemprop="url">如何高效地学习编程语言</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-04-18 15:15:09 / 修改时间：21:44:20" itemprop="dateCreated datePublished" datetime="2017-04-18T15:15:09+08:00">2017-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Clojure/" itemprop="url" rel="index"><span itemprop="name">Clojure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>这是Clojure好书《Clojure for the Brave and True》作者 Daniel Higginbotham 写于2017年4月16日的博文。从作者的丰富的经验来看，本文非常具有指导意义。</p>
</blockquote>
<p>学习编程语言是一种技巧：做好了，你会感受到掌握新事物之后的快感（dopamine：多巴胺）；做不好，就会接二连三的沮丧，甚至放弃。下面这些学习编程语言的最佳技巧是我从多年的<a target="_blank" rel="noopener" href="http://www.braveclojure.com/">著书</a><a target="_blank" rel="noopener" href="http://www.flyingmachinestudios.com/programming/the-unofficial-guide-to-rich-hickeys-brain/">写作</a>，<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=eRq5UBx6cbA">演讲</a>和<a target="_blank" rel="noopener" href="http://www.braveclojure.com/training/">培训</a>中总结出来的。这里头很多技巧来源于对高效学习前沿研究做了解释的书籍。你可以在 <a target="_blank" rel="noopener" href="http://www.communitypicks.com/r/learnprogramming">Community Picks Learn Programming</a> 中找到那些书（还有其它牛x的编程书籍）。</p>
<h2 id="持续测试自己以抵抗胜任力错觉"><a href="#持续测试自己以抵抗胜任力错觉" class="headerlink" title="持续测试自己以抵抗胜任力错觉"></a>持续测试自己以抵抗胜任力错觉</h2><p>最不济的学习方法中的一种就是重读或者重看材料。这种重复会给你一种感觉——似乎不用花什么气力，你就理解了话题所涵盖的内容。研究者们把这种现象称作胜任力错觉。</p>
<p>更好的一种方式（你可以掌握的最佳技巧之一）则是持续地测试自己。不要重读一个函数、类或者一个对象是什么，而是让自己定义这些概念或者把它们用到短小的程序当中——强迫你用某种方式显示自己的理解。这一过程常常很不舒服的，但是对形成长期记忆非常有效。更进一步，你可以在阅读材料之前先去行测试，举个例子，尝试在阅读一个章节之前做做练习。值得一提的是，这也被证明有助于记忆的形成。</p>
<p>测试对于学习的显著影响被称为<strong>测试效用</strong>，下面是一些具体方法可以利用：</p>
<ul>
<li>在阅读章节或者看视频之前，尝试猜测你将要学习的东西，并写下来。</li>
<li>在阅读章节之前先做做这个章节的练习题。</li>
<li>一直做练习，即使是最难的那些。暂时（永远）放弃一个练习也是可以的，不过至少要尝试一遍。（下个章节会详细谈到）</li>
<li>阅读短小的程序并且尝试不看源码重新写一个。或者，再小一些，写个函数也行。</li>
<li>在学习了对象、类、方法或者高阶函数等新概念之后，立即编码做示例。</li>
<li>创建阐述这些概念的图示，以及这些概念之间的区别和联系。</li>
<li>把你刚刚学到的概念写成博客。</li>
<li>尝试把概念解释给非技术的朋友听。（在写《Clojure for Brave and True》的时候，我常常这么干。这样能够以外行的话阐述一个想法，进而迫使你深入理解想法本身。）</li>
</ul>
<p>这些技巧的大部分都要规约到编写代码上！说到编程，由于程序都是重文本和概念性的，所以很容易以为我们仅仅通过阅读（代码）就在学习。但是程序同时也是一门手艺，就像其它手艺一样你得操练才能娴熟。编码是暴露你对程序作有错误假设的最佳方式。你越快地这么做，就会越快地纠正错误和提升技能。</p>
<p>如果你想了解更多测试效应的事情，敬请查看<a target="_blank" rel="noopener" href="http://www.communitypicks.com/r/learnprogramming/s/17592186047889-make-it-stick-the-science-of-successful-learning">坚持：成功学习的科学（make it stick： The Science of Successful Learning）</a>。</p>
<h2 id="花时间放空自己"><a href="#花时间放空自己" class="headerlink" title="花时间放空自己"></a>花时间放空自己</h2><p>如果你纠结在一个问题上，或者对刚才读到的东西不能理解，就去散散步甚或洗个澡 —— 只要能进入一种舒缓、放空的状态就行。解除障碍的最佳方式之一就是歇一会儿，这可能听上去有点反直觉，但确实如此。</p>
<p>问题是，当全神贯注解决问题时，我们很容易陷入思维障碍（mental blinder）。我的意思是，这差不多就是“关注”（字面上）的意思。不过，全神贯注会导致我们只能一直探索解决方案空间的一小部分。一旦放空，我们的潜意识就可以探索并联结我们经验中的广泛领域。</p>
<p>对我来说，这就像当你试图在纸质地图上找到一个目的地（是否还记得？）。你不用刻意就确信你想抵达的城市应该就在这里！在地图的左上角的区域，所以你看了一遍又一遍，都没有成功。然后你放下地图，做了深呼吸并让目光游离了一会儿。当你重新看地图时，确切的地点立马映入眼帘。</p>
<p>我们曾经都有过这样的经验，在洗澡的时候突发灵感。现在你对于为什么这么做有了更好的了解，那么也就能刻意地使用这个技巧。个人来讲，如果纠结在某事上，我真的会洗个澡，这个技巧的功效显著。另一方面，我又是多么干净（注：洗澡这件事）。</p>
<p>如果你想多学一些关于思考的关注和分散模式，敬请查看<a target="_blank" rel="noopener" href="http://www.communitypicks.com/r/learnprogramming/s/17592186047884-a-mind-for-numbers-how-to-excel-at">A Mind for Numbers: How to Excel at Math and Science (Even If You FLunked Algebra)</a></p>
<h2 id="别浪费时间沮丧"><a href="#别浪费时间沮丧" class="headerlink" title="别浪费时间沮丧"></a>别浪费时间沮丧</h2><p>和上一个章节相关：别浪费时间为代码沮丧了。沮丧会让我们做一些愚蠢的事情，比如重新编译或者重刷浏览器，期望这次会有所不同。</p>
<p>把沮丧看作你的知识有差距的信号。一旦你意识到自己沮丧了，它可以帮你后退一步，清晰地识别问题。如果你写的代码不起作用，坦率地向自己或者别人说明你期望的结果。使用科学的方法，就非预期行为的根因提出一个假说。然后测试你的假说。再次试验后，如果依然解决不了，就把这个问题放到一边，待会儿回来。</p>
<p>在一些似乎没法解决的问题上，我不知有多少次恼怒地扔掉了自己的笔记本电脑。隔天再看，一个显而易见的解决方案立马跳入脑海。甚至上周就发生过。</p>
<h2 id="确认你正在处理语言的哪个方面"><a href="#确认你正在处理语言的哪个方面" class="headerlink" title="确认你正在处理语言的哪个方面"></a>确认你正在处理语言的哪个方面</h2><p>个人观点，我觉得记住这些是有用的——当学习一门编程语言的时候，你实际上正在学四件事情。</p>
<ul>
<li>怎么写代码：语法、语义以及资源管理</li>
<li>语言的范式：面向对象，函数式，逻辑等</li>
<li>产出物的生态圈：如何构建、运行可执行文件以及如何使用库</li>
<li>工具：编辑器，编译器，调试器，代码质量检测器（linter）</li>
</ul>
<p>这四项很容易搞混，不幸的结果是，当你遇到问题最终完全找错了地方。</p>
<p>举个例子，某些完全的编程新手，可能准备开始构建iOS应用。他们可能会试着让自己的应用在朋友的手机上运行，只看得到有关需要开发人员证书或其他信息的消息。这是产出物生态圈的一部分，不过小白可能将此视为编写代码的问题。他们可能会浏览自己写的每行代码来尝试解决问题，尽管问题和代码没有半毛钱关系。</p>
<p>如果我系统地处理这些方面，我会发现学习一种语言会更加容易。我将在其它的博客文章中罗列一些待回答的宽泛问题的列表，应该能帮助你学习任何语言。</p>
<h2 id="明确目的，外部模型，内部模型"><a href="#明确目的，外部模型，内部模型" class="headerlink" title="明确目的，外部模型，内部模型"></a>明确目的，外部模型，内部模型</h2><p>任何时候你学习使用新工具，明确学习的目的，外部模型和内部模型都是十分有用的。</p>
<p>当你了解了工具的目的时，你的大脑会加载有用的上下文细节，使你更容易吸收新知识。这就好比拼图：当你看到完整拼图之后，更容易把各部件拼到一起。这个道理适用于语言本身以及语言库。</p>
<p>工具的外部模型就是它呈现出来的接口以及它想让你思考问题解决的方式。Clojure 的外部模型就是一个 Lisp，它想让你把编程当做大部分以数据为中心，不可变的转换过程。Ansible 希望你把服务器的整备工作想成定义最终状态，而不是定义抵达那种状态所要采取的步骤。</p>
<p>工具的内部模型就是如何将输入到其接口转换成一些底层的抽象。Clojure 把 Lisp 转换成 JVM 的字节码。Ansible 把任务定义转换成了 shell 命令。在一个理想国中，你不需要理解工具的内部模型，但事实上，理解内部模型总是有用的，因为在某些看上去迷惑或者矛盾的部分，它可以让你有个统一视图。举个例子，当 DNA 双螺旋模型被发现的时候，它帮助科学家们了解更高层次的现象。从我的角度来讲，当然，这篇博文也是历来所有伟大科学成就之一。</p>
<p>很多教程经常混淆工具的外部和内部模型，使学习者感到困惑。意识到这点可以帮你轻松辨别何时你会感到沮丧。</p>
<h2 id="间隔重复帮助记忆"><a href="#间隔重复帮助记忆" class="headerlink" title="间隔重复帮助记忆"></a>间隔重复帮助记忆</h2><p>间隔重复被证明是长期记忆中新信息编码的最佳方法之一。 这个想法是以不断增加的时间间隔来测验自己，使用最少重复次数来最小化记忆衰减。 卫报写了一篇<a target="_blank" rel="noopener" href="https://www.theguardian.com/education/2016/jan/23/spaced-repetition-a-hack-to-make-your-brain-store-information">很好的介绍性文章</a>。</p>
<h2 id="睡眠和练习"><a href="#睡眠和练习" class="headerlink" title="睡眠和练习"></a>睡眠和练习</h2><p>保重身体！身体可不仅仅是你脑袋的载体。如果你想保持专注和高效的学习，就要足够的睡眠和练习，而不是（原文：beats the pants off）狂饮咖啡因和能量饮料。</p>
<h2 id="更多小贴士"><a href="#更多小贴士" class="headerlink" title="更多小贴士"></a>更多小贴士</h2><p>如果你还有其它有用的技巧，请不吝评论！如果你想知道更多关于学习编程的优质资源，敬请查看<a target="_blank" rel="noopener" href="http://www.communitypicks.com/r/learnprogramming">Community Picks: Learn Programming</a>，这是一个社区策划编程学习书籍的收集活动，内容广泛，包含入门编程，工艺以及关于软技能和面试方面的书籍。</p>
<hr>
<p>原文链接<br>[1] <a target="_blank" rel="noopener" href="http://www.flyingmachinestudios.com/programming/learn-programming-languages-efficiently/">Techniques for Efficiently Learning Programming Languages</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2017/03/01/Pipleline-as-Code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/03/01/Pipleline-as-Code/" class="post-title-link" itemprop="url">Pipleline as Code</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-03-01 10:19:13 / 修改时间：10:52:12" itemprop="dateCreated datePublished" datetime="2017-03-01T10:19:13+08:00">2017-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>2016年11月份的技术雷达中给出了一个简明的定义：流水线即代码 (Pipeline as Code) 通过编码而非配置持续集成&#x2F;持续交付 (CI&#x2F;CD) 运行工具的方式定义部署流水线。<br>其实早在2015年11月份的技术雷达当中就已经有了类似的概念：</p>
<blockquote>
<p>The way to avoid programming in your CI&#x2F;CD tool is to extract the complexities of the build process from the guts of the tool and into a simple script which can be invoked by a single command. This script can then be executed on any developer workstation and therefore eliminates the privileged&#x2F;singular status of the build environment<br>大意是将复杂的构建流程纳入一个简单的脚本文件，然后用一条命令调用。这样，任意的开发者都能在自己的工作区中执行脚本重建一套一模一样的构建环境，从而消除 CI&#x2F;CD 环境由于散乱配置腐化而成的特异性。这么做的原因很好理解，使用 CI&#x2F;CD 工具是为了暴露产品代码中的问题的，如果它们自身已经复杂到不稳定的地步，我们还使用它就是自找麻烦。</p>
</blockquote>
<p>从某种程度上看，实施流水线即代码是不证自明的。在 CI&#x2F;CD 的时间过程中，凡是可以被编码的东西都已经被代码化了，比如：构建、测试、数据库迁移、部署和基础设施&#x2F;环境配置 (Infrastruture as Code) 等。说得烂俗点，流水线已经是 CI&#x2F;CD 实践过程中的“最后一公里”，让流水线变成软件开发中的“一等公民”（即代码）是大势所趋、民心所向。不过，这种论断毕竟欠缺说服力，我们接着从实践的痛点出发总结当前流水线遇到的问题。</p>
<h2 id="实践中的痛点"><a href="#实践中的痛点" class="headerlink" title="实践中的痛点"></a>实践中的痛点</h2><p>我给客户搭建和配置过不少 CI&#x2F;CD 流水线（被同事戏谑地称为“CI&#x2F;CD搭建兽”），最大的痛苦莫过于每次都得从头来过，即便大部分情况下所用的工具和配置都大同小异。其次是手工操作产生的配置漂移 (configuration drift) 。以 Jenkins 为例，先不谈 1.0 版本不支持流水线这一概念的问题，我们为了解决遇到的构建、测试和部署等问题，一般会在多个文本框中粘贴大量 shell&#x2F;batch 脚本；甚至会通过这些文本框安装各种插件或者依赖包、设置环境变量等等。久而久之（实际上不需要多久），这台 Jenkins 服务器就变得不可替代（特异化）了，因为没人清楚到底对它做了哪些更改以及这些更改对承载它的系统产生哪些影响，这时 Jenkins 服务器俨然腐化成了老马所说的雪花服务器 (snowflake server)。雪花服务器有两点显著的特征：</p>
<ol>
<li>特别难以复现</li>
<li>几乎无法理解</li>
</ol>
<p>第一点是由于以往所做的更改并没有被记录下来，所以做过的操作都是七零八落的，没有办法复现同样的操作，也无法复制一个同样的系统。<br>第二点则是由于绝大部分情况下散乱的配置是没有文档描述的，哪部分是重要的已经无从知晓，改动的风险很大。</p>
<p>这些问题会在流水线的演化过程中恶化得越来越严重。一般来讲，除非不再使用，否则流水线不会保持一成不变。具体实施过程中，考虑到项目，尤其是遗留项目当前的特点和团队成员的“产能”，我们会先将构建和部署自动化；部署节奏稳定后，开始将单元测试和代码分析自动化；接着可以指导测试人员将验收测试自动化；然后尝试将发布自动化。在这之后，就要开始持续优化流水线，包括 CI 的速度和稳定性等。换句话说，流水线的演化其实是和项目的当前进展密切相关的，保证这样的对应关系有时是有必要的，比如：在版本控制下，多发布分支所需流水线和主干分支会存在不同。发布分支是主干分支某个时刻分出去的，它需要在那时的流水线上才能正常工作。由于前面所说雪花服务器的特征，重建这样一条流水线并不是一件容易的事情。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-e8d3fcb49a100197.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="演进式的持续集成"></p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>其实，流水线即代码本身已经回答这个问题了。当前实现了这一概念的工具大体遵循了两种模式：</p>
<ol>
<li>版本控制</li>
<li>DSL（领域特定语言）</li>
</ol>
<p>对于特别难以复现、没有保证对应关系的痛点，我们就把流水线写成代码放到版本控制工具中管理起来。这样一来，每一次更改都能被记录下来，而且它会始终和此时的项目进展保持同步。</p>
<p>对于几乎无法理解、没有文档支持的痛点，我们就选用领域特定语言描述整条流水线。举个 Jenkins 2.0 例子，它允许我们在项目的特定目录下放置一个 Jenkinsfile 的文件，内容大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">node(&#x27;master&#x27;) &#123;</span><br><span class="line">	stage(&#x27;Checkout&#x27;) &#123;…&#125;</span><br><span class="line">	stage(&#x27;Code Analysis&#x27;) &#123;…&#125;</span><br><span class="line">	stage(&#x27;Unit Test&#x27;) &#123;…&#125;</span><br><span class="line">	stage(&#x27;Packing&#x27;) &#123;…&#125;</span><br><span class="line">	stage(&#x27;Archive&#x27;) &#123;…&#125;</span><br><span class="line">	stage(&#x27;DEV&#x27;) &#123;…&#125;</span><br><span class="line">&#125;</span><br><span class="line">stage(&#x27;SIT&#x27;) &#123;</span><br><span class="line">	timeout(time:4, unit:&#x27;HOURS&#x27;) &#123;</span><br><span class="line">		input &quot;Deploy to SIT?&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	node(&#x27;master&#x27;) &#123;…&#125;</span><br><span class="line">&#125;</span><br><span class="line">stage(&#x27;Acceptance Test&#x27;) &#123;</span><br><span class="line">	node(&#x27;slave&#x27;) &#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Jenkins 2.0 使用Groovy实现了一套描述流水线的DSL，即便不了解Groovy语言，只要对流水线稍微熟悉，就能按照<a target="_blank" rel="noopener" href="https://github.com/jenkinsci/pipeline-plugin/blob/master/TUTORIAL.md">例子和文档</a>编写出符合要求的代码。</p>
<p>类似的工具还有Concourse.ci、λCD (LambdaCD) 等。<br>Concourse.ci 使用了 yaml 实现了DSL，独立抽象出Resource（外部依赖，如：git repo）、Job（函数， get 和 put Resource ）和 Task（纯函数，必须明确定义 Input 和 Output ）模型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-250bc1dc50e3bdd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Concousre.ci"></p>
<p>而 λCD 则使用 Clojure 语言实现了 DSL，抽象出 Pipeline 和 Step 模型，使用了Lisp特有的宏 (macro) 和普通函数，编写起来简单明了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-8b29a42d225edebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="λCD"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(def pipeline-def</span><br><span class="line">  `(</span><br><span class="line">    (either</span><br><span class="line">     manualtrigger/wait-for-manual-trigger</span><br><span class="line">     wait-for-repo)</span><br><span class="line"></span><br><span class="line">    (with-workspace</span><br><span class="line">      clone</span><br><span class="line">      (in-parallel</span><br><span class="line">       run-some-tests</span><br><span class="line">       run-smokeing-tests)</span><br><span class="line"></span><br><span class="line">      run-package</span><br><span class="line">      deploy)))</span><br></pre></td></tr></table></figure>
<p>上述的pipeline-def就是这条流水线的定义，极为优雅得是，它的代码和UI事实上构成了一一映射的关系，简单到极致。</p>
<p>值得一提的是，λCD 有别于其它同类型的工具，它本身就是一份用 Clojure 写就的微服务。换句话说，其它的工具可能需要借助基础设施即代码完成自身的安装，但λCD不用，它完全可以采用其它微服务的部署方式，比如用 λCD 部署它自己，类似于编译器的自举 (bootstraping)。这个时候，我们就需要两套 λCD 服务，一套用于部署自身，另一套部署开发中的工程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-85057d2c87c41ab1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流水线自举"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>流水线即代码是个新概念，也就意味着我们还需要花时间去探索与之相关的实践，比如，调试和测试（既然是代码就需要测试）。一旦有了这些实践，我们就可以把流水线本身作为产品放到流水线上运作起来，那时将会看到一种很好玩的现象——旧的流水线会构建并部署新流水线，完成流水线的自举 (pipeline bootstrap) 。此外，当流水线成为代码，它在最终的交付物中必然占据一席之地，其潜在的价值还等待我们挖掘，至少从精益的角度，流水线能做的事情还有很多。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2017/01/01/Emacs-configs-for-a-clojurian/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/01/01/Emacs-configs-for-a-clojurian/" class="post-title-link" itemprop="url">Emacs configs for a clojurian</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-01-01 20:00:24" itemprop="dateCreated datePublished" datetime="2017-01-01T20:00:24+08:00">2017-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2017-06-20 11:32:53" itemprop="dateModified" datetime="2017-06-20T11:32:53+08:00">2017-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Clojure/" itemprop="url" rel="index"><span itemprop="name">Clojure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>俗话说，工欲善其事必先利其器，完善开发工具与我而言是一件快乐的事情，分享也是一件令人愉悦的事情，所以我想把学习过程中的点滴记录下，留作备忘。本文不会介绍太多花式或有深度的emacs配置，更多是摸索学习的过程，其中充满了乐趣。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>网络上的*.emacs.d&#x2F;init.el<em>配置数不胜数，各路lisp大神的</em>dot file<em>都已经放在github上了，而且前有牛人撰文推荐学习emacs配置的详实方法，看似确实没有什么必要自己折腾一份配置。这个说法对，也不对。我在转向emacs之前，是一名忠实的vim党，从大学开始就不断折腾vim的配置，还花过一段时间专门学习了</em>vimscript<em>，曾经惊叹于</em>vimscript<em>的动态函数式风格的优美和强大。类似地，</em>.vimrc*配置文件在网络上也多如牛毛，华丽和酷炫的插件极大地提升了vim的操作性。尽管如此，我还是乐于一砖一瓦地打造自己的vim环境，竭力演化它变成我心目中的“编辑器之神”。这个过程一般会充满修改然后重启的重复性机械劳作，偶尔会遭遇无论怎么修改就是不生效、甚至遍寻google也一无所获的挫折，但是我就是无法厌倦它，人天生好奇，探索未知事物本身就充满了乐趣，而且一旦配置奏效，便能获得满满的成就感。新事物对程序员具有极大的吸引力，但是程序员不会止步于使用新事物，而且会在惊奇之余，渴望控制那股背后主导它的力量本身，行使“上帝之力”。</p>
<p>话说回来，为什么我会从vim党摇身一变成为emacs党呢？这就不得不提起Clojure这门lisp方言，出于对lisp和函数式编程的痴迷，我选择了基于JVM的Clojure作为自己的偏好语言，而emacs天生为lisp而生。有了这个充足的理由，我开始收集emacs的cheatsheet并打印出来，天天放在手边翻阅，甚至买了一本英文版的<em>Learning GNU Emacs</em>书籍，只要有机会就打开emacs开始刷4clojure上的编程题。由于emacs对lisp的亲和性，我几乎没花多少时间就掌握住了常用的操作技巧。不过，emacs最负盛名的学习曲线确实让学习者绕过圈子，只要一段时间不用，就会忘记很多基本操作。另外，为了更好地在emacs中编写Clojure，还需要cider-mode和clojure-mode的支持，这时候就不得不编辑<em>init.el</em>文件，本着<em>KISS (keep it simple, stupid)<em>原则，我照着各种插件的说明文档中，把配置项复制粘贴到</em>init.el</em>文件当中，运行起来没有问题就好。随着自定义的内容变多，<em>init.el</em>文件也急剧膨胀起来。膨胀本来算不上问题，但我是个比较有操守的程序员，臃肿的代码是我极力避免的坏味道（bad smell）。所以胸臆之中涌动一股浩然之气，决心学起<em>emacs lisp</em>，把emacs的配置从头来过。</p>
<h2 id="从『头』开始"><a href="#从『头』开始" class="headerlink" title="从『头』开始"></a>从『头』开始</h2><p><em>init.el</em>文件位于*~&#x2F;.emacs.d<em>目录之下，如果没有，自行创建一份即可。<br>首先，我们需要用到emacs的包管理工具</em>package.el*，因为emacs 24及其以上的版本都已经内置，所以无需下载到本地，直接通过<code>require</code>加载到emacs的运行时。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">require</span> &#x27;package)</span><br><span class="line">(<span class="name">setq</span> package-archives &#x27;((<span class="string">&quot;melpa&quot;</span> . <span class="string">&quot;http://melpa.org/packages/&quot;</span>)</span><br><span class="line">						 (<span class="string">&quot;melpa-stable&quot;</span> . <span class="string">&quot;https://stable.melpa.org/packages/&quot;</span>)</span><br><span class="line">						 (<span class="string">&quot;marmalade&quot;</span> . <span class="string">&quot;http://marmalade-repo.org/packages/&quot;</span>)</span><br><span class="line">						 (<span class="string">&quot;elpy&quot;</span> . <span class="string">&quot;http://jorgenschaefer.github.io/packages/&quot;</span>)</span><br><span class="line">						 (<span class="string">&quot;gnu&quot;</span> . <span class="string">&quot;http://elpa.gnu.org/packages/&quot;</span>))</span><br><span class="line">	  package-enable-at-startup <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码涉及到<code>setq</code>（变量赋值）的操作，<code>package-archives</code>，顾名思义，多个包的下载源，我给<code>package-archives</code>设置了5个包源，它们之间服从顺序的优先级，即先从第一个源中下载包，如果没有，到第二个原种寻找，以此类推。此外，这里<code>(&quot;melpa&quot; . &quot;http://melpa.org/packages/&quot;)</code>中的点号（dot）表示法也比较奇怪，其实这是lisp中的<em>Dotted pair</em>表示法，用法和普通的列表类似，但因为是<em>pair</em>的缘故，你可以使用<code>(car )</code>获取<code>&quot;melpa&quot;</code>，<code>(cdr )</code>获取到的却不再是一个列表，而是<code>&quot;http://melpa.org/packages/&quot; </code>这个值本身。</p>
<p>对<em>emacs lisp</em>不熟悉不要紧，先找个教程练习一下它的用法，比如<a target="_blank" rel="noopener" href="https://learnxinyminutes.com/docs/elisp/">learnxinyminutes</a>就非常不错。完成这个教程，大体不会对<em>elisp</em>犯怵了。接下来，只需要使用<code>c-h v</code>和<code>c-h f</code>查看<em>elisp</em>中定义的变量函数就能很快上手自行配置。<br>来个实际的例子，在大牛的配置文件中，经常能看到如下成对的配置：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> package-enable-at-startup <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">package-initialize</span>)</span><br></pre></td></tr></table></figure>
<p>开始我觉得这是一对矛盾的配置，<code>package-enable-at-startup</code>设置为nil，暗示emacs启动时不会启用<code>package</code>，而<code>package-initialize</code>明显表明在做<code>package</code>的初始化工作。这种时候，我心中就蹦跶出一句话“世界上本没有矛盾，如果出现了，检查你都有哪些前提条件，就会发现其中一个是错的”。这种非异常的知识点很难通过搜索引擎找到满意的答案，而阅读文档恰恰是最合适的解决方式。emacs对<code>elisp</code>文档的支持非常全面，只需将鼠标移到<code>package-enable-at-startup</code>变量上，按下<code>c-h v</code> (control + h, v) 组合键，就能在其它窗口（window) 看到文档描述：</p>
<blockquote>
<p>Whether to activate installed packages when Emacs starts.<br>If non-nil, packages are activated after reading the init file<br>and before <code>after-init-hook&#39;.  Activation is not done if </code>user-init-file’ is nil (e.g. Emacs was started with “-q”).</p>
</blockquote>
<p>意思是在读入<em>init.el</em>之后，这个变量才会生效。换句话说，在读取<em>init.el</em>的过程中，该变量不论是nil或是non-nil都不会影响<code>package</code>的加载和初始化。所以，这两者之间并没有矛盾。当然，此时你可能会想把<code>package-enable-at-startup</code>设置为nil意欲何为？<a target="_blank" rel="noopener" href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Installation.html">官方文档</a>中有如下的解释：</p>
<blockquote>
<p>This will automatically set package-enable-at-startup to nil, to avoid loading the packages again after processing the init file.</p>
</blockquote>
<p>简单点说，就是防止在<code>package-initialize </code>之后重复加载包，因为可能会影响性能。</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>如果把什么东西都揉到<em>init.el</em>文件中，这个文件一定会很快变得臃肿不堪。为了解决这个问题，需要引入模块化的思想——把特定功能的配置放到独立的文件中，然后<code>require</code>进来。按照惯例，我在*~&#x2F;.emacs.d<em>目录下建立一个</em>lisp<em>目录用于存放所有自定义的模块文件，随后在</em>init.el<em>中加入下面这句代码，意在把</em>lisp*目录加到emacs的加载路径列表里。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add-to-list</span> &#x27;load-path (<span class="name">expand-file-name</span> <span class="string">&quot;lisp&quot;</span> user-emacs-directory))</span><br></pre></td></tr></table></figure>
<p>看似，接下来就可以在每个独立的模块文件中编写各种功能的配置。但是由于<code>package.el</code>功能的局限，我们很快就会遇到包重复安装和配置漂移（configuration drift）的麻烦。<code>package.el</code>提供了<code>package-install-p</code>（p是predicate的意思）和<code>package-install</code>两个配套使用的函数，也就是说一般得先判断包在不在，才决定安不安装。幸运的是，有人已经很好地解决了这部分问题，<a target="_blank" rel="noopener" href="https://github.com/jwiegley/use-package">use-package</a>就是非常好用的包，它将包的配置和包的定义聚合到了一块，并且保证包一定会安装在你的系统当中。<br>在使用<code>use-package</code>之前，我们需要先安装它，如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">unless</span> (<span class="name">package-installed-p</span> &#x27;use-package)</span><br><span class="line">  (<span class="name">package-refresh-contents</span>)</span><br><span class="line">  (<span class="name">package-install</span> &#x27;use-package))</span><br><span class="line"></span><br><span class="line">(<span class="name">eval-when-compile</span></span><br><span class="line">  (<span class="name">require</span> &#x27;use-package))</span><br></pre></td></tr></table></figure>
<p>由于<code>use-package</code>本身就是一个包，所以可以使用<code>package-install</code>安装到本地，然后<code>require</code>到emacs的运行时，值得一提的是这个<code>eval-when-compile</code>函数，使用<code>c-h f</code>查看它的定义:</p>
<blockquote>
<p>Like ‘progn’, but evaluates the body at compile time if you’re compiling.<br>Thus, the result of the body appears to the compiler as a quoted constant.<br>In interpreted code, this is entirely equivalent to &#96;progn’.</p>
</blockquote>
<p>初次看到<strong>compile time</strong>，心中难免会有疑问：lisp不是动态语言吗，怎么还需要编译？这种时候，我们就要求助于<em>elisp</em>的文档了。在emacs中按下<code>c-h i</code>获取主话题（topic）的菜单，然后点击<em>Elisp</em>进入它的操作指南。重点查看<em>Evaluation</em>和<em>Byte Compilation</em>两个章节。不难发现lisp的解析器可以读取解析两种类型的lisp代码，一种是适合人类阅读的代码，以<em>el</em>作为后缀；另一种是编译字节码，以<em>elc</em>作为后缀。编译字节码运行速度优于前一种代码，我们可以通过<code>byte-compile-file</code>把前一种代码的文件编译成字节码文件。有趣的是，如果我们使用<em>package</em>来安装包，对应包的目录下都存在配套的<em>el</em>和<em>elc</em>两类文件。<br>在<em>Byte Compilation</em>条目下，有<code>eval-when-compile</code>的完整描述：</p>
<blockquote>
<p>If you’re using another package, but only need macros from it (the byte compiler will expand those), then ‘eval-when-compile’ can be used to load it for compiling, but not executing. For example,</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">eval-when-compile</span></span><br><span class="line">   (<span class="name">require</span> &#x27;my-macro-package))</span><br></pre></td></tr></table></figure>
<p>这里头有三个关键字<strong>load</strong>、<strong>compiling</strong>和<strong>executing</strong>值得留意一下。为了弄懂它们的含义，我们需要了解lisp解析器基本的工作原理：<code>code text -[characters]-&gt; load -[lisp object]-&gt; evaluation/compiling -[bytecode]-&gt; lisp interpretor</code>。换句话说，除非你想编译包含上述代码的文件，否则它的作用和<code>progn</code>一模一样，顺序地求值包含其中的表达式。当你正在编译文件的时候，包中宏就会原地展开，然后被<code>eval-when-compile</code>宏加载进内存并被编译成字节码，供后续解析器执行。</p>
<h2 id="Clojure相关"><a href="#Clojure相关" class="headerlink" title="Clojure相关"></a>Clojure相关</h2><p>载入<em>use-package</em>之后，我需要开始配置自己强大的Clojure开发环境了。首先，引入几个包：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> rainbow-delimiters</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">use-package</span> clj-refactor</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">use-package</span> company</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:defer</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span> (<span class="name">global-company-mode</span>))</span><br></pre></td></tr></table></figure>
<p><em>rainbow-delimiters</em>能够让括号变得如同彩虹一样绚丽（主要是易于区分forms），<em>clj-refactor</em>是重构Clojure程序的神器，<em>company</em>提供了强大的命令补全提示功能。</p>
<h3 id="clojure-mode"><a href="#clojure-mode" class="headerlink" title="clojure mode"></a>clojure mode</h3><p>接下来，我们在*~&#x2F;.emacs.d&#x2F;lisp<em>目录下新建一个</em>init-clojure.el*文件，内容如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">require</span> &#x27;clj-refactor)</span><br><span class="line">(<span class="name">require</span> &#x27;rainbow-delimiters)</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> midje-mode</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> my-clj-refactor-mode-hook ()</span><br><span class="line">	(<span class="name">clj-refactor-mode</span> <span class="number">1</span>)</span><br><span class="line">	(<span class="name">yas-minor-mode</span> <span class="number">1</span>) <span class="comment">; for adding require/use/import</span></span><br><span class="line">	(<span class="name">cljr-add-keybindings-with-prefix</span> <span class="string">&quot;C-c C-m&quot;</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> clojure-mode</span><br><span class="line">			 <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">			 <span class="symbol">:config</span></span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;clojure-mode-hook #&#x27;rainbow-delimiters-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;clojure-mode-hook #&#x27;subword-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;clojure-mode-hook #&#x27;midje-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;clojure-mode-hook #&#x27;my-clj-refactor-mode-hook)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;clojure-mode-hook #&#x27;enable-paredit-mode))</span><br><span class="line"></span><br><span class="line">(<span class="name">provide</span> &#x27;init-clojure)</span><br></pre></td></tr></table></figure>
<p>这里就能看出<em>use-package</em>的好处来了，针对<em>clojure-mode</em>的配置项都统一放到<code>:config</code>中管理起来。配置完毕后，使用<code>(provide &#39;init-clojure)</code>将模块以这样的名字暴露给其它客户端调用。</p>
<h3 id="CIDER-mode"><a href="#CIDER-mode" class="headerlink" title="CIDER mode"></a>CIDER mode</h3><p>有了<em>clojure-mode</em>之后，我们还需要一个Clojure可交互式的开发工具，CIDER便是这么一款工具。同样地，我们在<em>lisp</em>目录下新建一个名为<em>init-clojure-cider.el</em>，内容如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">require</span> &#x27;init-clojure)</span><br><span class="line">(<span class="name">require</span> &#x27;company)</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> cider</span><br><span class="line">			 <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">			 <span class="symbol">:config</span></span><br><span class="line">			 (<span class="name">setq</span> nrepl-popup-stacktraces <span class="literal">nil</span>)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-mode-hook &#x27;eldoc-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-mode-hook #&#x27;rainbow-delimiters-mode)</span><br><span class="line">			 <span class="comment">;; Replace return key with newline-and-indent when in cider mode.</span></span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-mode-hook &#x27;(lambda () (local-set-key (kbd <span class="string">&quot;RET&quot;</span>) &#x27;newline-and-indent)))</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-mode-hook #&#x27;company-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-repl-mode-hook &#x27;subword-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-repl-mode-hook &#x27;paredit-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-repl-mode-hook #&#x27;company-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-repl-mode-hook #&#x27;rainbow-delimiters-mode))</span><br><span class="line"></span><br><span class="line">(<span class="name">provide</span> &#x27;init-clojure-cider)</span><br></pre></td></tr></table></figure>
<p>配置的首部，我使用<code>(require &#39;init-clojure)</code>先加载<em>init-clojure</em>，然后对CIDER本身进行一系列的配置。配置的详细信息可以通过CIDER github主页获取到，这里我就不再赘述。</p>
<p>最后，需要在<em>init.el</em>文件中添加入这么一句<code>(require &#39;init-clojure-cider)</code>，重新启动emacs，找到一个Clojure项目，按下<code>C-c M-j</code> (hack-jack-in)，就能获得一个Clojure的交互式开发环境。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当然，我的emacs配置绝对不止这些，但是其余的过程大体类似。由于emacs速来有伪装成编辑器的操作系统的称号，所以我的探索是无止境的。如果大家对我的配置感兴趣，可以直接去我github上<a target="_blank" rel="noopener" href="https://github.com/qianyan/dotfiles">dotfiles</a>上查看。</p>
<h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><p>参考链接<br>[1] <a target="_blank" rel="noopener" href="https://sriramkswamy.github.io/dotemacs/">sriramkswamy dotemacs</a><br>[2] <a target="_blank" rel="noopener" href="https://github.com/purcell/emacs.d/">purcell emacs.d</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2016/11/04/Generative-Testing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/11/04/Generative-Testing/" class="post-title-link" itemprop="url">Generative Testing</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2016-11-04 07:21:34 / 修改时间：09:13:01" itemprop="dateCreated datePublished" datetime="2016-11-04T07:21:34+08:00">2016-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Clojure/" itemprop="url" rel="index"><span itemprop="name">Clojure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们为什么要写单元测试？</p>
<p>满足需求是所有软件存在的必要条件，单元测试一定是为它服务的。从这一点出发，我们可以总结出写单元测试的两个动机：驱动（如：TDD）和验证功能实现。另外，软件需求易变的特征决定修改代码成为必然，在这种情况下，单元测试能保护已有的功能不被破坏。</p>
<p>基于以上两点共识，我们看看传统的单元测试有什么特征？</p>
<h2 id="基于用例的测试（By-Example）"><a href="#基于用例的测试（By-Example）" class="headerlink" title="基于用例的测试（By Example）"></a>基于用例的测试（By Example）</h2><p>单元测试最常见的套路就是Given、When、Then三部曲。</p>
<ul>
<li>Given：初始状态或前置条件 </li>
<li>When：行为发生</li>
<li>Then：断言结果</li>
</ul>
<p>编写时，我们会精心准备（Given）一组输入数据，然后在调用行为后，断言返回的结果与预期相符。这种基于用例的测试方式在开发（包括TDD）过程中十分好用。因为它清晰地定义了输入输出，而且大部分情况下体量都很小、容易理解。</p>
<p>但这样的测试方式也有坏处。</p>
<p>第一点在于测试的意图。用例太过具体，我们就很容易忽略自己的测试意图。比如我曾经看过有人在写计算器kata程序的时候，将其中的一个测试命名为<em>return 3 when add 1 and 2</em>，这样的命名其实掩盖了测试用例背后的真实意图——传入两个整型参数，调用add方法之后得到的结果应该是参数之和。我们常说测试即文档，既然是文档就应该明确描述待测方法的行为，而不是陈述一个例子。</p>
<p>第二点在于测试完备性。因为省事省心并且回报率高，我们更乐于写<em>happy path</em>的代码。尽管出于职业道德，我们也会找一个明显的异常路径进行测试，不过这还远远不够。</p>
<p>为了辅助单元测试改善这两点。我这里介绍另一种测试方式——生成式测试（Generative Testing，也称<a target="_blank" rel="noopener" href="https://github.com/fpinscala/fpinscala/wiki/Chapter-8:-Property-based-testing">Property-Based Testing</a>）。这种测试方式会基于输入假设输出，并且生成许多可能的数据验证假设的正确性。</p>
<h2 id="生成式测试"><a href="#生成式测试" class="headerlink" title="生成式测试"></a>生成式测试</h2><p>对于第一个问题，我们换种思路思考一下。假设我们不需要写具体的测试用例，那么掩盖意图的可能性也就没有了。想法很美好，但如何实践Given、When、Then呢？答案是让程序生成并自动验证它们。这也就引出生成式测试的概念——我们先声明传入数据可能的情况，然后使用生成器生成符合入参情况的数据，调用待测方法，最后才进行验证。</p>
<h3 id="Given阶段"><a href="#Given阶段" class="headerlink" title="Given阶段"></a>Given阶段</h3><p>Clojure 1.9（Alpha）新内置的clojure.spec可以很轻松地做到这点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;; 定义输入参数的可能情况：两个整型参数</span><br><span class="line">(s/def ::add-operators (s/cat :a int? :b int?))</span><br><span class="line">;; 尝试生成数据</span><br><span class="line">(gen/generate (s/gen ::add-operators))</span><br><span class="line"></span><br><span class="line">;; 生成的数据</span><br><span class="line">-&gt; (1 -122)</span><br></pre></td></tr></table></figure>
<p>首先，我们尝试声明两个参数可能出现的情况或者称为规格（specification），即参数a和b都是整数。然后调用生成器产生一对整数。整个分析和构造的过程中，都没有涉及具体的数据，这样会强制我们揣摩输入数据可能的模样，而且也能避免测试意图被掩盖掉——正如前面所说，<em>return 3 when add 1 and 2</em>并不代表什么，<em>return the sum of two integers</em>才具有普遍意义。</p>
<h3 id="Then阶段"><a href="#Then阶段" class="headerlink" title="Then阶段"></a>Then阶段</h3><p>数据是生成了，待测方法也可以调用，但是Then这个断言阶段又让人头疼了，因为我们根本没法预知生成的数据，也就无法知道正确的结果，怎么断言？</p>
<p>拿我们定义的加法运算为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(defn add [a b]</span><br><span class="line">  (+ a b))</span><br></pre></td></tr></table></figure>
<p>我们尝试把断言改成一个全称命题的格式：</p>
<blockquote>
<p>任取两个整数a, b，a和b加起来的结果总是a, b之和。</p>
</blockquote>
<p>借助<a target="_blank" rel="noopener" href="https://github.com/clojure/test.check">test.check</a>，我们在<em>Clojure</em>可以这样表达</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(def test-add</span><br><span class="line">  (prop/for-all [a (gen/int)</span><br><span class="line">                 b (gen/int)]</span><br><span class="line">                (= (add a b) (+ a b))))</span><br></pre></td></tr></table></figure>
<p>等等，我们把add方法的实现<code>(+ a b)</code>写到了断言里，这几乎丧失了单元测试的基本意义。换一种断言方式，我们使用加法的逆运算进行描述：</p>
<blockquote>
<p>任取两个整数，把a和b加起来的结果减去a总会得到b。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(def test-add</span><br><span class="line">  (prop/for-all [a (gen/int)</span><br><span class="line">                 b (gen/int)]</span><br><span class="line">                (= (- (add a b) a) b))))</span><br></pre></td></tr></table></figure>
<p>我们通过程序陈述了一个已知的真命题。变换以后，就可以使用<code>quick-check</code>对多组生成的整数进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;; 随机生成100组数据测试add方法</span><br><span class="line">(tc/quick-check 100 test-add)</span><br><span class="line"></span><br><span class="line">;; 测试结果</span><br><span class="line">-&gt; &#123;:result true, :num-tests 100, :seed 1477285296502&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果表明，刚才运行了100组测试，并且都通过了。理论上，程序可以生成无数的测试数据来验证add方法的正确性。即便不能穷尽，我们也获得一组统计上的数字，而不仅仅是几个纯手工挑选的用例。</p>
<p>至于第二个问题，首先得明确测试是无法做到完备的。很多指导方法保证使用较少的用例做到有效覆盖，比如：等价类、边界值、判定表、因果图、pairwise等等。但是在实际使用过程当中，依然存在问题。举个等价类的例子，假如我们有一个接受自然数并直接返回入参的方法<em>identity-nat</em>，那么对于输入参数而言，全体自然数都互为等价类，其中的一个有效等价类可以是自然数1。如果入参被假定在整数的范围，我们很容易找到一个无效等价类，比如-1。</p>
<p>用Clojure测试代码表现出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(deftest test-with-identity-nat</span><br><span class="line">  (testing &quot;identity of natural integers&quot;</span><br><span class="line">    (is (= 1 (identity-nat 1))))</span><br><span class="line">  (testing &quot;throw exception for non-natural integers&quot;</span><br><span class="line">    (is (thrown? RuntimeException (identity-nat -1)))))</span><br></pre></td></tr></table></figure>
<p>不过如果有人修改了方法<em>identity-nat</em>的实现，单独处理入参为0的情况，这个测试还是能够照常通过。也就是说，实现发生改变，基于等价类的测试有可能起不到防护作用的。当然你完全可以反驳：规则改变，等价类也得重新定义。道理确实如此，但是反过来想想，我们写测试的目的不正是构建一张安全网吗？我们信任测试能在代码变动时给予警告，但此处它失信了，这就尴尬了。</p>
<p>如果使用生成式测试，我们规定：</p>
<blockquote>
<p>任取一个自然数a，在其上调用f的结果总是a。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(def test-identity-nat</span><br><span class="line"> (prop/for-all [a (s/gen nat-int?)]</span><br><span class="line">               (= a (identity-nat a))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(tc/quick-check 100 test-identity-nat)</span><br><span class="line"></span><br><span class="line">-&gt; &#123;:result false, :seed 1477362396044, :failing-size 0, :num-tests 1, :fail [0], :shrunk &#123;:total-nodes-visited 0, </span><br><span class="line">         :depth 0, </span><br><span class="line">         :result false, </span><br><span class="line">         :smallest [0]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这个测试尝试对100组生成的自然数（nat-int?）进行测试，但首次运行就发现代码发生过变动。失败的数据是0，而且还给出了最小失败集[0]。拿着这个最小失败集，我们就可以快速地重现失败用例，从而修正。</p>
<p>当然也有可能在一次运行中，我们的测试无法发现失败的用例。但是，如果100个测试用例都通过了，至少表明我们程序对于100个随机的自然数都是正确的。和基于用例的测试相比，这就如同编织出一道更加紧密的安全网。网孔越小，漏掉的情况也越少。</p>
<p>Clojure语言之父Rich Hickey推崇*<a target="_blank" rel="noopener" href="https://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a>*哲学，所以生成式测试在Clojure.spec中有更为简约的表达。以上述为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(s/fdef identity-nat</span><br><span class="line">        :args (s/cat :a nat-int?) ;输入参数的规格</span><br><span class="line">        :ret nat-int?             ;返回结果的规格</span><br><span class="line">        :fn #(= (:ret %) (-&gt; % :args :a))) ;入参和出参之间的约束</span><br><span class="line"></span><br><span class="line">(stest/check `identity-nat)</span><br></pre></td></tr></table></figure>
<p><em>fdef</em>宏定义了方法<em>identity-nat</em>的规格，默认情况下会基于参数的规格生成1000组数据进行生成式测试。除了这一好处，它还提供部分类型检查的功能。</p>
<h2 id="再谈TDD"><a href="#再谈TDD" class="headerlink" title="再谈TDD"></a>再谈TDD</h2><p>TDD（测试驱动开发）是一种驱动代码实现和设计的过程。我们说要先有测试，再去实现；保证实现功能的前提下，重构代码以达到较好的设计。整个过程就好比演绎推理，测试就是其中的证明步骤，而最终实现的功能则是证明的结果。</p>
<p>对于开发人员而言，基于用例的测试方式是友好的，因为它能简单直接地表达实现的功能并保证其正确性。一旦进入红、绿、重构的节（guai）奏（quan），开发人员根本停不下来，进入一种心流状态。只不过问题是，基于用例驱动出来的实现可能并不是<strong>恰好</strong>通过的。我们常常会发现，在写完上组测试用例的实现之后，无需任何改动，下组测试照常能运行通过。换句话说，实现代码可能做了多余的事情而我们却浑然不知。在这种情况下，我们可以利用生成式测试准备大量符合规格的数据探测程序，以此检查程序的健壮性，让缺陷无处遁形。</p>
<p>凡是想到的情况都能测试，但是想不到情况也需要测试。这才是生成式测试的价值所在。有人把TDD概念化为“展示你的功能”（Show your work），而把生成式测试概念化为“检查你的功能“（Check your work），我深以为然。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>回到我们写单元测试的动机上：</p>
<ol>
<li>保证或验证实现功能；</li>
<li>保护已经实现的功能不被破坏。<br>基于用例的单元测试和生成式测试在这两点上是相辅相成的。我们可以借助它们尽可能早地找出缺陷，避免缺陷逃逸到生产环境。</li>
</ol>
<p>ThoughtWorks 2016年11月份的技术雷达把Clojure.spec移到了工具象限的评估环中，这表明这个工具值得作一番探究。当然，除了Clojure，<a target="_blank" rel="noopener" href="http://hypothesis.works/articles/quickcheck-in-every-language/">其它语言</a>都有相应的生成式测试的框架，你不妨在自己的项目中试一试。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2016/09/12/Collection-Pipelines-By-TDD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/09/12/Collection-Pipelines-By-TDD/" class="post-title-link" itemprop="url">Clojure集合管道函数练习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-09-12 09:26:24" itemprop="dateCreated datePublished" datetime="2016-09-12T09:26:24+08:00">2016-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2016-10-06 10:30:45" itemprop="dateModified" datetime="2016-10-06T10:30:45+08:00">2016-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Clojure/" itemprop="url" rel="index"><span itemprop="name">Clojure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>TDD讨论组里的<a target="_blank" rel="noopener" href="http://www.jackyshen.com/">申导</a>最近在B站直播了Martin Fowler的经典文章*<a target="_blank" rel="noopener" href="http://www.martinfowler.com/articles/refactoring-pipelines.html">Refactoring with Loops and Collection Pipelines</a><em>中谈到的<strong>利用集合管道对循环进行函数式重构</strong>。视频地址在<a target="_blank" rel="noopener" href="http://www.bilibili.com/mobile/video/av6146294.html">这里</a>，申导的翻译在<a target="_blank" rel="noopener" href="http://www.jackyshen.com/2016/07/04/Refactoring-with-Loops-and-Collection-Pipelines/">这里</a>。组织者<a target="_blank" rel="noopener" href="http://www.seabornlee.cn/">小波（Seaborn Lee）</a>趁机出了一道关于集合管道函数<a target="_blank" rel="noopener" href="https://codingstyle.cn/topics/205">题目</a>。我就想啊，论函数式编程，舍</em>Clojure<em>其谁？而且我在</em>Clojure*很少能写出<code>loop... recur</code>这样偏底层的循环代码。话不多说，撸起袖子开工。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一家澡堂有 m 个房间，每个房间有 n 个时段，现在要给用户推荐「最早的可以预约的时段」。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">rooms: [</span><br><span class="line">  &#123;</span><br><span class="line">     room_id: 1,</span><br><span class="line">     periods: [</span><br><span class="line">        &#123;</span><br><span class="line">           time: &#x27;17:00-18:00&#x27;,</span><br><span class="line">           status: &#x27;available&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">           time: &#x27;18:00-19:00&#x27;,</span><br><span class="line">           status: &#x27;occupied&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">     room_id: 2,</span><br><span class="line">     periods: [</span><br><span class="line">        &#123;</span><br><span class="line">           time: &#x27;17:00-18:00&#x27;,</span><br><span class="line">           status: &#x27;occupied&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">           time: &#x27;18:00-19:00&#x27;,</span><br><span class="line">           status: &#x27;available&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>期望返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  room_id: 1,</span><br><span class="line">  time: &#x27;17:00-18:00&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目很简单，基本思路：首先过滤出每个房间<code>periods</code>中<code>status</code>为<code>available</code>的时间段，然后取第一个也就是最早的时间段（默认为递增排序的），接着将<code>room_id</code>和这个时间段以<strong>期望返回</strong>的形式合并。再然后对所有合并的结果依据时间段进行一次排序（<code>sort</code>），最后取第一个结果即可。</p>
<h2 id="1-Clojure-解法"><a href="#1-Clojure-解法" class="headerlink" title="1. Clojure 解法"></a>1. Clojure 解法</h2><h3 id="转换数据格式"><a href="#转换数据格式" class="headerlink" title="转换数据格式"></a>转换数据格式</h3><p>原题中给的是json的格式，不适合在<em>Clojure</em>中处理，所以我们手工转换成需要的形式，如下：<br><strong>清单1-1</strong> 数据定义</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">def</span> <span class="title">rooms</span></span><br><span class="line">  [&#123;<span class="symbol">:room-id</span> <span class="number">1</span></span><br><span class="line">    <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;</span><br><span class="line">              &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;]&#125;</span><br><span class="line">   &#123;<span class="symbol">:room-id</span> <span class="number">2</span></span><br><span class="line">    <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;</span><br><span class="line">              &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;]&#125;])</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>清单1-2</strong> 房间最早可预约时间段</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-room</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">-&gt;&gt;</span></span> rooms</span><br><span class="line">       (<span class="name"><span class="built_in">map</span></span></span><br><span class="line">        (<span class="name"><span class="built_in">juxt</span></span> first (<span class="name"><span class="built_in">fn</span></span> [&#123;<span class="symbol">:keys</span> [periods]&#125;]</span><br><span class="line">                      (<span class="name"><span class="built_in">-&gt;&gt;</span></span> periods</span><br><span class="line">                           (<span class="name"><span class="built_in">filter</span></span> #(<span class="name"><span class="built_in">=</span></span> (<span class="symbol">:status</span> %) <span class="symbol">:available</span>))</span><br><span class="line">                           (<span class="name"><span class="built_in">ffirst</span></span>)))))</span><br><span class="line">       (<span class="name"><span class="built_in">map</span></span> #(<span class="name"><span class="built_in">into</span></span> &#123;&#125; %))</span><br><span class="line">       (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span>)</span><br><span class="line">       (<span class="name"><span class="built_in">first</span></span>)))</span><br><span class="line">       </span><br><span class="line">(<span class="name">the-earliest-available-room</span> rooms)</span><br><span class="line">-&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span><span class="punctuation">,</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码和上面的解析是一一对应的关系。为了让程序清晰，符合管道的用法，这里使用了thread last宏（<code>-&gt;&gt;</code>），它的作用是把前面一个<code>form</code>作为后一个<code>form</code>的最后一个参数。与之呼应的是thread first宏（<code>-&gt;</code>），它的作用类似，不过会传成第一个参数。</p>
<p>我们先看<code>(map (juxt ...) ...)</code>这一段代码。<code>juxt</code>是一个非常有意思的函数，而且超级实用。它的文档描述如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">doc</span> juxt)</span><br><span class="line">-&gt;</span><br><span class="line">clojure.core/juxt</span><br><span class="line"> [f]</span><br><span class="line"> [f g]</span><br><span class="line"> [f g h]</span><br><span class="line"> [f g h &amp; fs]</span><br><span class="line">Added in <span class="number">1.1</span></span><br><span class="line">  Takes a set of functions and returns a fn that is the juxtaposition</span><br><span class="line">  of those fns.  The returned fn takes a variable number of args<span class="punctuation">,</span> and</span><br><span class="line">  returns a vector containing the result of applying each fn to the</span><br><span class="line">  args (<span class="name">left-to-right</span>).</span><br><span class="line">  ((<span class="name"><span class="built_in">juxt</span></span> a b c) x) =&gt; [(<span class="name">a</span> x) (<span class="name">b</span> x) (<span class="name">c</span> x)]</span><br></pre></td></tr></table></figure>
<p>它的神奇之处在于可以对同一个参数应用不同的函数，而且还能将应用的结果全部收集起来。想想题目的解析中提及的以<strong>期望返回</strong>的形式合并，如果我们应用<code>juxt</code>函数，就能得到<code>[(:room-id 1) (:time &quot;17:00-18:00&quot;)]</code>这样的中间结果。</p>
<p><code>(juxt first (fn ...))</code>中<code>first</code>用于提取<code>:room-id</code>，而后面的<code>lambda</code>表达式则用于提取<code>:time</code>。解法很直观，筛选出<code>:status</code>是<code>:available</code>的时间段，然后使用<code>(ffirst)</code>取第一个map的首个entry。如：<code>&#123;:time &quot;17:00-18:00&quot; :status :available&#125;</code>，那么应用<code>(ffirst)</code>的结果就是<code>[:time &quot;17:00-18:00&quot;]</code>。</p>
<p>接下来，又进行了一次map操作，这次的目的是把元组的entries，转换为map。举个例子：<code>[[:room-id 1] [:time &quot;17:00-18:00&quot;]]</code> &#x3D;&gt; <code>&#123;:room-id 1 :time &quot;17:00-18:00&quot;&#125;</code>。转换成map之后，方便以<code>:time</code>对结果进行排序<code>(sort-by :time)</code>，最后取出第一个元素<code>(first)</code>，即我们期望的返回。</p>
<p>写完之后，我很想再写个TDD版本的。话不多说，继续撸袖子。</p>
<h2 id="2-Clojure-TDD-解法"><a href="#2-Clojure-TDD-解法" class="headerlink" title="2. Clojure TDD 解法"></a>2. Clojure TDD 解法</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>生成工程</li>
</ul>
<p>进入命令行，输入<code>lein new midje the-earliest-available-period-of-bathroom</code>，leiningen会生成基于<code>midje</code>这个测试框架的工程。</p>
<ul>
<li><p>Git</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">&gt; .gitignore</span><br><span class="line">.lein*</span><br><span class="line">.nrep*</span><br><span class="line">target/</span><br><span class="line">这里ctrl-c退出</span><br><span class="line">git add .</span><br><span class="line">git commit --message &quot;init commit&quot;</span><br></pre></td></tr></table></figure>
<p>我使用了<code>zsh</code>和<code>oh-my-zsh</code>，自带了很多git操作的alias，可以通过<code>alias |grep git</code>查看。后续的git操作都会使用alias。</p>
</li>
<li><p>自动测试</p>
</li>
</ul>
<p>输入<code>lein repl</code>，然后<code>(use &#39;midje.repl)</code>，最后输入<code>(autotest)</code>。这样一旦文件修改保存，测试就会自动触发。</p>
<ul>
<li>Emacs</li>
</ul>
<p>用来写代码的。</p>
<h3 id="Tasking（任务拆分）"><a href="#Tasking（任务拆分）" class="headerlink" title="Tasking（任务拆分）"></a>Tasking（任务拆分）</h3><p>先不急着敲代码，我们先从测试的角度看看完成这个需求需要哪几步？</p>
<ul>
<li><input disabled="" type="checkbox"> 单间澡堂有一个可用时间段</li>
<li><input disabled="" type="checkbox"> 单间澡堂有多个可用时间段</li>
<li><input disabled="" type="checkbox"> 所有澡堂（包含输入为空）没有可用时间段</li>
<li><input disabled="" type="checkbox"> 多间澡堂都有可用时间段</li>
<li><input disabled="" type="checkbox"> 多间澡堂中有的有可用时间段，有的没有可用时间段</li>
</ul>
<h3 id="第1个任务"><a href="#第1个任务" class="headerlink" title="第1个任务"></a>第1个任务</h3><ul>
<li><input disabled="" type="checkbox"> 单间澡堂有一个可用时间段</li>
</ul>
<h4 id="1-写测试"><a href="#1-写测试" class="headerlink" title="1. 写测试"></a>1. 写测试</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">def</span> <span class="title">room-1</span> &#123;<span class="symbol">:room-id</span> <span class="number">1</span></span><br><span class="line">    <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;</span><br><span class="line">              &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;]&#125;)</span><br><span class="line"></span><br><span class="line">(<span class="keyword">def</span> <span class="title">room-2</span> &#123;<span class="symbol">:room-id</span> <span class="number">2</span></span><br><span class="line">             <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;</span><br><span class="line">                       &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;]&#125;)</span><br><span class="line">                        </span><br><span class="line">(<span class="name">facts</span> <span class="string">&quot;about `the-earliest-avaible-period-of-bathroom`&quot;</span></span><br><span class="line">  (<span class="name">fact</span> <span class="string">&quot;should recommand if there is only one room with available period&quot;</span></span><br><span class="line">    <span class="comment">;; 1号</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-1]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;)</span><br><span class="line">    <span class="comment">;; 2号</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-2]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">2</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;))</span><br></pre></td></tr></table></figure>

<h4 id="2-写实现"><a href="#2-写实现" class="headerlink" title="2. 写实现"></a>2. 写实现</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>针对1号测试，这个实现有点“荒诞”，术语<code>hard code</code>说的就是这个，但是眼下足够了。不过此时，应该再写一个类似的测试来去除<code>hard code</code>，即2号测试。<br>相应地，我们要修改实现。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defn the-earliest-available-recommand [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">let</span></span> [&#123;<span class="symbol">:keys</span> [room-id periods]&#125; (<span class="name"><span class="built_in">first</span></span> rooms)</span><br><span class="line">        available-periods (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %)) periods)]</span><br><span class="line">    (<span class="name"><span class="built_in">merge</span></span> &#123;<span class="symbol">:room-id</span> room-id&#125;</span><br><span class="line">           (<span class="name"><span class="built_in">select-keys</span></span> (<span class="name"><span class="built_in">first</span></span> available-periods) [<span class="symbol">:time</span>]))))</span><br></pre></td></tr></table></figure>

<h4 id="3-关闭并提交"><a href="#3-关闭并提交" class="headerlink" title="3. 关闭并提交"></a>3. 关闭并提交</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 单间澡堂有一个可用时间段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;one available room&quot;</span><br></pre></td></tr></table></figure>
<h3 id="第2个任务"><a href="#第2个任务" class="headerlink" title="第2个任务"></a>第2个任务</h3><ul>
<li><input disabled="" type="checkbox"> 单间澡堂有多个可用时间段</li>
</ul>
<h4 id="1-写测试-1"><a href="#1-写测试-1" class="headerlink" title="1. 写测试"></a>1. 写测试</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">def</span> <span class="title">room-3</span> &#123;<span class="symbol">:room-id</span> <span class="number">3</span></span><br><span class="line">             <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;</span><br><span class="line">                       &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;</span><br><span class="line">                       &#123;<span class="symbol">:time</span> <span class="string">&quot;19:00-20:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;]&#125;)</span><br><span class="line">...                        </span><br><span class="line">(<span class="name">fact</span> <span class="string">&quot;should recommand the earliest one if there is only one room with multiple available periods&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">3</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>保存，发现测试还是跑过了。原因在于我们默认了<code>period</code>是递增排序的。我们看看有没有重构点？实现太简单了暂时找不到，那就欢欢喜喜地跳过实现步骤。</p>
<h4 id="2-关闭并提交"><a href="#2-关闭并提交" class="headerlink" title="2. 关闭并提交"></a>2. 关闭并提交</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 单间澡堂有多个可用时间段<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;one room with multiple available periods&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第3个任务"><a href="#第3个任务" class="headerlink" title="第3个任务"></a>第3个任务</h3><ul>
<li><input disabled="" type="checkbox"> 所有澡堂（包含输入为空）没有可用时间段</li>
</ul>
<h4 id="1-写测试-2"><a href="#1-写测试-2" class="headerlink" title="1. 写测试"></a>1. 写测试</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">def</span> <span class="title">non-available-room</span> &#123;<span class="symbol">:room-id</span> <span class="number">4</span></span><br><span class="line">             <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;</span><br><span class="line">                       &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;</span><br><span class="line">                       &#123;<span class="symbol">:time</span> <span class="string">&quot;19:00-20:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;]&#125;)</span><br><span class="line">                        </span><br><span class="line">(<span class="name">fact</span> <span class="string">&quot;should show `:no-available-room` if there is no available room&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> []) =&gt; <span class="symbol">:no-available-room</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [non-available-room]) =&gt; <span class="symbol">:no-available-room</span>))                        </span><br></pre></td></tr></table></figure>
<p>这回肯定挂掉。</p>
<h4 id="2-写实现-1"><a href="#2-写实现-1" class="headerlink" title="2. 写实现"></a>2. 写实现</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">let</span></span> [&#123;<span class="symbol">:keys</span> [room-id periods]&#125; (<span class="name"><span class="built_in">first</span></span> rooms)</span><br><span class="line">        available-periods (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %)) periods)]</span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">seq</span></span> available-periods)</span><br><span class="line">      (<span class="name"><span class="built_in">merge</span></span> &#123;<span class="symbol">:room-id</span> room-id&#125;</span><br><span class="line">             (<span class="name"><span class="built_in">select-keys</span></span> (<span class="name"><span class="built_in">first</span></span> available-periods) [<span class="symbol">:time</span>]))</span><br><span class="line">      <span class="symbol">:no-available-room</span>)))</span><br></pre></td></tr></table></figure>
<p>这里使用了<em>Clojure</em>中判断集合是否为空较为常用的手法<code>(seq )</code>，如果集合非空，那么返回集合本身；反之，返回nil，nil在逻辑上是false。测试通过。</p>
<h4 id="3-关闭并提交-1"><a href="#3-关闭并提交-1" class="headerlink" title="3. 关闭并提交"></a>3. 关闭并提交</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 所有澡堂（包含输入为空）没有可用时间段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;no available room&quot;</span><br></pre></td></tr></table></figure>

<h3 id="第4个任务"><a href="#第4个任务" class="headerlink" title="第4个任务"></a>第4个任务</h3><ul>
<li><input disabled="" type="checkbox"> 多间澡堂都有可用时间段</li>
</ul>
<h4 id="1-写测试-3"><a href="#1-写测试-3" class="headerlink" title="1. 写测试"></a>1. 写测试</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">fact</span> <span class="string">&quot;should recommand the earliest if there has more than one room and each has available periods&quot;</span></span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [room-1 room-2]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [room-2 room-1]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [room-2 room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">2</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;</span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [room-1 room-2 room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-写实现-2"><a href="#2-写实现-2" class="headerlink" title="2. 写实现"></a>2. 写实现</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">seq</span></span> rooms)</span><br><span class="line">    (<span class="name"><span class="built_in">first</span></span> (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span></span><br><span class="line">                    (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">fn</span></span> [room]</span><br><span class="line">                           (<span class="name"><span class="built_in">let</span></span> [&#123;<span class="symbol">:keys</span> [room-id periods]&#125; room</span><br><span class="line">                                 available-periods (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %)) periods)]</span><br><span class="line">                             (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">seq</span></span> available-periods)</span><br><span class="line">                               (<span class="name"><span class="built_in">merge</span></span> &#123;<span class="symbol">:room-id</span> room-id&#125;</span><br><span class="line">                                      (<span class="name"><span class="built_in">select-keys</span></span> (<span class="name"><span class="built_in">first</span></span> available-periods) [<span class="symbol">:time</span>]))</span><br><span class="line">                               <span class="symbol">:no-available-room</span>)))</span><br><span class="line">                         rooms)))</span><br><span class="line">    <span class="symbol">:no-available-room</span>))</span><br></pre></td></tr></table></figure>
<p>到这里，我们开始使用<code>(map )</code>函数处理多个房间的内容。注意，当输入房间是空集合的时候，这里需要相应地做<code>(seq rooms)</code>判空处理，否则会返回nil，而不是我们想要的<code>:no-available-room</code>。</p>
<h4 id="3-关闭并提交-2"><a href="#3-关闭并提交-2" class="headerlink" title="3. 关闭并提交"></a>3. 关闭并提交</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 多间澡堂都有可用时间段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;more than one room&quot;</span><br></pre></td></tr></table></figure>

<h4 id="4-重构"><a href="#4-重构" class="headerlink" title="4. 重构"></a>4. 重构</h4><p>代码写到这里，再不重构就说不过去了。另外，管道没看到，倒是看到一堆括号。<br>我们使用thread last<code>(-&gt;&gt; )</code>做一次重构：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">seq</span></span> rooms)</span><br><span class="line">    (<span class="name"><span class="built_in">-&gt;&gt;</span></span> rooms</span><br><span class="line">         (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">fn</span></span> [room]</span><br><span class="line">                (<span class="name"><span class="built_in">let</span></span> [&#123;<span class="symbol">:keys</span> [room-id periods]&#125; room</span><br><span class="line">                      available-periods (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %)) periods)]</span><br><span class="line">                  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">seq</span></span> available-periods)</span><br><span class="line">                    (<span class="name"><span class="built_in">merge</span></span> &#123;<span class="symbol">:room-id</span> room-id&#125;</span><br><span class="line">                           (<span class="name"><span class="built_in">select-keys</span></span> (<span class="name"><span class="built_in">first</span></span> available-periods) [<span class="symbol">:time</span>]))</span><br><span class="line">                    <span class="symbol">:no-available-room</span>))))</span><br><span class="line">         (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span>)</span><br><span class="line">         first)</span><br><span class="line">    <span class="symbol">:no-available-room</span>))</span><br></pre></td></tr></table></figure>
<p>还行，至少没那么多嵌套了。提交一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;[refactor] use macro thread-last -&gt;&gt; to pipe&quot;</span><br></pre></td></tr></table></figure>
<p>继续重构，使用我们的<code>juxt</code>函数。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">letfn</span></span> [(<span class="name">period</span> [&#123;<span class="symbol">:keys</span> [periods]&#125;]</span><br><span class="line">            (<span class="name"><span class="built_in">-&gt;&gt;</span></span> periods</span><br><span class="line">                 (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %)))</span><br><span class="line">                 ffirst</span><br><span class="line">                 (#(<span class="name"><span class="built_in">or</span></span> % [<span class="symbol">:time</span> <span class="symbol">::non-available</span>]))))]</span><br><span class="line">    (<span class="name"><span class="built_in">-&gt;&gt;</span></span> rooms</span><br><span class="line">         (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">fn</span></span> [room]</span><br><span class="line">                (<span class="name"><span class="built_in">apply</span></span> conj &#123;&#125; ((<span class="name"><span class="built_in">juxt</span></span> first period) room))))</span><br><span class="line">         (<span class="name"><span class="built_in">remove</span></span> #(#&#123;<span class="symbol">::non-available</span>&#125; (<span class="symbol">:time</span> %)))</span><br><span class="line">         (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span>)</span><br><span class="line">         first</span><br><span class="line">         (#(<span class="name"><span class="built_in">or</span></span> % <span class="symbol">:no-available-room</span>)))))</span><br></pre></td></tr></table></figure>
<p>看上去还行，不过不爽的是<code>(#(or % [:time ::non-available]))</code>。为了迎合<code>(-&gt;&gt; )</code>宏，我们给<code>(or )</code>包了一层。原因是<code>(-&gt;&gt; )</code>会让前面的结果出现在最后一个参数的位置，而我们需要将结果放到<code>(or )</code>的第一个参数的位置。有没有什么好看的解决方法呢？当然有！我们可以使用<code>(-&gt; )</code>来做到这点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(defn the-earliest-available-recommand [rooms]</span><br><span class="line">  (letfn [(period [&#123;:keys [periods]&#125;]</span><br><span class="line">            (-&gt; periods</span><br><span class="line">                (-&gt;&gt; (filter #(#&#123;:available&#125; (:status %)))</span><br><span class="line">                     ffirst)</span><br><span class="line">                (or [:time ::non-available])))]</span><br><span class="line">    (-&gt; rooms</span><br><span class="line">        (-&gt;&gt; (map (fn [room]</span><br><span class="line">                    (apply conj &#123;&#125; ((juxt first period) room))))</span><br><span class="line">             (remove #(#&#123;::non-available&#125; (:time %)))</span><br><span class="line">             (sort-by :time)</span><br><span class="line">             first)</span><br><span class="line">        (or :no-available-room))))</span><br></pre></td></tr></table></figure>
<p>顿时觉得世界干净了不少。再提交一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;[refactor] use juxt to extract needed fields&quot;</span><br></pre></td></tr></table></figure>
<h3 id="第5个任务"><a href="#第5个任务" class="headerlink" title="第5个任务"></a>第5个任务</h3><ul>
<li><input disabled="" type="checkbox"> 多间澡堂中有的有可用时间段，有的没有可用时间段</li>
</ul>
<h4 id="1-写测试-4"><a href="#1-写测试-4" class="headerlink" title="1. 写测试"></a>1. 写测试</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">fact</span> <span class="string">&quot;should recommand the earliest available room even if there has non available room&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-1 non-available-room]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-2 non-available-room]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">2</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>测试直接通过，又可以跳过实现代码了。不过，这也预示着我们的测试是有覆盖的，也需要花时间整理这些测试用例。在那之前，先提交一下。</p>
<h4 id="2-关闭并提交-1"><a href="#2-关闭并提交-1" class="headerlink" title="2. 关闭并提交"></a>2. 关闭并提交</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 多间澡堂中有的有可用时间段，有的没有可用时间段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;mixed non-available and available rooms&quot;</span><br></pre></td></tr></table></figure>
<h3 id="为第3个任务补上测试用例"><a href="#为第3个任务补上测试用例" class="headerlink" title="为第3个任务补上测试用例"></a>为第3个任务补上测试用例</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 所有（包含多个）澡堂（包含输入为空）没有可用时间段</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">fact</span> <span class="string">&quot;should show `:no-available-room` if there is no available room&quot;</span></span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> []) =&gt; <span class="symbol">:no-available-room</span></span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [non-available-room]) =&gt; <span class="symbol">:no-available-room</span></span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [non-available-room non-available-room]) =&gt; <span class="symbol">:no-available-room</span>))</span><br></pre></td></tr></table></figure>
<p>这里的第3个用例包含第2个用例，我们待会整理掉。不过现在先提交一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;multiple non-available rooms&quot;</span><br></pre></td></tr></table></figure>
<h3 id="整理测试"><a href="#整理测试" class="headerlink" title="整理测试"></a>整理测试</h3><p>在前面进行的任务当中，我们发现有两次没有写实现测试就通过的情况。这说明测试用例是有覆盖的。</p>
<ul>
<li>第2个任务的测试用例其实覆盖了第1个任务的测试用例，所以可以直接删去后者；</li>
<li>第5个任务的测试用例覆盖了第4个任务的部分测试用例，所以可以合并到一起。</li>
</ul>
<p>整理下来，最终的测试变成下面这样：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">facts</span> <span class="string">&quot;about `the-earliest-avaible-period-of-bathroom`&quot;</span></span><br><span class="line">  (<span class="name">fact</span> <span class="string">&quot;should recommand the earliest one if there is only one room with multiple available periods&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">3</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;)</span><br><span class="line">  </span><br><span class="line">  (<span class="name">fact</span> <span class="string">&quot;should show `:no-available-room` if there is no available room&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> []) =&gt; <span class="symbol">:no-available-room</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [non-available-room non-available-room]) =&gt; <span class="symbol">:no-available-room</span>)</span><br><span class="line"> </span><br><span class="line">  (<span class="name">fact</span> <span class="string">&quot;should recommand the earliest if there has more than one room and each may have available periods&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-1 room-2]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-2 room-1]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-2 room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">2</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;</span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-1 room-2 room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-1 non-available-room]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;))</span><br></pre></td></tr></table></figure>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><blockquote>
<p>The final goal of any engineering activity is some type of documentation.</p>
</blockquote>
<p>更新README.md文件，其中描述程序解决的问题以及运行步骤，当然包含设计思路那更好了。提交一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;update readme&quot;</span><br></pre></td></tr></table></figure>

<h3 id="美化代码"><a href="#美化代码" class="headerlink" title="美化代码"></a>美化代码</h3><blockquote>
<p>代码是诗行 - by lambeta</p>
</blockquote>
<h2 id="什么是好看的代码？除了清晰明了，格式也必须产生美感。顺眼不少，最后提交一下。"><a href="#什么是好看的代码？除了清晰明了，格式也必须产生美感。顺眼不少，最后提交一下。" class="headerlink" title="什么是好看的代码？除了清晰明了，格式也必须产生美感。顺眼不少，最后提交一下。"></a>什么是好看的代码？除了清晰明了，格式也必须产生美感。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">letfn</span></span> [(<span class="name">period</span> [&#123;<span class="symbol">:keys</span> [periods]&#125;]</span><br><span class="line">            (<span class="name"><span class="built_in">-&gt;</span></span> periods</span><br><span class="line">                (<span class="name"><span class="built_in">-&gt;&gt;</span></span> (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %))))</span><br><span class="line">                (<span class="name"><span class="built_in">ffirst</span></span>) <span class="comment">; 统一套上括号</span></span><br><span class="line">                (<span class="name"><span class="built_in">or</span></span> [<span class="symbol">:time</span> <span class="symbol">::non-available</span>])))]</span><br><span class="line">    (<span class="name"><span class="built_in">-&gt;</span></span> rooms</span><br><span class="line">        (<span class="name"><span class="built_in">-&gt;&gt;</span></span> (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">juxt</span></span> first period))</span><br><span class="line">             (<span class="name"><span class="built_in">map</span></span> #(<span class="name"><span class="built_in">into</span></span> &#123;&#125; %)) <span class="comment">; 合并单独提出来</span></span><br><span class="line">             (<span class="name"><span class="built_in">remove</span></span> #(#&#123;<span class="symbol">::non-available</span>&#125; (<span class="symbol">:time</span> %)))</span><br><span class="line">             (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span>)</span><br><span class="line">             (<span class="name"><span class="built_in">first</span></span>)) <span class="comment">; 统一套上括号</span></span><br><span class="line">        (<span class="name"><span class="built_in">or</span></span> <span class="symbol">:no-available-room</span>))))</span><br></pre></td></tr></table></figure><br>顺眼不少，最后提交一下。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;[refactor] beautify pipe format&quot;</span><br></pre></td></tr></table></figure></h2><p>这篇文章发出来一天，TDD讨论群的一位麦姓朋友@我道：</p>
<blockquote>
<p>core&#x3D;&gt; (first {:a 1 :b 2})<br>[:a 1]<br>core&#x3D;&gt; (first {:b 2 :a 1})<br>[:b 2]<br>@lambeta map的元素应该是无序的，用first来获得key value pair是不可靠的。</p>
</blockquote>
<p>看到这个建议的时候，我心里一阵欣喜——又有一员<em>Clojurians</em>，可以切磋技艺了！冷静下来，发现自己确实忽略了map中的entries可能是无序的。所以我做了如下的验证：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">type</span></span> &#123;&#125;)</span><br><span class="line">-&gt; clojure.lang.PersistentArrayMap</span><br></pre></td></tr></table></figure>
<p>看到<code>PersistentArrayMap</code>的时候，我明白这些entries是保持插入顺序的，也就是说，<code>(first &#123;:a 1 :b 2&#125;)</code>的求值结果一定是<code>[:a 1]</code>。照这个思路，在我的程序当中使用<code>(first )</code>取map的第一个元素并不会出错。不过，本着谨慎的心态，我查了一下clojure的<a target="_blank" rel="noopener" href="https://clojuredocs.org/clojure.core/array-map">array-map</a>，发现一个有趣的例子：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">make-map</span> [count] (<span class="name"><span class="built_in">zipmap</span></span> (<span class="name"><span class="built_in">range</span></span> count) (<span class="name"><span class="built_in">range</span></span> count)))</span><br><span class="line">(<span class="name"><span class="built_in">type</span></span> (<span class="name">make-map</span> <span class="number">9</span>))</span><br><span class="line"><span class="comment">;; =&gt; clojure.lang.PersistentArrayMap</span></span><br><span class="line">(<span class="name"><span class="built_in">type</span></span> (<span class="name">make-map</span> <span class="number">10</span>))</span><br><span class="line"><span class="comment">;; =&gt; clojure.lang.PersistentHashMap</span></span><br></pre></td></tr></table></figure>
<p>这表明当map中的entries数量超过一定数量（不一定是9，例外见：<a target="_blank" rel="noopener" href="http://dev.clojure.org/jira/browse/CLJ-1587">PersistentArrayMap’s assoc doesn’t respect HASHTABLE_THRESHOLD</a>）时，<code>PersistentArrayMap</code>就变成了<code>PersistentHashMap</code>，那也就意味着，<code>(first )</code>取出来的值可能是<em>随机的</em>。举个例子：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">first</span></span> &#123;<span class="number">7</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">1</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">3</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">9</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">8</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">5</span> <span class="number">5</span>&#125;)</span><br><span class="line">-&gt; [<span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>返回的结果并不是相当然的<code>[7 7]</code>，而是<code>[0 0]</code>。那么<code>(first )</code>到底干了些什么呢？Cognitect公司的<a target="_blank" rel="noopener" href="https://github.com/puredanger">alexmiller</a>回答我说：<code>(first )</code>会把它的参数强制转换（coerce）成了一个序列，然后取第一个值。我们试着用<code>(seq )</code>转换一下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">type</span></span> &#123; <span class="number">7</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">1</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">3</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">9</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">8</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">5</span> <span class="number">5</span>&#125;)</span><br><span class="line">-&gt; clojure.lang.PersistentHashMap</span><br><span class="line">(<span class="name"><span class="built_in">seq</span></span> &#123; <span class="number">7</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">1</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">3</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">9</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">8</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">5</span> <span class="number">5</span>&#125;)</span><br><span class="line">-&gt; ([<span class="number">0</span> <span class="number">0</span>] [<span class="number">7</span> <span class="number">7</span>] [<span class="number">1</span> <span class="number">1</span>] [<span class="number">4</span> <span class="number">4</span>] [<span class="number">6</span> <span class="number">6</span>] [<span class="number">3</span> <span class="number">3</span>] [<span class="number">2</span> <span class="number">2</span>] [<span class="number">9</span> <span class="number">9</span>] [<span class="number">8</span> <span class="number">8</span>])</span><br></pre></td></tr></table></figure>
<p>果然，<code>[0 0]</code>出现在序列的首位。至于为什么是这样的顺序，需要深入<em>Clojure</em>的hash算法和数据结构当中，有时间另起一篇博客解释。我们再试试<code>PersistentArrayMap</code>的情况：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">type</span></span> &#123; <span class="number">7</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">1</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">3</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">9</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span> <span class="number">0</span>&#125;)</span><br><span class="line">-&gt; clojure.lang.PersistentArrayMap</span><br><span class="line">(<span class="name"><span class="built_in">seq</span></span> &#123; <span class="number">7</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">1</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">3</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">9</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span> <span class="number">0</span>&#125;)</span><br><span class="line">-&gt; ([<span class="number">7</span> <span class="number">7</span>] [<span class="number">1</span> <span class="number">1</span>] [<span class="number">4</span> <span class="number">4</span>] [<span class="number">6</span> <span class="number">6</span>] [<span class="number">3</span> <span class="number">3</span>] [<span class="number">2</span> <span class="number">2</span>] [<span class="number">9</span> <span class="number">9</span>] [<span class="number">0</span> <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>顺序确实和原来的一致。</p>
<p>我们的程序当中是不应该假设map是有序的，所以需要修改实现代码。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">letfn</span></span> [(<span class="name">period</span> [&#123;<span class="symbol">:keys</span> [periods]&#125;]</span><br><span class="line">            (<span class="name"><span class="built_in">-&gt;</span></span> periods</span><br><span class="line">                (<span class="name"><span class="built_in">-&gt;&gt;</span></span> (<span class="name"><span class="built_in">filter</span></span> (<span class="name"><span class="built_in">comp</span></span> #&#123;<span class="symbol">:available</span>&#125; <span class="symbol">:status</span>)))</span><br><span class="line">                (<span class="name"><span class="built_in">first</span></span>)</span><br><span class="line">                (<span class="name"><span class="built_in">find</span></span> <span class="symbol">:time</span>)))</span><br><span class="line">          (<span class="name">room-id</span> [room]</span><br><span class="line">            (<span class="name"><span class="built_in">find</span></span> room <span class="symbol">:room-id</span>))]</span><br><span class="line">    (<span class="name"><span class="built_in">-&gt;</span></span> rooms</span><br><span class="line">        (<span class="name"><span class="built_in">-&gt;&gt;</span></span> (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">comp</span></span> (<span class="name"><span class="built_in">partial</span></span> into &#123;&#125;) (<span class="name"><span class="built_in">juxt</span></span> room-id period)))</span><br><span class="line">             (<span class="name"><span class="built_in">filter</span></span> <span class="symbol">:time</span>)</span><br><span class="line">             (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span>)</span><br><span class="line">             (<span class="name"><span class="built_in">first</span></span>))</span><br><span class="line">        (<span class="name"><span class="built_in">or</span></span> <span class="symbol">:no-available-room</span>))))</span><br></pre></td></tr></table></figure>
<p><code>(find )</code>函数，用于从map中获取包含该键值的entry，如果找不到，返回nil。这样就避免了潜在无序的entries对程序的干扰。另外，<code>(partial into &#123;&#125;)</code>和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Currying">Currying</a>很像，它通过接收<code>into</code>函数及其首个参数，构造出一个接收后续参数的函数。当然也可以直接使用<code>#(into &#123;&#125; %)</code>这样的形式。</p>
<p>下面是麦姓朋友的另一种解法，和我的解法思路不完全一样，值得学习借鉴。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">letfn</span></span> [(<span class="name">earliest-available-time</span> [periods]</span><br><span class="line">            (<span class="name"><span class="built_in">-&gt;&gt;</span></span> periods</span><br><span class="line">                 (<span class="name"><span class="built_in">filter</span></span> (<span class="name"><span class="built_in">comp</span></span> #&#123;<span class="symbol">:available</span>&#125; <span class="symbol">:status</span>))</span><br><span class="line">                 (<span class="name"><span class="built_in">map</span></span> <span class="symbol">:time</span>)</span><br><span class="line">                 (<span class="name"><span class="built_in">sort</span></span>)</span><br><span class="line">                 (<span class="name"><span class="built_in">first</span></span>)))]</span><br><span class="line">    (<span class="name">rename-keys</span></span><br><span class="line">     (<span class="name"><span class="built_in">-&gt;&gt;</span></span> rooms</span><br><span class="line">          (<span class="name"><span class="built_in">map</span></span> #(<span class="name"><span class="built_in">update-in</span></span> % [<span class="symbol">:periods</span>] earliest-available-time))</span><br><span class="line">          (<span class="name"><span class="built_in">filter</span></span> <span class="symbol">:periods</span>)</span><br><span class="line">          (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:periods</span>)</span><br><span class="line">          (<span class="name"><span class="built_in">first</span></span>))</span><br><span class="line">     &#123;<span class="symbol">:periods</span> <span class="symbol">:time</span>&#125;)))</span><br></pre></td></tr></table></figure>
<p>真诚欢迎大家继续点评。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://github.com/qianyan/kata-bathroom/">本文样例</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2016/09/04/Reading-and-Writing-Files/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/09/04/Reading-and-Writing-Files/" class="post-title-link" itemprop="url">Reading and Writing Files</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-09-04 10:10:44" itemprop="dateCreated datePublished" datetime="2016-09-04T10:10:44+08:00">2016-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2016-09-07 16:49:21" itemprop="dateModified" datetime="2016-09-07T16:49:21+08:00">2016-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Clojure/" itemprop="url" rel="index"><span itemprop="name">Clojure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="读取和写入文件"><a href="#读取和写入文件" class="headerlink" title="读取和写入文件"></a>读取和写入文件</h2><p>数据一般都是存储在纯文本文件当中，存储的形式多种多样。本文，我会介绍如何在Clojure中读取和写入这些数据。</p>
<h3 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1. 打开文件"></a>1. 打开文件</h3><p>新建文件<em>hello.txt</em>，放到<em>resources</em>目录，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">hello lambeta!</span><br><span class="line">hello life!</span><br></pre></td></tr></table></figure>
<p>新建<em>4io.clj</em>，输入程序：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">ns</span></span> the-way-to-clojure.4io</span><br><span class="line">  (<span class="symbol">:require</span> [clojure.java.io <span class="symbol">:as</span> io]</span><br><span class="line">            [clojure.string <span class="symbol">:as</span> str]))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">def</span> <span class="title">data-file</span> (<span class="name">io/resource</span> <span class="string">&quot;hello.txt&quot;</span>))</span><br><span class="line">(<span class="name"><span class="built_in">slurp</span></span> data-file) </span><br></pre></td></tr></table></figure>
<p>运行程序，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello world! \nhello lambeta!\nhello life!\n&quot;</span><br></pre></td></tr></table></figure>
<h4 id="读取所有行"><a href="#读取所有行" class="headerlink" title="读取所有行"></a>读取所有行</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">line-seq</span></span> (<span class="name">io/reader</span> data-file))</span><br><span class="line"><span class="comment">;;=&gt; (&quot;hello world!&quot; &quot;hello lambeta!&quot; &quot;hello life!&quot;)</span></span><br></pre></td></tr></table></figure>
<h4 id="with-open宏"><a href="#with-open宏" class="headerlink" title="with-open宏"></a>with-open宏</h4><p>with-open宏用于自动关闭打开的文件。</p>
<p>1.1 读取一行，如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">when-let</span></span> [line (<span class="name">.readLine</span> rdr)]</span><br><span class="line">    (<span class="name">println</span> line)))</span><br></pre></td></tr></table></figure>

<p>1.2 读取多行，如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; read multiple lines</span></span><br><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">loop</span></span> [line (<span class="name">.readLine</span> rdr)]</span><br><span class="line">    (<span class="name"><span class="built_in">when</span></span> line</span><br><span class="line">      (<span class="name">println</span> line)</span><br><span class="line">      (<span class="name"><span class="built_in">recur</span></span> (<span class="name">.readLine</span> rdr)))))</span><br></pre></td></tr></table></figure>

<h3 id="2-读取文件的技巧"><a href="#2-读取文件的技巧" class="headerlink" title="2. 读取文件的技巧"></a>2. 读取文件的技巧</h3><p>想想读取文件可能有哪些场景？</p>
<ul>
<li>读取整个文本</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">slurp</span></span> data-file)</span><br></pre></td></tr></table></figure>

<ul>
<li>读取一行</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">first</span></span> (<span class="name"><span class="built_in">line-seq</span></span> rdr)))</span><br><span class="line"><span class="comment">;; 或者</span></span><br><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">take</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr)))</span><br><span class="line">-&gt; <span class="string">&quot;hello world!&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>读取前n行</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">doall</span></span> (<span class="name"><span class="built_in">take</span></span> <span class="number">2</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))))</span><br><span class="line">-&gt; (<span class="string">&quot;hello world!&quot;</span> <span class="string">&quot;hello lambeta!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里使用了<code>(doall )</code>方法，如果不用这个方法，在repl中求值的时候会表达式导致抛出<code>Unhandled java.io.IOException  Stream closed</code>异常。究其缘由是<code>(take 2 )</code>返回了一个惰性序列，详细解释参见文末备注。</p>
<ul>
<li>读取前n个字符</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">with-open [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">loop</span></span> [ch (<span class="name">.read</span> rdr) len <span class="number">20</span>]</span><br><span class="line">    (<span class="name"><span class="built_in">when-not</span></span> (<span class="name"><span class="built_in">or</span></span> (<span class="name"><span class="built_in">=</span></span> <span class="number">-1</span> ch) (<span class="name"><span class="built_in">zero?</span></span> len))</span><br><span class="line">      (<span class="name">println</span> (<span class="name">char</span> ch))</span><br><span class="line">      (<span class="name"><span class="built_in">recur</span></span> (<span class="name">.read</span> rdr) (<span class="name"><span class="built_in">dec</span></span> len)))))</span><br><span class="line">| h</span><br><span class="line">| e</span><br><span class="line">| ...</span><br><span class="line">-&gt; <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<ul>
<li>跳过特定的行</li>
</ul>
<p>在<em>resources</em>目录下，新建<em>records.txt</em>，内容即代码注释所示：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">read-records</span> [input-file]</span><br><span class="line">  <span class="string">&quot;Coloured fox fur production, HOPEDALE, Labrador, 1834-1842</span></span><br><span class="line"><span class="string">  #Source: C. Elton (1942) \&quot;Voles, Mice and Lemmings\&quot;, Oxford Univ. Press</span></span><br><span class="line"><span class="string">  #Table 17, p.265--266</span></span><br><span class="line"><span class="string">  22</span></span><br><span class="line"><span class="string">  29</span></span><br><span class="line"><span class="string">  2</span></span><br><span class="line"><span class="string">  16</span></span><br><span class="line"><span class="string">  12</span></span><br><span class="line"><span class="string">  35</span></span><br><span class="line"><span class="string">  8</span></span><br><span class="line"><span class="string">  83</span></span><br><span class="line"><span class="string">  166&quot;</span></span><br><span class="line">  (<span class="name"><span class="built_in">letfn</span></span> [(<span class="name">skip</span> [lines]</span><br><span class="line">            (<span class="name"><span class="built_in">next</span></span> lines))]</span><br><span class="line">         (<span class="name"><span class="built_in">with-open</span></span> [rdr ((<span class="name"><span class="built_in">comp</span></span> io/reader io/resource) input-file)]</span><br><span class="line">           (<span class="name"><span class="built_in">-&gt;&gt;</span></span></span><br><span class="line">            (<span class="name"><span class="built_in">for</span></span> [line (<span class="name">skip</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))</span><br><span class="line">                  <span class="symbol">:when</span> (<span class="name"><span class="built_in">not</span></span> (<span class="name">.startsWith</span> line <span class="string">&quot;#&quot;</span>))]</span><br><span class="line">              (<span class="name">read-string</span> line))</span><br><span class="line">            (<span class="name"><span class="built_in">apply</span></span> +)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">read-records</span> <span class="string">&quot;records.txt&quot;</span>)</span><br><span class="line">-&gt; <span class="number">373</span></span><br></pre></td></tr></table></figure>

<p>我们在<code>read-records</code>内部新建一个<code>skip</code>方法，顾名思义，跳过第一个元素，然后返回后面的列表。这里旨在跳过文本的声明头。<code>:when (not ...)</code>过滤了文本的注释部分（以#开头的行），并使用<code>read-string</code>转换字符串到数字类型，<code>(for )</code>求值完成后返回只包含数字的列表。最后，我们对列表做了一次累加操作。</p>
<p>我们试试非过滤而是跳过（删除）以”#”开头行的方式获取数字列表，这样更符合要求。重写<em>with-open</em>部分，如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr ((<span class="name"><span class="built_in">comp</span></span> io/reader io/resource) input-file)]</span><br><span class="line">      (<span class="name"><span class="built_in">apply</span></span> +</span><br><span class="line">             (<span class="name"><span class="built_in">let</span></span> [lines (<span class="name">skip</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))]</span><br><span class="line">               (<span class="name"><span class="built_in">-&gt;&gt;</span></span> lines</span><br><span class="line">                    (<span class="name"><span class="built_in">remove</span></span> (<span class="name">set</span> (<span class="name"><span class="built_in">for</span></span> [line lines <span class="symbol">:while</span> (<span class="name">.startsWith</span> line <span class="string">&quot;#&quot;</span>)] line)))</span><br><span class="line">                    (<span class="name"><span class="built_in">map</span></span> read-string)))))</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr ((<span class="name"><span class="built_in">comp</span></span> io/reader io/resource) input-file)]</span><br><span class="line">      (<span class="name"><span class="built_in">apply</span></span> +</span><br><span class="line">             (<span class="name"><span class="built_in">let</span></span> [lines (<span class="name">skip</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))]</span><br><span class="line">               (<span class="name"><span class="built_in">-&gt;&gt;</span></span> lines</span><br><span class="line">                    (<span class="name"><span class="built_in">drop</span></span> (<span class="name"><span class="built_in">count</span></span> (<span class="name"><span class="built_in">for</span></span> [line lines <span class="symbol">:while</span> (<span class="name">.startsWith</span> line <span class="string">&quot;#&quot;</span>)] line)))</span><br><span class="line">                    (<span class="name"><span class="built_in">map</span></span> read-string)))))</span><br></pre></td></tr></table></figure>
<h3 id="3-读取网络文件"><a href="#3-读取网络文件" class="headerlink" title="3. 读取网络文件"></a>3. 读取网络文件</h3><p>通过slurp读取字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(slurp &quot;http://robjhyndman.com/tsdldata/ecology1/hopedale.dat&quot; :encoding &quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line">-&gt; &quot;Coloured fox fur production, HOPEDALE, Labrador,, 1834-1925\n#Source: C. Elton (1942) \&quot;Voles, Mice and Lemmings\&quot;, Oxford Univ. Press\n#Table 17, p.265--266\n      22   \n...</span><br></pre></td></tr></table></figure>
<p>注意，这个网页上的数据是用UTF-8编码的，所以解码读取时，也应该使用UTF-8。</p>
<h3 id="4-写入文件"><a href="#4-写入文件" class="headerlink" title="4. 写入文件"></a>4. 写入文件</h3><ul>
<li>使用spit方法</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">spit</span> <span class="string">&quot;world.txt&quot;</span> <span class="string">&quot;Hello, lambeta!&quot;</span> <span class="symbol">:append</span> <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>运行程序之后，项目的根目录下会生成<em>world.txt</em>文件，内容是<em>Hello, lambeta</em>。spit方法其实就是向Java的BufferedWriter中写入内容。</p>
<ul>
<li>使用clojure.java.io&#x2F;writer</li>
</ul>
<p>我们在项目的根目录新建<em>numbers.txt</em>，内容是多行的数字对，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.3 2.7</span><br><span class="line">10000 1</span><br><span class="line">-1 1</span><br></pre></td></tr></table></figure>

<p>我们需要把每行两个数字，和它们相加的结果写入到<em>sum-of_numbers.txt</em>文件中。也就是注释中的描述。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">sum-number-pairs</span> [input-file output-file]</span><br><span class="line">  <span class="string">&quot;Read the data from input-file, which contains two floats per line</span></span><br><span class="line"><span class="string">   separated by a space.  Open file named output-file and, for each line in</span></span><br><span class="line"><span class="string">   input-file, write a line to the output file that contains the two floats</span></span><br><span class="line"><span class="string">   from the corresponding line of input-file plus a space and the sum of the</span></span><br><span class="line"><span class="string">   two floats.&quot;</span></span><br><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> input-file) wtr (<span class="name">io/writer</span> output-file <span class="symbol">:append</span> <span class="literal">true</span>)]</span><br><span class="line">    (<span class="name"><span class="built_in">loop</span></span> [line (<span class="name">.readLine</span> rdr)]</span><br><span class="line">      (<span class="name"><span class="built_in">when</span></span> line</span><br><span class="line">        (<span class="name"><span class="built_in">let</span></span> [pair (<span class="name"><span class="built_in">map</span></span> read-string</span><br><span class="line">                        (<span class="name">str/split</span> line <span class="regex">#&quot;\s&quot;</span>))</span><br><span class="line">              first (<span class="name"><span class="built_in">first</span></span> pair)</span><br><span class="line">              second (<span class="name"><span class="built_in">second</span></span> pair)</span><br><span class="line">              sum (<span class="name"><span class="built_in">+</span></span> first second)]</span><br><span class="line">          (<span class="name">.write</span> wtr (<span class="name"><span class="built_in">str</span></span> first <span class="string">&quot; &quot;</span> second <span class="string">&quot; &quot;</span> sum <span class="string">&quot;\n&quot;</span>)))</span><br><span class="line">        (<span class="name"><span class="built_in">recur</span></span> (<span class="name">.readLine</span> rdr))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">sum-number-pairs</span> <span class="string">&quot;numbers.txt&quot;</span> <span class="string">&quot;sum-of-numbers.txt&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>with-open同时打开了一个用于读取、名为<em>input-file</em>的文件以及一个用于写入、名为<em>output-file</em>的文件，写入方式是追加<code>:append true</code>。随后循环读取<em>input-file</em>中的每行内容。若<em>line</em>不是nil（即存在），那么用空格分隔这行内容，得到一个数组，如：”1.3 2.7” -&gt; [“1.3” “2.7”]。此时数组的元素类型还不是数字（Number），我们使用<code>(map read-string )</code>将元素转换为对应的数字类型，如：[“1.3” “2.7”] -&gt; [1.3 2.7]。之后，分别提取数组的第一、二个元素以及两者的和。最后，写入到wtr中。</p>
<hr>
<p><strong>注意</strong>：程序中的<em>str&#x2F;split</em>是通过<code>(:require [clojure.string :as str])</code>方式引入<em>str</em>命名空间的。</p>
<hr>
<p>运行程序之后，<em>sum-of-numbers.txt</em>中的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.3 2.7 4.0</span><br><span class="line">10000 1 10001</span><br><span class="line">-1 1 0</span><br></pre></td></tr></table></figure>

<h3 id="5-多行记录"><a href="#5-多行记录" class="headerlink" title="5. 多行记录"></a>5. 多行记录</h3><h4 id="5-1-有结束标识"><a href="#5-1-有结束标识" class="headerlink" title="5.1 有结束标识"></a>5.1 有结束标识</h4><p>有时候，记录并不是以一行一行的方式存储在文件当中的，而是以多行数据描述一条记录。比如下面的蛋白质数据：<br><strong>清单 5.1</strong> <em>multimol.pdb</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">COMPND      AMMONIA</span><br><span class="line">ATOM      1  N  0.257  -0.363   0.000</span><br><span class="line">ATOM      2  H  0.257   0.727   0.000</span><br><span class="line">ATOM      3  H  0.771  -0.727   0.890</span><br><span class="line">ATOM      4  H  0.771  -0.727  -0.890</span><br><span class="line">END</span><br><span class="line">COMPND      METHANOL</span><br><span class="line">ATOM      1  C  -0.748  -0.015   0.024</span><br><span class="line">ATOM      2  O  0.558   0.420  -0.278</span><br><span class="line">ATOM      3  H  -1.293  -0.202  -0.901</span><br><span class="line">ATOM      4  H  -1.263   0.754   0.600</span><br><span class="line">ATOM      5  H  -0.699  -0.934   0.609</span><br><span class="line">ATOM      6  H  0.716   1.404   0.137</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>第一行描述的是分子的名字，接下来到END为止的每行代表原子的ID、类型以及在分子中分布的[x y z]坐标。<br>我们需要一个函数，将数据读取出来并且以规定的格式输出，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">((&quot;AMMONIA&quot; </span><br><span class="line">    (&quot;N&quot; &quot;0.257&quot; &quot;-0.363&quot; &quot;0.000&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;0.257&quot; &quot;0.727&quot; &quot;0.000&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;0.771&quot; &quot;-0.727&quot; &quot;0.890&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;0.771&quot; &quot;-0.727&quot; &quot;-0.890&quot;)) </span><br><span class="line"> (&quot;METHANOL&quot; </span><br><span class="line">    (&quot;C&quot; &quot;-0.748&quot; &quot;-0.015&quot; &quot;0.024&quot;)</span><br><span class="line">    (&quot;O&quot; &quot;0.558&quot; &quot;0.420&quot; &quot;-0.278&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;-1.293&quot; &quot;-0.202&quot; &quot;-0.901&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;-1.263&quot; &quot;0.754&quot; &quot;0.600&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;-0.699&quot; &quot;-0.934&quot; &quot;0.609&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;0.716&quot; &quot;1.404&quot; &quot;0.137&quot;)))</span><br></pre></td></tr></table></figure>
<p>也就是说，我们需要把每条记录读入单个列表中，每个列表由分子的名称和多个<code>(Type X Y Z)</code>的原子列表组成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(defn read-all-molecules [input-file]</span><br><span class="line">  (map (fn [molecules]</span><br><span class="line">         (let [[_ name] (str/split (first molecules) #&quot;\s+&quot;)</span><br><span class="line">               atoms (map (comp #(drop 2 %) #(str/split % #&quot;\s+&quot;))</span><br><span class="line">                          (rest molecules))]</span><br><span class="line">           (concat [name] atoms)))</span><br><span class="line">       ;; 分割成多条记录</span><br><span class="line">       (remove #(= % [&quot;END&quot;]) </span><br><span class="line">               (partition-by #(= % &quot;END&quot;) (line-seq (io/reader input-file))))))</span><br><span class="line"></span><br><span class="line">(read-all-molecules &quot;multimol.pdb&quot;)</span><br></pre></td></tr></table></figure>
<p><code>(remove #(= % [&quot;END&quot;]) (partition-by #(= % &quot;END&quot;) (line-seq (io/reader input-file))))</code>这行代码做的事情就是把文件读取出来变成一个<code>lazy-seq</code>，然后使用<code>parttition-by</code>以<em>END</em>进行分组，最后使用<code>remove</code>方法剔除掉*[“END”]*这样的分组，得到如下中间结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">((&quot;COMPND      AMMONIA&quot; </span><br><span class="line">  &quot;ATOM      1  N  0.257  -0.363   0.000&quot;</span><br><span class="line">  &quot;ATOM      2  H  0.257   0.727   0.000&quot;</span><br><span class="line">  &quot;ATOM      3  H  0.771  -0.727   0.890&quot;</span><br><span class="line">  &quot;ATOM      4  H  0.771  -0.727  -0.890&quot;) </span><br><span class="line"> (&quot;COMPND      METHANOL&quot; </span><br><span class="line">  &quot;ATOM      1  C  -0.748  -0.015   0.024&quot;</span><br><span class="line">  &quot;ATOM      2  O  0.558   0.420  -0.278&quot;</span><br><span class="line">  &quot;ATOM      3  H  -1.293  -0.202  -0.901&quot; </span><br><span class="line">  &quot;ATOM      4  H  -1.263   0.754   0.600&quot;</span><br><span class="line">  &quot;ATOM      5  H  -0.699  -0.934   0.609&quot; </span><br><span class="line">  &quot;ATOM      6  H  0.716   1.404   0.137&quot;))</span><br></pre></td></tr></table></figure>
<p>这样离我们的目标已经很近了。观察上述结果，不难发现分子的名称处于列表的第一个<code>(first )</code>，而原子列表可以使用<code>(rest )</code>获取。然后，借助<code>(map )</code>函数遍历所有的记录。</p>
<p><code>(let )</code>中的第一个binding是<code>[_ name] (str/split (first molecules) #&quot;\s+&quot;)</code>，首先用<code>(split )</code>函数分割，再使用了解构提取出分子的名称；第二个binding是原子列表的提取，我们在<code>(split )</code>的基础之上，使用<code>(drop 2 )</code>函数剔除了不用的字段，如：ATOM和1。最后使用<code>(concat )</code>函数将名称和原子列表的列表拼接到一起。</p>
<h4 id="5-2-无结束标识"><a href="#5-2-无结束标识" class="headerlink" title="5.2 无结束标识"></a>5.2 无结束标识</h4><p>5.1中的记录项通过<em>END</em>标识分隔，但是事实上这是一个多余的字段，记录项可以更简练，如下：<br><strong>清单 5.2</strong> <em>multimol-without-end-marker.pdb</em></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">COMPND      AMMONIA</span><br><span class="line">ATOM      <span class="number">1</span>  N  <span class="number">0.257</span>  <span class="number">-0.363</span>   <span class="number">0.000</span></span><br><span class="line">ATOM      <span class="number">2</span>  H  <span class="number">0.257</span>   <span class="number">0.727</span>   <span class="number">0.000</span></span><br><span class="line">ATOM      <span class="number">3</span>  H  <span class="number">0.771</span>  <span class="number">-0.727</span>   <span class="number">0.890</span></span><br><span class="line">ATOM      <span class="number">4</span>  H  <span class="number">0.771</span>  <span class="number">-0.727</span>  <span class="number">-0.890</span></span><br><span class="line">COMPND      METHANOL</span><br><span class="line">ATOM      <span class="number">1</span>  C  <span class="number">-0.748</span>  <span class="number">-0.015</span>   <span class="number">0.024</span></span><br><span class="line">ATOM      <span class="number">2</span>  O  <span class="number">0.558</span>   <span class="number">0.420</span>  <span class="number">-0.278</span></span><br><span class="line">ATOM      <span class="number">3</span>  H  <span class="number">-1.293</span>  <span class="number">-0.202</span>  <span class="number">-0.901</span></span><br><span class="line">ATOM      <span class="number">4</span>  H  <span class="number">-1.263</span>   <span class="number">0.754</span>   <span class="number">0.600</span></span><br><span class="line">ATOM      <span class="number">5</span>  H  <span class="number">-0.699</span>  <span class="number">-0.934</span>   <span class="number">0.609</span></span><br><span class="line">ATOM      <span class="number">6</span>  H  <span class="number">0.716</span>   <span class="number">1.404</span>   <span class="number">0.137</span></span><br></pre></td></tr></table></figure>
<p>现在的问题变成了没有<em>END</em>标识符，如何进行分组？观察不难发现以<em>COMPND</em>开头的数据行可以作为记录的分隔符。<br>使用<code>(partition-by #(.startsWith % &quot;COMPND&quot;) (line-seq (io/reader input-file)))</code>进行分组，得到的结果如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">((<span class="string">&quot;COMPND      AMMONIA&quot;</span>) </span><br><span class="line">  (<span class="string">&quot;ATOM      1  N  0.257  -0.363   0.000&quot;</span> </span><br><span class="line">   <span class="string">&quot;ATOM      2  H  0.257   0.727   0.000&quot;</span> </span><br><span class="line">   <span class="string">&quot;ATOM      3  H  0.771  -0.727   0.890&quot;</span></span><br><span class="line">   <span class="string">&quot;ATOM      4  H  0.771  -0.727  -0.890&quot;</span>) </span><br><span class="line"> (<span class="string">&quot;COMPND      METHANOL&quot;</span>) </span><br><span class="line">  (<span class="string">&quot;ATOM      1  C  -0.748  -0.015   0.024&quot;</span> </span><br><span class="line">   <span class="string">&quot;ATOM      2  O  0.558   0.420  -0.278&quot;</span> </span><br><span class="line">   <span class="string">&quot;ATOM      3  H  -1.293  -0.202  -0.901&quot;</span></span><br><span class="line">   <span class="string">&quot;ATOM      4  H  -1.263   0.754   0.600&quot;</span></span><br><span class="line">   <span class="string">&quot;ATOM      5  H  -0.699  -0.934   0.609&quot;</span></span><br><span class="line">   <span class="string">&quot;ATOM      6  H  0.716   1.404   0.137&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>此时，我们对比5.1中中间结果，会发现它们极为相似。也就是说，我们稍加转换就能让两者一致，而一致的好处就是可以复用原来<code>(map )</code>中的逻辑。</p>
<p>稍稍修改原来的分组逻辑，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(map (fn [[name atoms]] (concat name atoms))</span><br><span class="line">       (partition 2</span><br><span class="line">                  (partition-by</span><br><span class="line">                   #(.startsWith % &quot;COMPND&quot;)</span><br><span class="line">                   (line-seq (io/reader input-file)))))</span><br></pre></td></tr></table></figure>
<p>我们先使用<code>(partition 2 )</code>将第一步得到的列表每隔两个元素划为一组，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(((&quot;COMPND      AMMONIA&quot;) </span><br><span class="line">  (&quot;ATOM      1  N  0.257  -0.363   0.000&quot; </span><br><span class="line">   &quot;ATOM      2  H  0.257   0.727   0.000&quot; </span><br><span class="line">   &quot;ATOM      3  H  0.771  -0.727   0.890&quot;</span><br><span class="line">   &quot;ATOM      4  H  0.771  -0.727  -0.890&quot;)) ; 多出一对括号</span><br><span class="line"> ((&quot;COMPND      METHANOL&quot;) </span><br><span class="line">  (&quot;ATOM      1  C  -0.748  -0.015   0.024&quot; </span><br><span class="line">   &quot;ATOM      2  O  0.558   0.420  -0.278&quot; </span><br><span class="line">   &quot;ATOM      3  H  -1.293  -0.202  -0.901&quot;</span><br><span class="line">   &quot;ATOM      4  H  -1.263   0.754   0.600&quot;</span><br><span class="line">   &quot;ATOM      5  H  -0.699  -0.934   0.609&quot;</span><br><span class="line">   &quot;ATOM      6  H  0.716   1.404   0.137&quot;)))</span><br></pre></td></tr></table></figure>
<p>然后使用<code>(map (fn [[name atoms]] ...)</code>将每组里面的两个列表合成为一个列表，这样就得到和原来5.1一模一样的中间结果。</p>
<p>接下来，我们把转换的逻辑从<code>(read-all-molecules )</code>中提取出来，以便复用。改造如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">read-all-molecules</span> [f input-file]</span><br><span class="line">  (<span class="name"><span class="built_in">let</span></span> [data (<span class="name">f</span> input-file)]</span><br><span class="line">    (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">fn</span></span> [molecules]</span><br><span class="line">           (<span class="name"><span class="built_in">let</span></span> [[_ name] (<span class="name">str/split</span> (<span class="name"><span class="built_in">first</span></span> molecules) <span class="regex">#&quot;\s+&quot;</span>)</span><br><span class="line">                 atoms (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">comp</span></span> #(<span class="name"><span class="built_in">drop</span></span> <span class="number">2</span> %) #(<span class="name">str/split</span> % <span class="regex">#&quot;\s+&quot;</span>))</span><br><span class="line">                            (<span class="name"><span class="built_in">rest</span></span> molecules))]</span><br><span class="line">             (<span class="name"><span class="built_in">concat</span></span> [name] atoms))) data)))</span><br></pre></td></tr></table></figure>
<p>定义转换逻辑，如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">file-without-markers-&gt;multi-records</span> [input-file]</span><br><span class="line">  (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">fn</span></span> [[name atoms]] (<span class="name"><span class="built_in">concat</span></span> name atoms))</span><br><span class="line">       (<span class="name"><span class="built_in">partition</span></span> <span class="number">2</span></span><br><span class="line">                  (<span class="name">partition-by</span></span><br><span class="line">                   #(<span class="name">.startsWith</span> % <span class="string">&quot;COMPND&quot;</span>)</span><br><span class="line">                   (<span class="name"><span class="built_in">line-seq</span></span> (<span class="name">io/reader</span> input-file))))))</span><br></pre></td></tr></table></figure>
<p>最后，我们来调用的改造之后的方法：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">read-all-molecules</span> </span><br><span class="line">        file-without-markers-&gt;multi-records <span class="string">&quot;multimol-without-end-marker.pdb&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>此时，5.1中的转换逻辑也可以提取出一个函数：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">file-&gt;multi-records</span></span><br><span class="line">  (<span class="name"><span class="built_in">remove</span></span> #(<span class="name"><span class="built_in">=</span></span> % [<span class="string">&quot;END&quot;</span>]) </span><br><span class="line">               (<span class="name">partition-by</span> #(<span class="name"><span class="built_in">=</span></span> % <span class="string">&quot;END&quot;</span>) (<span class="name"><span class="built_in">line-seq</span></span> (<span class="name">io/reader</span> input-file)))))</span><br></pre></td></tr></table></figure>
<p>原来的程序就重构成了如下的模样：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">read-all-molecules</span> file-&gt;multi-records <span class="string">&quot;multimol.pdb&quot;</span>)</span><br></pre></td></tr></table></figure>


<hr>
<p><strong>备注</strong></p>
<p>为了清楚定位这个问题，我们需要提前了解两个知识点</p>
<ol>
<li>什么是惰性序列？</li>
<li>惰性序列在repl中什么时候变现（realizes）？</li>
</ol>
<p>惰性序列是用<code>(lazy-seq [&amp; body] )</code>宏创建出来的。<code>lazy-seq</code>仅在需要的时候才会去调用它的body。<br>当repl尝试<code>pretty-print</code>惰性序列的结果时，才会进行变现操作。</p>
<p>有了上面的知识点，我们来考察<code>with-open</code>和<code>(take 2 (line-seq ))</code>的关系。<code>with-open</code>是宏，我们使用<code>clojure.walk/macroexpand-all</code>展开下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">clojure.walk/macroexpand-all</span> </span><br><span class="line">    &#x27;(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">                      (<span class="name"><span class="built_in">take</span></span> <span class="number">2</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))))</span><br><span class="line">                      </span><br><span class="line">-&gt; (<span class="name">let*</span> [rdr (<span class="name">io/reader</span> data-file)] </span><br><span class="line">        (<span class="name"><span class="built_in">try</span></span> (<span class="name"><span class="built_in">do</span></span> </span><br><span class="line">                (<span class="name"><span class="built_in">take</span></span> <span class="number">2</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))) </span><br><span class="line">        (<span class="name">finally</span> (<span class="name"><span class="built_in">.</span></span> rdr clojure.core/close))))                      </span><br></pre></td></tr></table></figure>
<p>使用<code>(doc line-seq)</code>查看文档，得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clojure.core/line-seq</span><br><span class="line"> [rdr]</span><br><span class="line">Added in 1.0</span><br><span class="line">  Returns the lines of text from rdr as a lazy sequence of strings.</span><br><span class="line">  rdr must implement java.io.BufferedReader.</span><br></pre></td></tr></table></figure>
<p>可以确认<code>line-seq</code>返回一个惰性的字符串序列。<br>再看看<code>(doc take)</code>的文档，得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clojure.core/take</span><br><span class="line"> [n]</span><br><span class="line"> [n coll]</span><br><span class="line">Added in 1.0</span><br><span class="line">  Returns a lazy sequence of the first n items in coll, or all items if</span><br><span class="line">  there are fewer than n.  Returns a stateful transducer when</span><br><span class="line">  no collection is provided.</span><br></pre></td></tr></table></figure>
<p>所以<code>take</code>返回的也是一个惰性序列，那么<code>(do (take 2 (line-seq rdr)))</code>（等价于<code>(take 2 (line-seq rdr))</code>）整个返回的就是一个惰性序列。</p>
<p>当我们通过repl求值<code>with-open</code>时，它并没有真的变现<code>(take 2 (line-seq rdr))</code>，而是在运行完<code>try...finally</code>之后，直接返回这个惰性序列作为结果。此时，repl开始尝试pretty-print <code>(take 2 (line-seq rdr))</code>，变现发生，但是rdr已经被关闭了，所以抛出<em>Stream closed</em>异常。</p>
<p>到这里，解决了一大半问题，但是还有一个逻辑上解释不过去的点，就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(with-open [rdr (io/reader data-file)]</span><br><span class="line">  (take 1 (line-seq rdr)))</span><br></pre></td></tr></table></figure>
<p>当我们尝试<code>(take 1 )</code>时并不会抛出异常！也就是说<code>(take 1 )</code>和<code>(take 2 )</code>的行为不同，但是<code>(take )</code>明明都是返回惰性序列啊？</p>
<p>带着这个疑惑，看看<code>line-seq</code>的源代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(when-let [line (.readLine rdr)]</span><br><span class="line">    (cons line (lazy-seq (line-seq rdr)))))</span><br></pre></td></tr></table></figure>
<p>是不是有种豁然开朗的感觉？没有也没关系，我来解释一下。<br><code>line-seq</code>的<code>when-let</code>语句并没有包在<code>(lazy-seq )</code>（这点可以和<code>take</code>的源码比较）中，这说明<code>[line (.readline rdr)]</code>是需要立即求值的。也就是说，我们在求值<code>with-open</code>时，rdr中第一行的内容会被<code>(line-seq )</code>给抓住了。那么当<code>try...finally</code>运行结束之后，pretty-print变现惰性序列时，发现第一行根本不需要从rdr中读，当然就不会抛出异常了。</p>
<p>明确这几点之后，我们看看<code>(doall )</code>为何能解决惰性序列延迟求值的问题？<code>(doall )</code>其实强制变现了整个惰性序列（不断调用序列的<code>next</code>方法），所以并不会等到<code>with-open</code>求值完成之后才求值。</p>
<p>换个角度，我们知道之所以抛出异常，是因为repl对返回的惰性序列求值了。那么如果我们不在repl中求值，程序还会抛出异常吗？</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">ns</span></span> the-way-to-clojure.core</span><br><span class="line">  (<span class="symbol">:require</span> [clojure.java.io <span class="symbol">:as</span> io])</span><br><span class="line">  (<span class="symbol">:gen-class</span>))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">-main</span> [&amp; args]</span><br><span class="line">  (<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> <span class="string">&quot;hello.txt&quot;</span>)]</span><br><span class="line">    (<span class="name"><span class="built_in">take</span></span> <span class="number">100</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))))</span><br></pre></td></tr></table></figure>
<p>接着，我们使用<code>lein run</code>来运行<code>main</code>方法。程序运行良好，因为根本没有人用到返回的惰性序列。</p>
<p>如果我们加一句打印语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defn -main [&amp; args]</span><br><span class="line">  (println          ; 变现</span><br><span class="line">      (with-open [rdr (io/reader &quot;hello.txt&quot;)]</span><br><span class="line">        (take 100 (line-seq rdr)))))</span><br></pre></td></tr></table></figure>
<p>再用<code>lein run</code>跑一个<code>main</code>方法，异常又不期而遇了。因为此处的<code>println</code>等价于<code>repl</code>的<code>pretty print</code>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">lambeta</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
