<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qianyan.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Elegance and familiarity are orthogonal">
<meta property="og:type" content="website">
<meta property="og:title" content="λ">
<meta property="og:url" content="https://qianyan.github.io/page/2/index.html">
<meta property="og:site_name" content="λ">
<meta property="og:description" content="Elegance and familiarity are orthogonal">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lambeta">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://qianyan.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>λ</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">λ</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">(conj clojurians me)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lambeta</p>
  <div class="site-description" itemprop="description">Elegance and familiarity are orthogonal</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/qianyan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qianyan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qianyan.lambda@gmail.com" title="E-Mail → mailto:qianyan.lambda@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/3672207020" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;3672207020" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/_qian_yan" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;_qian_yan" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://blog.jayfields.com/" title="http:&#x2F;&#x2F;blog.jayfields.com&#x2F;" rel="noopener" target="_blank">Jay Fields</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://aphyr.com/" title="https:&#x2F;&#x2F;aphyr.com" rel="noopener" target="_blank">Aphyr</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://bucharestfp.ro/" title="http:&#x2F;&#x2F;bucharestfp.ro" rel="noopener" target="_blank">Bucharest FP</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://www.yinwang.org/" title="http:&#x2F;&#x2F;www.yinwang.org" rel="noopener" target="_blank">Wangyin</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://blog.rlmflores.me/" title="http:&#x2F;&#x2F;blog.rlmflores.me&#x2F;" rel="noopener" target="_blank">Rodrigo Flores</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://seancorfield.github.io/" title="https:&#x2F;&#x2F;seancorfield.github.io&#x2F;" rel="noopener" target="_blank">Seancorfield</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2019/01/17/Guide-to-Clean-Architecture-2-more/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/17/Guide-to-Clean-Architecture-2-more/" class="post-title-link" itemprop="url">架构整洁之道导读（二）续 组件聚合张力图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-01-17 15:16:04 / 修改时间：15:23:15" itemprop="dateCreated datePublished" datetime="2019-01-17T15:16:04+08:00">2019-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="关于组件聚合张力图的讨论"><a href="#关于组件聚合张力图的讨论" class="headerlink" title="关于组件聚合张力图的讨论"></a>关于组件聚合张力图的讨论</h2><p>周三的午休时间，我在ThoughtWorks北京办公室分享了一场《架构整洁之道导读》。当谈到分享组件聚合原则的时候，很多同事表示难以理解。究其缘由，是我们无法将组件违反原则的后果对应到真实项目的问题上，这就导致原则和实践之间的不一致。讨论的过程异常激烈，但是很遗憾地最终并没有得到一个服众的结论。所以为了进一步澄清这些争议点，我决定专门组织一场针对组件聚合原则张力图的讨论会。在<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/49ddfba9ae88">吴大师</a>的鼓动下，时间定在下周四晚上的8点半，与会人员大多是咨询团队的技术教练，也有我们项目上的客户。</p>
<p>在这场长达两个半小时的讨论会上，没想到首先出现争议的点居然是组件的定义。</p>
<blockquote>
<p>组件是软件部署的最小单元，是整个软件系统在部署过程中可以独立完成部署的最小实体。</p>
</blockquote>
<p>对于这样的定义，<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/nuo-tie">大魔头</a>提出了质疑：library（库）并不能独立部署。但凡出现明显的逻辑漏洞的时候，我们最好的方式是抛开译文回去看原文。</p>
<blockquote>
<p>Components are the units of deployment. They are the smallest entities that can be deployed as part of a system.</p>
</blockquote>
<p>阅读原文之后，我们发现“组件是软件部署的最小单元。”这句话翻译得并没有太大问题，但是第二句就有损原意了，原意是说<strong>可以作为系统的一部分被部署的最小实体</strong>，而没有强调部署过程这种动态的概念，否则就和前一句是同义反复。所以这个定义里面并没有说组件可以独立部署。后面提到组件可以被链接到一个独立可执行文件或者归档文件，又或者，可以被打包成.jar、.dll或者.exe文件，并以动态加载的插件形式实现<strong>独立部署</strong>。</p>
<h3 id="解读组件的定义"><a href="#解读组件的定义" class="headerlink" title="解读组件的定义"></a>解读组件的定义</h3><p>来自原文：</p>
<blockquote>
<p>Components can be linked together into a single executable. Or they can be aggregated together into a single archive, such as a .war file. Or they can be independently deployed as separate dynamically loaded plugins, such as.jar or .dll or .exe files.</p>
</blockquote>
<p>来自讨论：</p>
<blockquote>
<p>20:56:56	 From tianjie : These dynamically linked files, which can be plugged together at runtime, are the software components of our architectures.</p>
</blockquote>
<p>联系上下文理解之后，我们知道：组件可以被设计成独立部署的，但是并不是所有的组件都是可以独立部署的。这是要澄清的，不然讨论聚合原则的时候容易出现偏差。</p>
<p>吴大师接着解释说，组件应该是个逻辑单元，而不是物理单元。强制某个代码模块就是一个物理的部署单元是不合适的。另外，鲍勃大叔在介绍架构边界时，也表明了一样的观点：架构的边界并不是服务的边界。</p>
<h3 id="解读REP原则"><a href="#解读REP原则" class="headerlink" title="解读REP原则"></a>解读REP原则</h3><p>我按照自己的思路解释过REP、CCP和CRP原则[^1]之后，讨论的焦点很快聚集到REP原则的解读和实践意义上。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/wu-xue-feng/">吴大师</a>认为REP原则如果简单解读成没有发布过程就不能复用，它就和CCP、CRP原则的排斥力量不均衡，无法形成稳定的三角关系，那么这个张力图就显得有点鸡肋。</p>
<p><a target="_blank" rel="noopener" href="https://www.thoughtworks.com/cn/profiles/liu-shangqi">尚奇</a>受到CAP（分布式系统基本原理，一致性，可用性和分区容错性）原则的启发提出了另一个解读方向。他说，CAP原则在分布式系统的实践里，都会先站住P原则，然后在C和A中权衡。那么在REP、CCP和CRP三角关系里，REP原则就相当于这里的P原则，必须先满足然后再去取舍CCP和CRP。</p>
<p>大魔头理解REP的意思是可复用性就是组件是独立可复用的。假如回到没有Maven这些工具，没有依赖管理的年代，如果我们所依赖的包还依赖其它第三方包，那么这个包就不能叫做独立可复用。</p>
<blockquote>
<p>21:13:04	 From YangYun : 我倒是理解REP的意思是你发布出来的一个可重用的包就是独立可重用的，你不能让我必须带着别的jar包才能用它。<br>21:14:04	 From YangYun : The granule of reuse is the granule of release</p>
</blockquote>
<p>他接着说，假如有两个提供同样功能的包，其中一个没有第三方的依赖，而另一个有，那我当然选择前者。</p>
<p>技术教练Sara举出了一个相对复杂但是很有启发性的例子。</p>
<blockquote>
<p>21:46:35	 From Qian Ping : 假设项目包含sub module ABC<br> - 如果ABC单纯sub module没有打成jar，又互相直接复用了，就是违反了REP<br> - 如果每个sub module，打成jar，互相复用的时候是通过对方特定版本的jar（如snapshot版本），就是符合REP<br> - 如果符合REP了，而所有sub module是跟随整个项目一起升级版本，就是符合CCP因为他们是一体一起发布的<br> - 这时假如A依赖B和C，我这次单纯想改C，他们一起升版本了。但其实B的Jar完全没有变化，这个对B来说就是一个不必要的发布，B又貌似应该分离出去，但如果它分离出去了，就又离REP和CCP远了</p>
</blockquote>
<p>对于最后一句的表述，她澄清道：</p>
<blockquote>
<p>之前有遇到一个情况，比如组件A，然后它里面需要用到一个common library, lib里面其实包含了比如3个sub module（1&#x2F;2&#x2F;3），全部都是A需要复用的, 这时候如果要改1&#x2F;2&#x2F;3里面任意的东西，都会一起升级lib，然后在A里面对应升级版本。</p>
</blockquote>
<blockquote>
<p>后来，有一些新组件B，它只需要用到common lib里面的3，不需要1&#x2F;2，于是3一直被改和打包版本。 此时1&#x2F;2会跟着升版本号，但其实1&#x2F;2内容本身是完全没有变化的，只是版本号升了。</p>
</blockquote>
<p>这个场景中引入了两个组件A和B分别依赖common library的某些模块。在我们讨论一个组件依赖时，面临的约束要简单很多，但是复用的初衷就是给多个组件去依赖，所以这个假设是很有价值。</p>
<p>Sara分析的思路如下：</p>
<blockquote>
<p>如果分离出去，等于我有两个common lib（1&#x2F;2 和 3）, 对于B来说，B只需要3这么一个lib是比较完美的，反正改了3再改B就好了。</p>
</blockquote>
<blockquote>
<p>但对于A来说，它就需要同时升级1&#x2F;2的lib和3的lib，等于要3个发布，而它原来只需要2个发布（1&#x2F;2&#x2F;3 + A），所以离CRP远了，同时它也要分别维护两个lib分别的版本升级，所以CCP也比原来差了。</p>
</blockquote>
<p>在她的分析下，我们发现CRP和CCP不单是互相排斥的，还有可能两者都无法满足。造成这种结果的原因在于1&#x2F;2&#x2F;3模块形成的这个common library对于A组件而言都符合CCP和CRP原则，但是对于B组件而言，是不满足REP和CRP原则的，因为每次想要依赖3模块，就得全部依赖1&#x2F;2&#x2F;3整个common library（复用困难）。反之，如果我们将3从1&#x2F;2&#x2F;3中拆出来成为独立的组件，那就几乎宣告对于A组件而言势必违反CCP和CRP原则，但是B组件却获得了符合REP和CRP原则的好处。</p>
<p>她接着补充道：</p>
<blockquote>
<p>其实后来说起对应微服务的时候有另外一个想法，就是比如说我系统里面多个组件需要用计提（Mark to market[^2]）这么一个功能，说白了就是一条公式，那通常可以有几个做法</p>
<ul>
<li>直接把这个公式复制到要用的组件，code level的复用，没有版本 -&gt; REP bad, CCP bad, but CRP not bad (因为要更改时候发布次数还是一样的）</li>
<li>把公式写到一个common lib里面再进行复用 -&gt; REP good, CCP good, CRP bad(多发布一次）</li>
<li>把公式放在一个独立service -&gt; REP good, CCP bad(因为要维护多一个服务）, CRP good</li>
</ul>
</blockquote>
<p>这个观点就上升到不同层次的复用性上，可以算是对组件聚合原则的普适性的探索。</p>
<p>当话题再次被聚焦到复用性时，技术教练<a target="_blank" rel="noopener" href="https://litongxin.github.io/">MoMo</a>提出一个观点：我们现在讨论就是可复用组件应该遵循的原则，而REP是对复用粒度的定义。至于那些那些常年采用SNAPSHOT（Java项目里Maven常用的开发版本号），没有发布概念的组件，就不该纳入复用的考虑范围内，那些也就不是REP的反模式。</p>
<p>与此同时，<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YkKz4lknR2fqbSgv4JL9Lw">阎王</a>指出了一个翻译上的失误。组件粘合张力图中REP原则的简短描述是“为复用性而组合”，而原文其实是”Group for reusers”，翻译过来应该是为了复用者而组合，复用性的英文是 Reusability。所以为了复用者发布，考虑的就是对外部的承诺。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-97f1eb1dfe9e1314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tension diagram"></p>
<h3 id="外部资料"><a href="#外部资料" class="headerlink" title="外部资料"></a>外部资料</h3><p>大魔头在加班写方案和讨论的间隙，快速查阅了一些资料，比如wiki上对于REP原则的定义：</p>
<blockquote>
<p>21:45:05 From YangYun : Reuse-release Equivalence Principle (REP)<br>REP essentially means that the package must be created with reusable classes – “Either all of the classes inside the package are reusable, or none of them are”. The classes must also be of the same family. Classes that are unrelated to the purpose of the package should not be included. A package constructed as a family of reusable classes tends to be most useful and reusable. - wiki百科里</p>
</blockquote>
<p>在wiki的定义里，可以看到REP原则包含CRP和CCP原则的成分，如此看来，这三大原则并不符合<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MECE_principle">MCME</a>分类原则，就连鲍勃大叔在书中也是模棱两可的态度——REP维护共同的大主题，组件中的类和模块也必须紧密相关，这基本是CCP和CRP的简版描述。</p>
<p>然后大魔头查找到“粒度”这个词在软件设计中详细定义，这是对REP原则定义（软件复用的最小粒度等同于其发布的最小粒度）的分解和再认知。</p>
<blockquote>
<p>21:57:03	 From YangYun : <a target="_blank" rel="noopener" href="http://condor.depaul.edu/dmumaugh/OOT/Design-Principles/granularity.pdf">http://condor.depaul.edu/dmumaugh/OOT/Design-Principles/granularity.pdf</a></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-31f16cf3b2bb8922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="granularity"></p>
<blockquote>
<p>21:58:29	 From YangYun : <a target="_blank" rel="noopener" href="https://fi.ort.edu.uy/innovaportal/file/2032/1/design_principles.pdf">https://fi.ort.edu.uy/innovaportal/file/2032/1/design_principles.pdf</a></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-c3db0f42dde964ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="design principles"></p>
<p>这些观点和学术建议很有代表性，值得大家反复揣摩和思考。</p>
<h3 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h3><p>软件工程师一般有个“正难则反”的习惯。原则较抽象，但是模式很具体，反模式更能指导实践。接下来，大家开始讨论哪些是违反了REP原则的反模式。</p>
<p>首当其冲的就是<code>git submodule</code>，在某些项目中，这种通过源代码划分模块并共享的方式还是挺常见的。因为共享的是代码，所以每次共享代码更新，势必要让依赖方重新编译，发布和部署。这种做法对于复用是痛苦的。</p>
<p>其次是常年使用SNAPSHOT版本的某些项目。这些项目的特点一般都是某个产品团队底下，内部团队之间有复用的要求。缺点其实也很明显，常年SNAPSHOT等于没有版本和发布的流程。使用者并不知道SNAPSHOT中哪些是稳定的，哪些是修改的，拿到的版本到底是最新的还是遗留的，我需要的功能在这个功能有包含，还是你包含了太多我不需要的升级。这种也是复用痛苦的。</p>
<h3 id="REP原则小结"><a href="#REP原则小结" class="headerlink" title="REP原则小结"></a>REP原则小结</h3><p>综合以上两个例子以及其它讨论，我们得出了一个好玩的结论：软件工程发展到现在，REP原则已经是基本的要求，它的存在有可能是鲍勃大叔年代感<del>老了</del>的体现。</p>
<p>[^1]: <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/96e2d580374f">架构整洁之道导读（二）组件聚合</a> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d651c9fb1755#fnref1"></a><br>[^2]: <a target="_blank" rel="noopener" href="https://www.investopedia.com/terms/m/marktomarket.asp">Mark to market 按市值计价</a></p>
<p>[1] <a href="/2018/10/28/Guide-to-Clean-Architecture-1/">架构整洁之道导读（一）编程范式</a><br>[2] <a href="/2019/01/17/Guide-to-Clean-Architecture-2/">架构整洁之道导读（二）组件聚合</a><br>于 2018-11-12</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2019/01/17/Guide-to-Clean-Architecture-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/17/Guide-to-Clean-Architecture-2/" class="post-title-link" itemprop="url">架构整洁之道导读（二）组件聚合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-01-17 15:12:38 / 修改时间：15:22:08" itemprop="dateCreated datePublished" datetime="2019-01-17T15:12:38+08:00">2019-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="组件聚合"><a href="#组件聚合" class="headerlink" title="组件聚合"></a>组件聚合</h2><h3 id="组件的定义"><a href="#组件的定义" class="headerlink" title="组件的定义"></a>组件的定义</h3><p>组件是软件部署的最小单元，是整个软件系统在部署过程中可以独立完成部署的最小实体。比如，对于Java应用程序而言，Jar包就是组件；Ruby中的组件则是Gem文件；Python中的Egg或Wheel文件以及.Net下的DLL文件。</p>
<p>上回我们说到，编程范式的本质是约束。子过程、类或函数是我们编程过程中的基本元素，所以说编程范式是程序的基础构件。如果将这些基本构件比作建筑里的泥沙石，那么程序中的组件就可以类比成砖头。砖头的工艺注重材料配比，组件也是如此，恰如其分的基础构件配比是组件稳定的基础。组件的内容配比较难定量，但是在实践上，仍然受到指导原则的约束。</p>
<h3 id="软件工程中的约束三角"><a href="#软件工程中的约束三角" class="headerlink" title="软件工程中的约束三角"></a>软件工程中的约束三角</h3><p>在软件工程中，我们会看到很多约束条件都能由三角形的方式体现出来。这是因为三角形除了具有稳定的特性以外，还能体现出一种张力。<br><img src="https://upload-images.jianshu.io/upload_images/217988-c19cb030d6c0b04c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="软件开发中的各种三角"></p>
<p>比如在敏捷项目管理中，我们常会听到时间，资源和成本的约束三角；在分布式计算中，著名的CAP（一致性，可用性和分区容错性）原理也是如此；还有区块链中的不可能三角（性能，安全和去中心化）。这些三角都在反映一种现实中的约束——因为不能全部同时满足，所以需要权衡。</p>
<h3 id="组件聚合张力图"><a href="#组件聚合张力图" class="headerlink" title="组件聚合张力图"></a>组件聚合张力图</h3><p>组件的内容配比，最终反映在组件的实践上就是基本构件的拆与合。鲍勃大叔给出了三个拆合的指导原则：REP（复用&#x2F;发布等同原则），CCP（共同闭包原则）和CRP（共同复用原则）。<br><img src="https://upload-images.jianshu.io/upload_images/217988-e21240f0dc564114.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组件聚合张力图"></p>
<ol>
<li>REP（复用&#x2F;发布等同原则）：软件复用的最小粒度应该等同于其发布的最小粒度（注：只有那些通过版本追踪系统发布的组件才能被高效地复用）</li>
<li>CCP（共同闭包原则）：将同时修改，目的相同的类放到同一个组件；不会同时修改，目的不同的类放到不同的组件</li>
<li>CRP（共同复用原则）：不要强迫一个组件的用户依赖他们不需要的东西</li>
</ol>
<p>这些原则乍看上去是全新的理念，细细品来又好像“新瓶装旧酒”的老把戏。CCP不就是SRP（单一职能原则）？CRP不就是ISP（接口隔离原则）？REP，等等，这个原则不言自明地像个公理呀！难怪有些架构师朋友说，鲍勃大叔老了，又拿着SOLID那一套概念出来忽悠<del>骗钱</del>。</p>
<p>其实，不妨换个思路想想，通常当谈论SOLID、高内聚低耦合、稳定依赖、稳定抽象系列原则的时候，我们是处于软件系统生命周期的哪一环？不出意外，大家都是从编写源代码，即开发（Development）的角度出发的。但是，我们又清晰地了解，软件系统的生命周期其实还包含除开发之外的部署、发布，运行和维护环节。那么问题来了，在这些环节里，哪些指导原则是适用的呢？</p>
<p>在跳脱了开发的思维桎梏之后，我们通过两种手段分析下这三条原则。</p>
<h4 id="分开看"><a href="#分开看" class="headerlink" title="分开看"></a>分开看</h4><p>REP原则阐述了一个简单的道理：软件复用是基本要求。在追求软件复用的过程中，逐步形成了标准的发布流程，如：版本号（<a target="_blank" rel="noopener" href="https://semver.org/lang/zh-CN/">语义化版本</a>），发布时间，变更内容等。这要求组件中所包含的模块和类都必须同时可发布，而可发布的深层含义既是对用户的承诺，也是对作者的约束。组件是否向后兼容？是否包含破坏性的变更？升级的注意事项？</p>
<p>CCP原则是指尽量把变更频率相同的模块和类放到同一个组件当中。这样做的好处是，当相关功能更新时，我们可以把源代码的变更局限在某一个组件当中，而不需要横跨多个组件，从而减少了部署，验证和发布的次数。概括来说，这是<strong>局部化影响</strong>的优势。CCP和OCP（开闭原则）中强调的“闭包”也有关联，所谓<strong>封装可变因素</strong>就是形成闭包的过程，CCP要求将同一时间变更的点聚合起来，达到闭包的效果。</p>
<p>CRP原则是说组件和组件之间的依赖应该达成一种默契——如果不需要完全使用某个组件中所有的模块和类，那么就不要依赖它。这看上去不太可能，但是有一点意义，它指导我们：不是紧密相连的模块和类不应该被放到同一个组件里。因为我们知道一旦某个组件变更升级之后，依赖它的组件往往也会被动的变更升级，即便是和自己那些无关的变更也是如此。而每次变更都意味着重新编译，部署验证和发布。</p>
<h4 id="合起看"><a href="#合起看" class="headerlink" title="合起看"></a>合起看</h4><p>REP原则说明软件复用是基础，复用是通过发布流程规范的。在复用和发布的上下文中，CCP原则为了便于后期维护，需要尽可能地将变更频率相同的模块和类放到相同的复用单元——组件中；CRP原则为了避免频繁发布，应该将每个组件分割的足够小，减少无关变更导致依赖链条的连锁发布反应。</p>
<p>如果我们只兼顾REP和CCP原则，那么就可能由于连锁发布反应，出现很多不必要的发布；如果只兼顾REP和CRP原则，那么就可能因为实现一个功能需要横跨多个组件修改，造成过多的组件变更；如果只兼顾CCP和CRP，那我们可能就忘记了复用这档子事儿，这在先前我们批判鲍勃大叔的时候已经体现出来了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>软件系统的生命周期里处处充斥着约束条件，每多一个环节往往就会多一种矛盾，进而衍生出多个方向的约束。组件聚合张力图反映的是发布和开发之间的矛盾，需要尽量遵循REP，CCP和CRP原则，满足其约束，才能减少变更成本。</p>
<p>组件构建过程中，除了聚合原则，还有耦合原则——描述的是组件的依赖关系。聚合原则告诉我们的是软件系统中的最小元素，耦合原则说的是元素之间的关系，当这两者和系统的功能结合到一起，就构成一个运行着的系统<a href="%5B%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BE%8E%5D(https://www.jianshu.com/p/da088142eef2)">^1</a>。系统是逐渐演化出来，即便我们熟知REP，CCP和CRP原则，也没有办法说，在系统构建之初，遵循这些原则就能画出完美的组件结构图。这便是“自顶而下”的设计不靠谱的基本解释。</p>
<p>“自顶而下”的设计不靠谱还有更深层次的原因。本书的第14章“组件耦合”会有答案，且听下回分解。</p>
<hr>
<p>[1] <a href="/2018/10/28/Guide-to-Clean-Architecture-1/">架构整洁之道导读（一）编程范式</a><br>[2] <a href="/2019/01/17/Guide-to-Clean-Architecture-2-more/">架构整洁之道导读（二）续 组件聚合张力图</a><br>于2018-10-28</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2018/10/28/Guide-to-Clean-Architecture-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/28/Guide-to-Clean-Architecture-1/" class="post-title-link" itemprop="url">架构整洁之道导读（一）编程范式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-28 15:36:54" itemprop="dateCreated datePublished" datetime="2018-10-28T15:36:54+08:00">2018-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-01-17 15:14:49" itemprop="dateModified" datetime="2019-01-17T15:14:49+08:00">2019-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我是《架构整洁之道》(<em>Clean Architecture</em>) 中文版的技术审校者，在审校的过程当中略有感悟，所以希望通过撰写导读的方式分享给大家。</p>
<h2 id="书名的由来"><a href="#书名的由来" class="headerlink" title="书名的由来"></a>书名的由来</h2><p>《架构整洁之道》是<em>Clean Architecture</em>的中文译名。看似简单地延续了《代码整洁之道》(<em>Clean Code</em>)的翻译传统，但事实上，对于取中文名字这件事，我们还是花了不少气力的。拿到译文初稿时，编辑提供了几个备选的译名：《架构简洁之道》，《架构至洁》和《Clean Architecture》，这些名字各有各的考量，在没有了解这本书的核心思想之前，我也没有办法给出恰当的判断。所以在通读了原作和译作之后，我在ThoughtWorks咨询群里发起提案，讨论的过程很精彩，最终在骨灰级架构师新哥的建议下，结果大致趋向了整洁架构。</p>
<p>新哥说：“整本书在说依赖治理（管理），也就是如果降低依赖复杂度，和DDD中分离子域分层架构等想法是一致的；如同你整理你的房间，把东西分门别类放好，从这个角度，整齐比简单更合适，或者清晰也可。”</p>
<p>除此之外，对于《架构至洁》这个候选项，大魔头的态度是不要至洁，总感觉脏脏的。言下之意，自行体会。而读MBA的岳岳和XR（XR说他没读过MBA）从用户思维出发，认为《代码整洁之道》和《架构整洁之道》可以相互增强记忆，更容易激发用户的购买行为。</p>
<p>即便敲定了“整洁架构”，大家对“之道”也有不同的看法。《代码整洁之道》对应的原标题和副标题分别是<em>Clean Code - A handbook of Agile Software Craftsmanship</em>，而《架构整洁之道》对应的原标题和副标题分别是<em>Clean Architecture - A Craftsman’s Guide to Software Structure and Design</em>。我们知道“道”是一种形而上的精神层面，老实讲，把<em>Craftsman</em>（手艺人）译做“道”是有点夸张的。</p>
<blockquote>
<p>形而上是精神方面的宏观范畴，用抽象（理性）思维，形而上者道理，起于学，行于理，止于道，故有形而上者谓之道；形而下是物质方面的微观范畴，用具体（感性）思维，形而下者器物，起于教，行于法，止于术，故有形而下者谓之器。</p>
</blockquote>
<p>道法术器择其一？其实凡事总有权衡，遵循前人的译法往往不会太坏。就像鲍勃大叔书中总结的稳定依赖原则，当我们依赖一种译法次数越多，它就更加稳定，这种稳定先不说能否形成品牌效应，单是SEO就能省去不少功夫，那么何乐而不为呢？</p>
<p>鲍勃大叔的文字平铺直叙、浅显易懂，尤其喜欢用他自己生活中的经验做例子。而且这本书是没有知识断层的，即便是初级程序员，也能在鲍勃大叔的循循善诱下，完成对软件架构认知的转变。因为他总是从最基础的知识点切入，自下而上，一步步地搭起架构的形状。</p>
<h2 id="范式的实质是约束"><a href="#范式的实质是约束" class="headerlink" title="范式的实质是约束"></a>范式的实质是约束</h2><p>编程范式是程序员喜闻乐见的话题，就像Vim和Emacs编辑器地位的旷日之争。它们的沉浮过往俨然就是风云诡谲的江湖。结构化编程英雄迟暮逐渐淡出程序员的视野，觊觎已久的面向对象编程（OOP）以迅雷之势称霸武林，独居一隅的函数式编程（FP）隐忍多年终于等来了一次机会。2012-2014年，江湖唱衰OOP的声音不绝于耳，FP就像一名拯救程序员于水火的侠士想要撼动这片天地。硝烟过后，眼前却不是你死我亡的惨状，而是你中有我、我中有你的大团圆结局。当Java这位OOP的保守党融汇了FP的特性lambda表达式，这场范式的冲突之争也算落下了帷幕。</p>
<p>程序员谈编程范式，喜欢党同伐异，作为FP的拥趸，我也不例外。可是鲍勃大叔却娓娓道来，所谓编程范式不过是约束程序的执行，告诉我们什么不能做而已。</p>
<ol>
<li>结构化编程是对程序控制权的直接转移的规范和限制</li>
<li>面向对象编程是对程序控制权的间接转移的规范和限制</li>
<li>函数式编程是对程序赋值操作的规范和限制</li>
</ol>
<h3 id="Goto-considered-harmful"><a href="#Goto-considered-harmful" class="headerlink" title="Goto considered harmful"></a>Goto considered harmful</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-187abed98d4896de.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GotoConsideredHarmful"></p>
<p>学习C语言编程的第一天，老师就告诉我们不要在程序中使用<code>goto</code>语句，因为<code>goto</code>会破坏程序的结构化。Dijkstra在论文<em>Go To Statement Considered Harmful</em>中证明了<code>goto</code>语句阻止了将大程序递归分解成更小的可证明的单元，这意味着大量使用<code>goto</code>语句的程序是不能被证明的。这里，不能被证明的语义是不可判定，类似说谎者悖论——“我在说谎”这句话不能被证明和证伪，所以不用<code>goto</code>其实是在保证小的程序单元可判定。可惜的是，Dijkstra并没有证明程序单元，这项工作被科学方法——测试取代了。在保证程序单元可判定的前提下，测试是一种可以对其可证伪的科学方法。命题“天下乌鸦一般黑”就是可以证伪的，我们不可能枚举天下所有的乌鸦，等到哪天找到了一只白乌鸦，我们就可以说这个命题是错误的，这就是证伪。Dijkstra说的“测试只能说明bug存在，而不能证明不存在。”是同样的道理。</p>
<p>测试可以保证，在当前已知情况下，程序单元是正确的。一旦有新的测试用例导致程序单元出错，那么我们就可以修正程序，让程序更加接近真相。这或许就是TDD（测试驱动开发）的妙处所在吧。</p>
<p>去除了<code>goto</code>语句之后，我们发现具备顺序，循环和分支判断能力的计算过程还是图灵完备的，也就是说<code>goto</code>的有无并不会影响计算能力。那么<code>goto</code>的在程序中的作用便是弊大于利的。再加上<code>goto</code>的滥用会导致程序结构容易混乱，不利于程序员理解，这更得尽力避免。所以结构化编程限制了对程序直接转移的控制权。</p>
<h3 id="Pointer-considered-harmful"><a href="#Pointer-considered-harmful" class="headerlink" title="Pointer considered harmful"></a>Pointer considered harmful</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-1b98c5fe49bd4ed4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PointerConsideredHarmful"></p>
<p>人人都知道面向对象编程有三大特征：封装，继承和多态。</p>
<p>封装是为了构造抽象屏障（Abstract Barrier），到达隐藏信息的目的。任何编程范式都不会缺少封装，因为这是人的需求，是人类简化问题认知的方式。</p>
<p>继承是一种函数（过程或者API）复用的方式，以前我们想在多个结构相似的数据上使用同样的函数，需要通过强制转换到函数可接收的数据类型（结构体指针）上，这必然存在风险。面向对象的世界里，我们不再需要手动强制转换，只要通过显式地表明继承关系，编程语言就能在运行时自动做到这点。</p>
<p>多态（polymorphism）是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29">一种将不同的特殊行为和单个泛化记号相关联的能力</a>，和多态概念对应的参考实现——运行哪段代码的决策叫做分派，大部分分派基于类型，也可以基于方法参数的个数及其类型，而分派的具体执行过程则仰仗函数指针。当作为单个泛化记号的函数被声明出来，它的具体实现可以多样化。通过这样的记号，事实上，我们解耦声明和实现，而这种解耦的过程恰恰是通过函数指针间接地找到目标函数完成的。所以面向对象编程限制了对程序间接转移的控制权。</p>
<h3 id="Mutability-considered-harmful"><a href="#Mutability-considered-harmful" class="headerlink" title="Mutability considered harmful"></a>Mutability considered harmful</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-a19539fe44c20bba.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MutabilityConsideredHarmful"></p>
<p>Neal Ford在《函数式编程思想》（<em>Functional Thinking</em>）中提到面向对象编程是通过封装可变因素控制复杂性（makes code understandable），而函数式编程是通过消除可变因素控制复杂性的。函数式的一个显著的特点就是不可变性。不可变性意味着更多的内存消耗，更差的性能？其实不尽然。像Scala，Clojure这些基于JVM上的函数式编程语言大量使用了持久化结构（如：Persistent Vector，见脚注1)，在不损失效率的前提下，实现了不可变的数据结构。这样的数据结构在高并发的环境下具有非常巨大的优势，尤其相对于面向对象编程中为人所诟病的临界区和竞态条件。</p>
<p>不可变的数据结构是无法重复赋值的，所以函数式编程限制了对程序的赋值操作。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>鲍勃大叔一针见血地指出，我们过去50年学到的东西主要是——<strong>什么不应该做</strong>。这等于给全书奠定了基调。可以类比，良好的架构也在传达同样的道理。</p>
<p>为什么从编程范式开始谈起？在审阅完整本书之后，我慢慢发现鲍勃大叔其实在传递一种设计理念：架构设计里，自顶向下的设计往往是不靠谱的。就像本书的目录，从程序的基础构件，谈到组件，最后谈到架构，这个过程非常符合系统自组织的特征。</p>
<p>为什么自顶向下的设计往往不靠谱？本书的第4部分“组件构建原则”会有答案，有需要，且听下回分解。</p>
<hr>
<p>[1] <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1aa9f717366c">函数式编程简介</a><br>于 2018-10-21</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-442a08009a47db30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="架构整洁之道"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2018/09/18/the-generic-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/18/the-generic-programming/" class="post-title-link" itemprop="url">泛型编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-09-18 16:31:58 / 修改时间：16:34:46" itemprop="dateCreated datePublished" datetime="2018-09-18T16:31:58+08:00">2018-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>泛型编程是一种编程风格，其中算法以尽可能抽象的方式编写，而不依赖于将在其上执行这些算法的数据形式。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-2bfc87e93ae5b6c6.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="泛型编程的提出者"></p>
<p>泛型这个词并不是通用的，在不同的语言实现中，具有不同的命名。在Java&#x2F;Kotlin&#x2F;C#中称为泛型（Generics），在ML&#x2F;Scala&#x2F;Haskell中称为Parametric Polymorphism，而在C++中被叫做模板（Template），比如最负盛名的C++中的STL。任何编程方法的发展一定是有其目的，泛型也不例外。泛型的主要目的是加强类型安全和减少强制转换的次数。</p>
<h2 id="Java中的泛型编程"><a href="#Java中的泛型编程" class="headerlink" title="Java中的泛型编程"></a>Java中的泛型编程</h2><p>在Java中有泛型类和泛型方法之分，这些都是表现形式的改变，实质还是将算法尽可能地抽象化，不依赖具体的类型。</p>
<blockquote>
<p>generics add a way to specify concrete types to general purposes classes and methods that operated on Object before</p>
</blockquote>
<p>通用的类和方法，具有代表性的就是集合类。在Java1.5之前，Java中的泛型都是通过单根继承的方式实现的。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList // before  Java SE 5.0</span><br><span class="line">&#123;</span><br><span class="line">    public Object get(int i)</span><br><span class="line">    public void add(Object o)</span><br><span class="line">    public boolean contains(Object o);</span><br><span class="line">    private Object[] elementData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然算法足够通用了，但是这样会带来两个问题。一个是类型不安全，还有一个是每次使用时都得强制转化。减少类型转换次数比较容易理解，在没有泛型（参数化类型）的时候，装进容器的数据，其类型信息丢失了，所以取出来的时候需要进行类型转换。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(1);</span><br><span class="line"></span><br><span class="line">assertThat(list.get(0), instanceOf(Integer.TYPE));</span><br><span class="line">assertThat((Integer)list.get(0), is(1)); //存在强制转换</span><br></pre></td></tr></table></figure>
<p>因为这个类里只有Object的声明，所以任意类型的对象都可以加入到这个集合当中，在使用过程中就会存在强制到具体的类型失败的问题，这将丧失编译器检查的好处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(&quot;any type&quot;);</span><br><span class="line"></span><br><span class="line">assertThat(list.get(1), instanceOf(String.class));</span><br><span class="line">assertThat((Integer) list.get(1), is(1));//-&gt; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer</span><br></pre></td></tr></table></figure>
<p>2005 Java SE 5引入了泛型，不仅有效地提高了算法的通用程度，同时也保留强类型语言在编译期检查的好处。</p>
<blockquote>
<p>Generics This long-awaited enhancement to the type system allows a type or method to operate on objects of various types while providing compile-time type safety. It adds compile-time type safety to the Collections Framework and eliminates the drudgery of casting.</p>
</blockquote>
<p>所以上述的程序会写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(1);</span><br><span class="line">// list.add(&quot;no way&quot;); 编译出错</span><br><span class="line">assertThat(list.get(0), instanceOf(Integer.TYPE));</span><br><span class="line">assertThat(list.get(0), is(1)); // 不需要强制转换</span><br></pre></td></tr></table></figure>
<h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>在静态强类型语言中，编译期间的检查非常重要，因为它可以有效地避免低级错误。这些低级错误就是类型安全解决的问题。类型安全包含了赋值安全和调用安全。其底层实质上就是在某块内存中，始终存在被同种类型的指针指向。</p>
<ol>
<li>类型赋值检查<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long l_num = 1L;</span><br><span class="line">int i_num = l_num; // 编译错误</span><br></pre></td></tr></table></figure>
在强类型的语言当中，类型不一致是无法互相赋值的。</li>
</ol>
<p>2. 类型调用检查<br> Clojure就是一门强类型语言，而且还是一门函数式语言，所以重新赋值不被允许，它的类型安全表现在针对类型的调用安全。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; (+ &quot;&quot; 1)</span><br><span class="line">...</span><br><span class="line">java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number</span><br></pre></td></tr></table></figure>
<p>这里存在一个隐式类型转化的过程，但是由于String无法转化成Number，所以方法调用失败。由于Clojure是动态语言，所以只有在运行时才会抛出错误。</p>
<p>另一个简单的例子，如果一个类型不存在某个方法，那就没法去调用它。在动态强类型语言中，运行时一定会报错。其实质是类型是内存堆上的一块区域，如果该区域之上没有想要调用的方法，那么调用在编译期或者运行期间一定会出错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Object().sayNothing() // 编译出错</span><br></pre></td></tr></table></figure>
<p>为什么说类型安全对于开发人员友好，这个特性对于编程语言很重要？其实这可以追溯到三次编程范式解决的根本问题上。Clean Architecture（架构整洁之道）一书中，对结构化，面向对象和函数式编程语言做了很透彻的分析。</p>
<p>首先我们得明确一点，这些范式从来没有扩展编程语言的能力，而是在不同方面对编程语言的能力进行了约束。</p>
<ol>
<li>结构化编程<br>对程序的直接控制进行约束和规范，goto considered harmful.</li>
<li>面向对象编程<br>对程序的间接控制进行约束和规范，pointer considered harmful.</li>
<li>函数式编程<br>对程序的赋值进行约束和规范，mutability considered harmful.</li>
</ol>
<p>按照这样的思路，泛型编程无非是对既有的范式做了进一步的约束。泛型编程旨在对程序的间接控制进一步进行约束和规范。它把类型安全放在第一位，而将类型转化限制在编译期间。</p>
<p>我们甚至可以遵循前面的定义方式，说：<br>2.1 泛型编程<br>对程序的间接控制<strong>进一步</strong>进行约束和规范，type casting considered harmful.</p>
<h2 id="Kotlin中的泛型编程"><a href="#Kotlin中的泛型编程" class="headerlink" title="Kotlin中的泛型编程"></a>Kotlin中的泛型编程</h2><p><img src="https://upload-images.jianshu.io/upload_images/217988-6d226cf160f832ba.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="variance - 变化"><br>和Java泛型中的泛型方法和泛型类概念类似，Kotlin将对应的概念称为参数化函数和参数化类型。</p>
<h3 id="parameterized-function-参数化函数"><a href="#parameterized-function-参数化函数" class="headerlink" title="parameterized function 参数化函数"></a>parameterized function 参数化函数</h3><p>假设我们要返回三个对象中任一一个对象，同时保证类型一致。参数化函数是很恰当的选择。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; random(one: T, two: T, three: T): T</span><br></pre></td></tr></table></figure>
<h3 id="parameterized-type-参数化类型"><a href="#parameterized-type-参数化类型" class="headerlink" title="parameterized type 参数化类型"></a>parameterized type 参数化类型</h3><p>除了参数化函数，类型本身也可以定义自己的参数化类型。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Dictionary&lt;K, V&gt;</span><br></pre></td></tr></table></figure>
<h3 id="bounded-polymorphism-限定参数化类型"><a href="#bounded-polymorphism-限定参数化类型" class="headerlink" title="bounded polymorphism 限定参数化类型"></a>bounded polymorphism 限定参数化类型</h3><p>大部分情况下，参数化类型不会是无限抽象的，无限抽象往往不利于语言的表达性。所以限定的参数化类型应运而生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T : Comparable&lt;T&gt;&gt; min(first: T, second: T): T &#123;</span><br><span class="line">    val k = first.compareTo(second)</span><br><span class="line">    return if (k &lt;= 0) first else second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要用多个边界来限定类型，则需要用到<code>where</code>语句，表达<code>T</code>被多个边界类或者接口限制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class MultipleBoundedClass&lt;T&gt; where T : Comparable&lt;T&gt;, T : Serializable</span><br></pre></td></tr></table></figure>
<h3 id="invariance-不变"><a href="#invariance-不变" class="headerlink" title="invariance 不变"></a>invariance 不变</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-df2dfb855f6f9755.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invariance 不变"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">open class Animal</span><br><span class="line">class Dog : Animal()</span><br><span class="line">class Cat : Animal()</span><br><span class="line">class Box&lt;T&gt;(val elements: MutableList&lt;T&gt;) &#123;</span><br><span class="line">    fun add(t: T) = elements.add(t)</span><br><span class="line">    fun last(): T = elements.last()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun foo(box: Box&lt;Animal&gt;)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val box = Box(mutableListOf(Dog()))</span><br><span class="line">// -&gt; val box: Box&lt;Dog&gt; = Box(mutableListOf(Dog()))</span><br><span class="line">box.add(Dog()) // ok</span><br><span class="line">box.add(Cat()) // 编译错误</span><br></pre></td></tr></table></figure>
<p>这里出现的编译错误，原因是box的真实类型是<code>Box&lt;Dog&gt;</code>，所以尝试向<code>Box&lt;Dog&gt;</code>中添加<code>Cat</code>对象是不会成功的。这样总能保证类型安全。</p>
<p><code>Dog</code>是<code>Animal</code>的子类型，那么编译器是否承认<code>Box&lt;Dog&gt;</code>是<code>Box&lt;Animal&gt;</code>的子类型，在使用时进行隐式转换呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val box: Box&lt;Animal&gt; = Box(mutableListOf(Dog())) // type inference failed. Expected type mismatch.</span><br></pre></td></tr></table></figure>
<p>编译器是不会允许这样行为发生。原因就是这样做会导致类型不安全。<br>我们试想一下，假如这种转换是允许的，那么我们就可以继续添加其它继承了<code>Animal</code>的子类对象，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val box: Box&lt;Animal&gt; = Box(mutableListOf(Dog())</span><br><span class="line">box.add(Cat())</span><br></pre></td></tr></table></figure>
<p>这样就导致<code>Box&lt;Animal&gt;</code>里面同时保存了<code>Dog</code>和<code>Cat</code>的对象，正如前面提到的，在运行时，调用可能就会抛出<code>ClassCastException</code>，所以这是非类型安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val box = Box(mutableListOf(Dog()))</span><br><span class="line">// val box: Box&lt;Dog&gt; = Box(mutableListOf(Dog()))</span><br><span class="line">val animalBox: Box&lt;Animal&gt; = box // 编译错误</span><br></pre></td></tr></table></figure>

<h3 id="covariance-协变"><a href="#covariance-协变" class="headerlink" title="covariance 协变"></a>covariance 协变</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-87c0b29318f7589d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="covariance 协变"></p>
<p>但是这种限制太过于严苛了，如果我们只需要从这个box读取元素，而不需要往里面添加，那么这种转换就是类型安全的。具体原因稍后再说。</p>
<p>当<code>Dog</code>是<code>Animal</code>的子类型，那么<code>Box&lt;Dog&gt;</code>也是<code>Box&lt;Animal&gt;</code>的子类型，这种继承关系就是协变。在Kotlin中，我们需要使用<code>out</code>关键字表示这种关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class CovarianceBox&lt;out T : Animal&gt;(val elements: MutableList&lt;out T&gt;) &#123;</span><br><span class="line">    fun add(t: T) = elements.add(t) //编译错误</span><br><span class="line">    fun last(): T = elements.last()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于这种协变关系，我们可以这样调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val dogs: CovarianceBox&lt;Dog&gt; = CovarianceBox(mutableListOf(Dog(), Dog()))</span><br><span class="line">val animals: CovarianceBox&lt;Animal&gt; = dogs</span><br><span class="line">print(animals.last())</span><br></pre></td></tr></table></figure>
<p>我们注意上面的<code>CovarianceBox</code>的<code>add</code>方法出现了编译错误，原因就是在协变关系中，泛型参数只能作为输出参数，而不能作为输入参数。因为在拒绝了输入泛型参数的前提下，协变发生的时候，才不会出现强制转化的错误。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val dogs: CovarianceBox&lt;Dog&gt; = CovarianceBox(mutableListOf(Dog(), Dog()))</span><br><span class="line">val animals: CovarianceBox&lt;Animal&gt; = dogs</span><br><span class="line">dogs.add(Cat()) // add在这里禁止了</span><br></pre></td></tr></table></figure>
<p>如果<code>CovarianceBox</code>允许<code>add</code>方法，那么box里面就会同时存在多个子类型的实例，这样就会导致类型不安全，所以<code>out</code>修饰的参数化类型，只能在函数的返回值上出现。</p>
<p>不过，这种解决方式也不是万能的，属于杀敌一千，自损八百的战术。因为对于<code>Collection</code>而言，不可能做到任何泛型参数都不会出现在入参的位置上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; &#123;</span><br><span class="line">    public operator fun contains(element: @UnsafeVariance E): Boolean</span><br><span class="line">    public fun containsAll(elements: Collection&lt;@UnsafeVariance E&gt;): Boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，针对这种情况，我们知道某些方法其实并不会有添加的操作，可以在入参的位置上加上<code>@UnsafeVariance</code>，以此消除掉编译器的错误。</p>
<h3 id="contravariance-逆变"><a href="#contravariance-逆变" class="headerlink" title="contravariance 逆变"></a>contravariance 逆变</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-837beeffe65375fc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="contravariance 逆变"></p>
<p>当<code>Dog</code>是<code>Animal</code>的子类型，那么<code>Box&lt;Animal&gt;</code>也是<code>Box&lt;Dog&gt;</code>的子类型，这种继承关系就是逆变。在Kotlin中，我们需要使用<code>in</code>关键字表示这种关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ContravarianceBox&lt;in T&gt;(val elements: MutableList&lt;in T&gt;) &#123;</span><br><span class="line">    fun add(t: T) = elements.add(t)</span><br><span class="line">    fun first(): T = elements.first() // 编译错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于这种逆变关系，我们可以这样调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val animals = ContravarianceBox(mutableListOf(Animal()))</span><br><span class="line">val dogs: ContravarianceBox&lt;Dog&gt; = animals</span><br><span class="line">dogs.add(Dog())</span><br></pre></td></tr></table></figure>
<p>这个时候，类型始终是安全的。但是我们也注意到<code>ContravarianceBox</code>的<code>first</code>方法出现了编译错误，原因就是在逆变关系中，泛型参数只能作为输入参数，而不能作为输出参数。在拒绝了输出参数的前提下，逆变发生的时候，才不会出现强制转换的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val animals = ContravarianceBox(mutableListOf(Animal()))</span><br><span class="line">val dogs: ContravarianceBox&lt;Dog&gt; = animals</span><br><span class="line">dogs.add(Dog())</span><br><span class="line">val dog: Dog = dogs.first() // 编译错误</span><br></pre></td></tr></table></figure>

<h3 id="reification-变现"><a href="#reification-变现" class="headerlink" title="reification 变现"></a>reification 变现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reify is To convert mentally into a thing; to materialize.</span><br></pre></td></tr></table></figure>
<p>Kotlin中的Reification的实现使用的是inline模式，就是在编译期间将类型进行原地替换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 定义</span><br><span class="line">inline fun &lt;reified T : Any&gt; loggerFor(): Logger = LoggerFactory.getLogger(T::class.java)</span><br><span class="line">// 使用</span><br><span class="line">private val logger = loggerFor&lt;AgreementFactory&gt;()</span><br></pre></td></tr></table></figure>
<p>因此，所以原来调用处的代码会在编译期间展开成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private val logger = LoggerFactory.getLogger(AgreementFactory::class.java)</span><br></pre></td></tr></table></figure>
<p>使用<code>reification</code>操作，可以精简掉很多模板代码。</p>
<h3 id="type-projection-类型投影"><a href="#type-projection-类型投影" class="headerlink" title="type projection 类型投影"></a>type projection 类型投影</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-ee46241507e001e0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="type projection 类型投影"></p>
<p>上述过程中，我们看到协变和逆变都是针对可以编辑的类。但是如果遇到已经存在的类，这件事就得运用类型投影技术。拿<code>Class</code>这个类举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val dog = Dog::class.java</span><br><span class="line">val animal: Class&lt;Animal&gt; = dog //编译不通过</span><br></pre></td></tr></table></figure>
<p>Kotlin中的type projection就是为了解决这个问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val dog = Dog::class.java</span><br><span class="line">val animal: Class&lt;out Animal&gt; = dog</span><br></pre></td></tr></table></figure>
<p>同理，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val animal = Animal::class.java</span><br><span class="line">val dog: Class&lt;in Dog&gt; = animal</span><br></pre></td></tr></table></figure>
<p>我们来看一个真实的场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val agreementClass: Class&lt;RentalAgreement&gt; = RentalAgreement::class.java</span><br><span class="line"></span><br><span class="line">private val virtualTable = mapOf(RentalPayload.type to RentalAgreement::class.java)</span><br><span class="line">private fun dispatch(type: String): Class&lt;out Agreement&lt;Payload&gt;&gt; &#123;</span><br><span class="line">    return virtualTable[type]</span><br><span class="line">            ?: throw RuntimeException(&quot;No suitable Agreement of this type found, please check your type: $type&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有这样，我们才能将具体的<code>Class&lt;RentalAgreement&gt;</code>投射到<code>Class&lt;out Agreement&lt;Payload&gt;&gt;</code>父类型之上，后续通过某种方式，实例化出<code>RentalAgreement</code>的实例，其继承自<code>Agreement&lt;Payload&gt;</code>。</p>
<h2 id="泛型编程的思考"><a href="#泛型编程的思考" class="headerlink" title="泛型编程的思考"></a>泛型编程的思考</h2><p><img src="https://upload-images.jianshu.io/upload_images/217988-2ae56647d7c62079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="过程式代码 vs. 面向对象"><br>Bob 大叔的 Clean Code 一书的第六章《对象和数据结构》中提到了一个很有意思的现象：数据、对象的反对称性。在这里，数据结构暴露数据，没有提供有意义的函数；对象把数据隐藏起来，暴露操作数据的函数。</p>
<p>过程式代码会基于数据结构进行操作。例如：首先会定义好数据结构<code>Square</code>, <code>Circle</code>和<code>Triangle</code>，然后统一在<code>area(shape: Any)</code>的函数中求shape数据的面积，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun area(shape: Any): Double &#123;</span><br><span class="line">    return when(shape) &#123;</span><br><span class="line">      is Square -&gt; return shape.side * shape.side</span><br><span class="line">      else -&gt; 0.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而面向对象拥趸一定会嗤之以鼻——显然应该抽象出一个shape类包含<code>area</code>方法，让其它的形状类继承。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    fun area(): Double</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Square(val side: Double) : Shape &#123;</span><br><span class="line">    override fun area(): Double &#123;</span><br><span class="line">        return side * side</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在添加新的形状的要求下，面向对象的代码是优于过程式的，因为面向对象对类型的扩展开放了。而过程式代码却不得不修改原来<code>area</code>方法的实现。</p>
<p>但是，如果此时需要添加一个求周长<code>primeter</code>的函数。相对于面向对象代码，过程式代码由于无需修改原来的实现，反而更加容易扩展。反观面向对象的代码，在接口<code>Shape</code>中添加一个<code>primeter</code>会导致所有的子类都得发生修改。</p>
<p>这就是数据和类型的反对称性。在变化方向不同的时候，它们面临的阻力也是不一样的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-cd7abfea6d757a50.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="隔离阻抗"><br>我们既想要过程式对方法扩展的优点，又执着面向对象自然的类型扩展的好处，该怎么办呢？可以考虑结合起来使用。</p>
<p>这样的结合不是说原有的双向阻力消失了，而是在不同的层次上应用各自的优点。也就是说，<code>Shape</code>需要求面积、周长，同时也要支持类型扩展，这种要求之下，基本不可能调解出一种符合开闭原则的方案。不过，如果对于所有<code>Shape</code>类，都需要统一进行某些操作，例如：集合的排序，过滤等等。那么合并两者的好处就变得可行了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-1baedd1173c5c2ad.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="泛型补充"><br>基于最先分析的通过继承的方式进行泛型编程的缺点：</p>
<ol>
<li>太多强制转换</li>
<li>非类型安全。<br>恰当地引入了泛型<code>T</code>，以期编译期的占位和运行时的替换。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-2a674d8478f7884d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="泛型限定"><br>不过没有限定的泛型大部分情况下是没有用处的，因为无限的抽象没有意义，所以需要更加精准的泛型限定。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-9bc98f8e10201115.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依赖倒置"><br>在我们做完这一切以后，会惊喜地发现依赖倒置（DIP）原则贯穿始终。不论是继承体系，还是改善之后的泛型继承体系。它们秉持的原则就是在编译期，始终朝着稳定、抽象的方向移动，而且不断在易变、具体的方向延迟决策，直到运行时方能确定。</p>
<h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><p><img src="https://upload-images.jianshu.io/upload_images/217988-613c079cce8d4fa5.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="书籍推荐"></p>
<h2 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h2><p><img src="https://upload-images.jianshu.io/upload_images/217988-8f2ce836e7ea45a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="知识梳理"></p>
<hr>
<p>参考链接<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/64b2d11decbc">泛型 一个会写诗的程序员</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2018/07/18/the-joy-of-learning-new-programming-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/18/the-joy-of-learning-new-programming-language/" class="post-title-link" itemprop="url">我是怎样学习新编程语言的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-18 13:09:26" itemprop="dateCreated datePublished" datetime="2018-07-18T13:09:26+08:00">2018-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-14 08:30:26" itemprop="dateModified" datetime="2024-06-14T08:30:26+08:00">2024-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/images/Elixir.webp" alt="Elixir"></p>
<h2 id="说服自己"><a href="#说服自己" class="headerlink" title="说服自己"></a>说服自己</h2><p>学习新的编程语言的最终目的是解决实际问题。掌握编程语言的过程，在某种程度上近似学习一种新的工程实践。不仅解决问题固然可乐，学习的过程也同样充满了新鲜感，不过需要谨防的是新鲜感带来的胜任力错觉。</p>
<p>胜任力错觉指的是反复接触新东西，发现不用花费什么气力就理解了其中所有的内容。说的简单点，就是自以为是。这种胜任力错觉导致最常见的后果是以为掌握了某种技能，真正开始解决问题时，要么是半天摸不着头绪，要么就是处处掣肘。所以我始终相信，阅读是一码事，理解是一码事，掌握还是另一码事，所谓一码归一码，大抵就是这么回事。</p>
<p><del>以终为始，方得始终。老子（真·老子，非我）也说，慎终如始，则无败事。这里的“终”就是目标，在软件工程中，有一种实践很好得反映了这种做事方式——测试驱动开发。借我司的一位牛人的原话：看一个人会不会测试驱动开发，不是看他的测试写得好不好，而是要看他是不是始终从测试出发去解决问题。脑子里条件反射的就是测试该怎么测？这种才是测试驱动开发的实质。</del></p>
<p>学习，说白了就是一个不会到会的过程，这里头最难的是学会了什么？在学习方法上，我们很多时候喜欢遵循前人的套路，美其名曰知识体系化。我承认体系是前人经验和群体智慧的积累，但是学习体系不代表你具备形成体系的能力，就像你学习了著名开发框架（Spring or Rails）也不会说你能开发这套框架一样。学习的关键还是发散、收敛和再发散、再收敛的渐进过程，感性的定性分析到理性的定量分析，在不断丰富和修正认知，处处用实践检验认知。这种过程坚持下来，得到就不单单是知识，可能是元知识（方法论）或者智慧。</p>
<p>看书抄代码是个学习的好方法，不过书中的例子一般都被加工（简化）过，我们很容易陷入套路中，谨记胜任力陷阱。比较推荐的方式，自己认准一段有用的程序，反复练习（也可以每次增加些体系化的功能）直到娴熟。在接触新语言时，不去看一套完整的语言体系，而是事先把这段程序可能用到的基本类型、数据结构、流程控制结构、模块化和功能组件列出来，然后去找它们在这门语言中对应的实现。</p>
<h2 id="有目的地试错"><a href="#有目的地试错" class="headerlink" title="有目的地试错"></a>有目的地试错</h2><p>我常用的练手程序叫<code>tree</code>，功能是<em>list contents of directories in a tree-like format.</em> 这个程序需要用到的基本构件有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">基本类型（basic type)</span><br><span class="line">1. str</span><br><span class="line"> </span><br><span class="line">数据结构（data structure）</span><br><span class="line">1. list</span><br><span class="line">2. map</span><br><span class="line"></span><br><span class="line">流程控制结构（control flow structure）</span><br><span class="line">1. if, else</span><br><span class="line">2. recursion</span><br><span class="line"></span><br><span class="line">模块化（modulize）</span><br><span class="line">1. function</span><br><span class="line">2. module/namspace/package</span><br><span class="line"></span><br><span class="line">功能组件（function components）</span><br><span class="line">1. IO</span><br><span class="line">2. File</span><br><span class="line">3. Path</span><br></pre></td></tr></table></figure>

<p>分类清晰之后，对应找起来很方便，有的基本不用找，经验足矣。现在的编程语言基本都有<em>repl</em>，多尝试几遍就有了感性认识。我说的很轻松，但是如果不去尝试，一样会难住。Elixir中有<code>iex</code>命令作为<em>repl</em>，而且这门语言深受Clojure的影响，尤其是文档和例子方面很充足，对于初学者再友好不过。</p>
<h3 id="换种思维"><a href="#换种思维" class="headerlink" title="换种思维"></a>换种思维</h3><p>在编写<code>tree</code>的过程中，我会时不时停下来思考Elixir在某个功能点上应该怎么用才好？因为历史上，把Java的代码写成C风格的人不在少数，这足以让人警惕。再说，学会用新语言的思维方式编程是我初始的目的之一。</p>
<p>这里举个例子，map的key使用哪种基本类型会比较合适？Clojure中有keyword，如<code>&#123;:name &quot;clojure&quot;&#125;</code>，而Python中并没有这样的数据类型，我只好使用<code>&#123;&#39;name&#39;: &quot;python&quot;&#125;</code>，那么Elixir呢？它推荐的是atom&#x2F;symbol，<code>%&#123;:name =&gt; &quot;elixir&quot;&#125; #or %&#123;name: &quot;elixir&quot;&#125;</code></p>
<p>遇到需要join path的时候，凭借原来的经验，我会去寻找<code>Path</code>模块。具体可以去问谷歌，也可以问<em>repl</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iex&lt;1&gt; h Path.join</span><br><span class="line">or</span><br><span class="line">iex&lt;1&gt; Path.join &lt;TAB&gt; #用tab键</span><br><span class="line">join/1    join/2</span><br></pre></td></tr></table></figure>
<p>看到<code>join/1 join/2</code>的时候，我有些许迷茫，但是很快就变成了欣喜。我们知道，在动态类型语言中，arity指的是方法参数的个数，这里的<code>1和2</code>其实表明的就是join有两个重载的方法，分别接受一个参数和两个参数。更进一步，arity是方法（函数）实现静态多态的依据之一。再进一步，多态是函数的特性，而非OO中固化下来的概念——类的特性。</p>
<h3 id="组织代码"><a href="#组织代码" class="headerlink" title="组织代码"></a>组织代码</h3><p>上面的验证只需要<em>repl</em>就足够了。但是，真正编写还是得有组织和结构。软件工程中，控制复杂度（复杂度从来不会被消除）的基本法则就是模块化。这就引出了module和function，还有对模块可见性（private, public etc.）的修饰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defmodule Tree do</span><br><span class="line">  defp tree_format(parent_dir, dir_name) do</span><br><span class="line">    %&#123;:name =&gt; dir_name, :children =&gt; []&#125;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><code>defp</code>定义了一个私有的方法<code>tree_format</code>，它是用来格式化目录的。目录结构是树形结构，所以很容易递归实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defp children(path) do</span><br><span class="line">  if (path |&gt; File.dir?) do</span><br><span class="line">    File.ls!(path) |&gt; Enum.map(fn f -&gt; tree_format(path, f) end)</span><br><span class="line">  else</span><br><span class="line">    []</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">defp tree_format(parent_dir \\ &quot;.&quot;, dir_name) do</span><br><span class="line">  %&#123;:name =&gt; dir_name, :children =&gt; Path.join(parent_dir, dir_name) |&gt; children&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>在利用递归的过程中，我使用<code>File.ls!</code>（查文档，注意!号）列出子目录，然后递归地格式化。这些都比较好理解，不过这里其实出现了两个新的玩意（当然也不是一蹴而就的，认识之后才重构成这样）。一个是<code>\\ &quot;.&quot;</code>，还有一个是<code>|&gt;</code>。第一个比较容易猜，叫做默认参数（default arguments）；第二个有Clojure基础的也手到擒来，叫做管道操作符（pipe operator），用来将左边表达式的结果传入右边方法的首个参数。这里就是<code>children(path)</code>的<code>path</code>.</p>
<h3 id="结构，解构"><a href="#结构，解构" class="headerlink" title="结构，解构"></a>结构，解构</h3><p>完成目录结构的格式化，接下来需要做的是渲染这组树状的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defp decorate(is_last?, [parent | children]) do</span><br><span class="line">  prefix_first = (if (is_last?), do: &quot;└── &quot;, else: &quot;├── &quot;)</span><br><span class="line">  prefix_rest = (if (is_last?), do: &quot;    &quot;, else: &quot;│   &quot;)</span><br><span class="line">  [prefix_first &lt;&gt; parent | children |&gt; Enum.map(fn child -&gt; prefix_rest &lt;&gt; child end)]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">defp render_tree(%&#123;name: dir_name, children: children&#125;) do</span><br><span class="line">  [dir_name </span><br><span class="line">   | children </span><br><span class="line">   |&gt; Enum.with_index(1)</span><br><span class="line">   |&gt; Enum.map(fn &#123;child, index&#125; -&gt; decorate(length(children) == index, render_tree(child)) end) </span><br><span class="line">   |&gt; Enum.flat_map(fn x -&gt; x end)]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>到这里，我学到的是参数解构（arguments destructing），<code>map-indexed</code>的新实现，字符串的拼接（string concatenation）还有列表元素的前置操作。</p>
<p>Elixir和所有函数式编程语言一样，具备强大的模式匹配（Pattern matching）的功能，参数解构其实就是其中的一个应用场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%&#123;name: dir_name, children: children&#125;</span><br><span class="line">matching</span><br><span class="line">%&#123;:name =&gt; &quot;.&quot;, :children =&gt; [&quot;tree.exs&quot;]&#125;</span><br><span class="line"># -&gt;</span><br><span class="line">dir_name == &quot;.&quot;</span><br><span class="line">children == [&quot;tree.exs&quot;]</span><br></pre></td></tr></table></figure>

<p>渲染的过程也是递归的。最终返回的是一个加上分支标识前缀的列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[dir_name | children]</span><br></pre></td></tr></table></figure>
<p>这是一种将<code>dir_name</code>前置到<code>children</code>列表头部，形成新列表的做法。和Clojure（绝大数Lisp）中的<code>(cons dir_name children)</code>类似。</p>
<p>操作符<code>|</code>除了可以前置列表元素，递归解构也是一把好手。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defp decorate(is_last?, [parent | children]) do</span><br><span class="line">  ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>参数列表中的<code>[parent | children]</code>，解构出了列表的head和rest，这对于递归简直就是福音。</p>
<p>在添加前缀的步骤<code>[prefix_first &lt;&gt; parent...]</code>中，经验里字符串的拼接常用符号<code>+</code>不起作用了，换成了<code>&lt;&gt;</code>，这个是靠试错得出来的。</p>
<p>除了说到的这部分内容，我还运用了<code>Enum.map, Enum.with_index, Enum.flat_map</code>等函数式语言的标配。这些零散的知识点，可以添加到基本构件中，以便持续改进。</p>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>程序要执行，就需要一个入口。每次我都会猜猜<code>argv</code>会在哪里出现呢？是<code>sys</code>(Python)，<code>os</code>(Go)，还是<code>process</code>(Node.js)，这回又猜错了，Elixir管这个叫做<code>System</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  def main([dir | _]) do</span><br><span class="line">    dir |&gt; tree_format |&gt; render_tree |&gt; Enum.join(&quot;\n&quot;) |&gt; IO.puts</span><br><span class="line">  end</span><br><span class="line"># ---</span><br><span class="line">Tree.main(System.argv)</span><br><span class="line"># ---</span><br><span class="line">$ elixir tree.exs .</span><br></pre></td></tr></table></figure>

<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>这里重构的目的是让程序更加贴近Elixir的表达习惯，那么哪里不是很符合Elixir风格呢？我注意到了<code>if...else</code>，可以考虑模式匹配实现多态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">defp children(path) do</span><br><span class="line">  if (path |&gt; File.dir?) do</span><br><span class="line">    File.ls!(path) |&gt; Enum.map(fn f -&gt; tree_format(path, f) end)</span><br><span class="line">  else</span><br><span class="line">    []</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><code>File.ls!</code>中的<code>!</code>表示如果指定目录有问题，函数会抛出error或者异常。然而，Elixir还给出了一个<code>File.ls</code>方法，即便出错，也不会有抛出的动作，而是返回<code>&#123;:error, ...&#125;</code>的元组，至于正常结果，则是<code>&#123;:ok, ...&#125;</code>. 这恰恰可以使用模式匹配做动态分派了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defp children(parent) do</span><br><span class="line">  children(parent |&gt; File.ls, parent)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">defp children(&#123;:error, _&#125;, parent) do</span><br><span class="line">  []</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">defp children(&#123;:ok, sub_dir&#125;, parent) do</span><br><span class="line">    sub_dir |&gt; Enum.map(fn child -&gt; tree_format(parent, child) end)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>一旦<code> children(parent |&gt; File.ls, parent)</code>中的<code>parent</code>不是目录，<code>File.ls</code>返回的就会是<code>&#123;:error, ...&#125;</code>元组，它会被分派到对应的方法上，这里直接返回一个空的列表。反之，我们就可以拿到解构之后的子目录<code>sub_dir</code>进行交互递归，实现全部子目录的格式化。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在学习Elixir的过程中我收获了很多乐趣，不过，这离掌握Elixir还有很远的距离。我曾经看过一部科幻电影“降临”，剧情受到了萨丕尔-沃夫假说（语言相对性原理）的影响，这个假说提到：人类的思考模式受到其使用语言的影响，因而对同一事物时可能会有不同的看法。既然如此，那么自然语言也好，编程语言也罢，如果能换种思维方式解决同一种问题，说不定能收获些奇奇怪怪的东西，编程之路，道阻且长，开心就好。 – 2018-06-08</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c65cbbbd2826">如何高效地学习编程语言</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0bc3f56500ef">怎样才算学会Python</a><br><a target="_blank" rel="noopener" href="https://elixir-lang.org/">Elixir</a><br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%96%A9%E4%B8%95%E7%88%BE-%E6%B2%83%E5%A4%AB%E5%81%87%E8%AA%AA">萨丕尔-沃夫假说</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2018/07/18/the-way-to-python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/18/the-way-to-python/" class="post-title-link" itemprop="url">怎样才算学会Python</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-07-18 13:03:10 / 修改时间：13:06:27" itemprop="dateCreated datePublished" datetime="2018-07-18T13:03:10+08:00">2018-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://upload-images.jianshu.io/upload_images/217988-4e2f808562ea3f78.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Python inside the door"></p>
<h1 id="Python-实践基础"><a href="#Python-实践基础" class="headerlink" title="Python 实践基础"></a>Python 实践基础</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>假如你已经有了编程基础，那么学习一门新语言的困难点绝对不在语法、语义和风格等代码层面上的，而在于语言范式（OO，FP还是Logic），语言的生态（如：依赖管理和包发布等）和工具（编辑器，编译器或者解释器）这些方面，请参看<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c65cbbbd2826">如何高效地学习编程语言</a>。再假如你已经对各类语言范式都有一定的了解，那么最后的困难之处就是…细节，它是魔鬼。</p>
<p>我相信真正拥抱一门新语言，花在工具和语言生态上的时间一定很多。庞大的社区利用群体智慧构筑的生态圈充满了各种零碎的知识点，这些知识点可能是前人趟过的陷阱（Common Gotchas），基于局部共识经由经典项目实践过之后的约定（Convention）和惯用法（Idioms），也可能是总结出的概念模式（Pattern），甚至是审美（Aesthetic）和禅（Zen）或道（Dao）。这些知识点作用到了工具和语言生态之中，意味着你需要使用合适工具、遵循生态的玩法才能从中受益。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>工欲善其事必先利其器，对于程序员而言，这个器是编辑器…吗？Emacs, Vim, VS Code or PyCharm?</p>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>当然不是，这个器应当是让你能立马运行程序并立刻看到结果的工具，在Python的上下文中，它是Python的解释器。一般情况下，我们会选择最新版的解释器或者编译器，但是Python有一点点例外，因为Python3和2并不兼容，那么该选择哪个版本呢？寻找这类问题的答案其实就是融入Python社区的过程。幸运的是，社区出版了一本书 *<a target="_blank" rel="noopener" href="http://docs.python-guide.org/en/latest/">The Hitchhiker’s Guide to Python</a>*，里面诚恳地给出了建议。所以不出意外，Python3是比较合适的选择。</p>
<p>因为Python安装起来很简单，我们跳过…吧？不过，大侠留步，你可知道Python其实只是一个语言标准，它的实现程序不止一个，其中官方的实现是CPython，还有Jython和IronPython等。不过，CPython作为使用最为广泛的解释器当然是开发之首选。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python 3.6.5 (default, Jun 17 2018, 12:13:06)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 9.1.0 (clang-902.0.39.2)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; print(&quot;hello world&quot;)</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>虽然面向REPL编程（Repl-Oriented Programming）是一种比单元测试的反馈速度更快的编程方式，但是在REPL中编写应用程序并不合适，不合适的地方表现在代码不易组织（分模块）和代码没法记录（存盘）。所以我们需要可以编辑的源代码、目录和其它相关文件，这个时候就需要挑选趁手的编辑器。</p>
<p>神之编辑器Emacs中内置了<a target="_blank" rel="noopener" href="https://www.emacswiki.org/emacs/PythonProgrammingInEmacs">python-mode</a>，如果已经是Emacs用户，这款编辑器当是写Python的不二之选。编辑器之神的Vim排第二，如果你比较喜欢折腾Vim8.0的插件，或者想自己构建NeoVim的话。其它的编辑器，我不知道，不想用。不过PyCharm是Jetbrains家的IDE，靠谱。</p>
<p>有功夫在Terminal中装一个<code>emacsclient</code>，然后下载一个oh-my-zsh的插件<code>emacsclient</code>，就可以很愉悦地在Terminal中使用Emacs编辑文件了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ te hello_world.py # te: aliased to /Users/qianyan/.oh-my-zsh/plugins/emacs/emacsclient.sh -nw</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">hello_world.py</span><br><span class="line">Ctrl+x+c 退出emacs :)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(&quot;hello world&quot;)</span><br><span class="line"></span><br><span class="line">$ python3 hello_world.py</span><br><span class="line">hello world</span><br><span class="line">$ python3 -m hello_world #注意没有.py的后缀</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><p>基本工具比较好把握，但是何时选择什么工具做什么样的事情就不好拿捏了，而且如何把事情做成Pythonic的模样也是对经验和能力的考验。</p>
<p>如果我们不是编程小白的话，就需要充分利用迁移学习的能力了。学习的最好方法就是解决问题。不得不承认，在动手实践的过程，时间走得是最快的，在同一件事上花的时间越多也就越熟悉。</p>
<p>我们尝试用Python编写一个<code>tree</code>命令行（Command-Line Application），顾名思义，打印目录层级结构的程序，详细描述参看这篇<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/eb12371e7768">命令行中 tree 的多重实现</a>。</p>
<h3 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h3><p>怎么写测试呢？多年养成的TDD习惯让我首先想要了解什么是Python中常用的测试工具。答案不难寻找，unittest是Python内置的测试模块，而<a target="_blank" rel="noopener" href="https://pytest.org/">pytest</a>是比unittest更简洁和强大的选择，所以我选择后者。</p>
<p>这个程序的测试我使用pytest，但是它并不是所有项目测试的唯一选择，所以最好能局部安装，尤其是限制在当前工程目录里。搜索查找的结果是，Python3内置的虚拟环境（Virtual Environment)模块可以做到这点。</p>
<hr>
<p>虚拟环境<br>在当前创建venv目录(python3 -m venv venv)，然后用<code>tree</code>命令查看该目录的结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m venv venv</span><br><span class="line">$ tree -L 4 venv</span><br><span class="line">venv</span><br><span class="line">├── bin</span><br><span class="line">│   ├── activate</span><br><span class="line">│   ├── activate.csh</span><br><span class="line">│   ├── activate.fish</span><br><span class="line">│   ├── easy_install</span><br><span class="line">│   ├── easy_install-3.6</span><br><span class="line">│   ├── pip</span><br><span class="line">│   ├── pip3</span><br><span class="line">│   ├── pip3.6</span><br><span class="line">│   ├── python -&gt; python3</span><br><span class="line">│   └── python3 -&gt; /usr/local/bin/python3</span><br><span class="line">├── include</span><br><span class="line">├── lib</span><br><span class="line">│   └── python3.6</span><br><span class="line">│       └── site-packages</span><br><span class="line">│           ├── __pycache__</span><br><span class="line">│           ├── easy_install.py</span><br><span class="line">│           ├── pip</span><br><span class="line">│           ├── pip-9.0.3.dist-info</span><br><span class="line">│           ├── pkg_resources</span><br><span class="line">│           ├── setuptools</span><br><span class="line">│           └── setuptools-39.0.1.dist-info</span><br><span class="line">└── pyvenv.cfg</span><br></pre></td></tr></table></figure>
<p>进入虚拟环境，然后使用pip3安装pytest测试模块，会发现venv目录多了些东西。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$  . venv/bin/activate</span><br><span class="line">venv ❯ pip3 install pytest</span><br><span class="line">Collecting pytest</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ tree -L 4 venv</span><br><span class="line">venv</span><br><span class="line">├── bin</span><br><span class="line">│   ├── py.test</span><br><span class="line">│   ├── pytest</span><br><span class="line">├── include</span><br><span class="line">├── lib</span><br><span class="line">│   └── python3.6</span><br><span class="line">│       └── site-packages</span><br><span class="line">│           ├── __pycache__</span><br><span class="line">│           ├── _pytest</span><br><span class="line">│           ├── atomicwrites-1.1.5.dist-info</span><br><span class="line">│           ├── attr</span><br><span class="line">│           ├── attrs-18.1.0.dist-info</span><br><span class="line">│           ├── more_itertools</span><br><span class="line">│           ├── more_itertools-4.2.0.dist-info</span><br><span class="line">│           ├── pluggy</span><br><span class="line">│           ├── pluggy-0.6.0.dist-info</span><br><span class="line">│           ├── py</span><br><span class="line">│           ├── py-1.5.3.dist-info</span><br><span class="line">│           ├── pytest-3.6.2.dist-info</span><br><span class="line">│           ├── pytest.py</span><br><span class="line">│           ├── six-1.11.0.dist-info</span><br><span class="line">│           └── six.py</span><br></pre></td></tr></table></figure>
<p>此时，虚拟环境会在<code>PATH</code>变量中前置<code>./bin</code>目录，所以可以直接使用<code>pytest</code>命令进行测试。根据约定，测试文件的名称必须以test_开头，如test_pytree.py，测试方法也必须如此，如test_fix_me。遵循约定编写一个注定失败的测试如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">test_pytree.py</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def test_fix_me():</span><br><span class="line">    assert 1 == 0</span><br><span class="line"></span><br><span class="line">$ pytest</span><br><span class="line">...</span><br><span class="line">    def test_fix_me():</span><br><span class="line">&gt;       assert 1 == 0</span><br><span class="line">E       assert 1 == 0</span><br><span class="line">test_pytree.py:5: AssertionError</span><br></pre></td></tr></table></figure>
<p>测试失败了，说明测试工具的打开方式是正确的。在进入测试、实现和重构（红-绿-黄）的心流状态之前，我们需要考虑测试和实现代码该放在哪里比较合适。</p>
<p>假设我们会把pytree作为应用程序分发出去供别人下载使用，那么标准的目录结构和构建脚本是必不可少的，Python自然有自己的一套解决方案。</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>在<a target="_blank" rel="noopener" href="https://packaging.python.org/tutorials/packaging-projects/">Packaging Python Projects</a>的指导下，我们略作调整，创建和源代码平级的测试目录（tests），得到的完整目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGES</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── docs</span><br><span class="line">├── pytree</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── __version__.py</span><br><span class="line">│   ├── cli.py</span><br><span class="line">│   └── core.py</span><br><span class="line">├── setup.cfg</span><br><span class="line">├── setup.py</span><br><span class="line">├── tests</span><br><span class="line">│   ├── fixtures</span><br><span class="line">│   └── test_pytree.py</span><br><span class="line">└── venv</span><br></pre></td></tr></table></figure>
<p>这样的目录结构不仅可以清晰地模块化，隔离测试和实现，提供使用指导和版本更新记录，还可以很方便地做到包依赖管理和分发，这得归功于setup.py，它是Python项目中事实标准（de facto standard）上的依赖和构建脚本，pytree下的setup.py内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># setup.py</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from setuptools import setup, find_packages</span><br><span class="line">from codecs import open</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">here = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"></span><br><span class="line">about = &#123;&#125;</span><br><span class="line">with open(os.path.join(here, &#x27;pytree&#x27;, &#x27;__version__.py&#x27;), &#x27;r&#x27;, &#x27;utf-8&#x27;) as f:</span><br><span class="line">    exec(f.read(), about)</span><br><span class="line">    </span><br><span class="line">with open(&#x27;README.md&#x27;) as f:</span><br><span class="line">    readme = f.read()</span><br><span class="line"></span><br><span class="line">with open(&#x27;LICENSE&#x27;) as f:</span><br><span class="line">    license = f.read()</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=&#x27;pytree&#x27;,</span><br><span class="line">    version=about[&#x27;__version__&#x27;],</span><br><span class="line">    description=&#x27;list contents of directories in a tree-like format.&#x27;,</span><br><span class="line">    long_description=readme,</span><br><span class="line">    author=&#x27;Yan Qian&#x27;,</span><br><span class="line">    author_email=&#x27;qianyan.lambda@gmail.com&#x27;,</span><br><span class="line">    url=&#x27;https://github.com/qianyan/pytree&#x27;,</span><br><span class="line">    license=license,</span><br><span class="line">    packages=find_packages(exclude=(&#x27;tests&#x27;, &#x27;docs&#x27;)),</span><br><span class="line">    classifiers=(</span><br><span class="line">        &quot;Programming Language :: Python :: 3&quot;,</span><br><span class="line">        &quot;License :: OSI Approved :: MIT License&quot;,</span><br><span class="line">        &quot;Operating System :: OS Independent&quot;,</span><br><span class="line">    ),</span><br><span class="line">    setup_requires=[&#x27;pytest-runner&#x27;],</span><br><span class="line">    tests_require=[&#x27;pytest&#x27;],</span><br><span class="line">    entry_points = &#123;</span><br><span class="line">        &#x27;console_scripts&#x27;: [</span><br><span class="line">            &#x27;pytree = pytree.cli:main&#x27;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    install_requires=[]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>setup.py能帮助我们解决测试中依赖模块的问题，这样我们把pytree作为一个package引入到测试代码中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">venv ❯ python3</span><br><span class="line">Python 3.6.5 (default, Jun 17 2018, 12:13:06)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 9.1.0 (clang-902.0.39.2)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import sys, pprint</span><br><span class="line">&gt;&gt;&gt; pprint.pprint(sys.path)</span><br><span class="line">[&#x27;&#x27;,</span><br><span class="line"> &#x27;/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&#x27;,</span><br><span class="line"> &#x27;/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6&#x27;,</span><br><span class="line"> &#x27;/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload&#x27;,</span><br><span class="line"> &#x27;/Users/qianyan/Projects/personal/public/pytree/venv/lib/python3.6/site-packages&#x27;,</span><br><span class="line"> &#x27;/Users/qianyan/Projects/personal/public/pytree/venv/lib/python3.6/site-packages/docopt-0.6.2-py3.6.egg&#x27;,</span><br><span class="line"> &#x27;/Users/qianyan/Projects/personal/public/pytree&#x27;]</span><br></pre></td></tr></table></figure>
<p>然后运行<code>pytest</code>或者<code>python3 setup.py  pytest</code>，此时pytest会把<code>.pytree/tests</code>前置到<code>PATH</code>变量中，验证如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># test_pytree.py</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def test_path():</span><br><span class="line">    assert sys.path == &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">venv ❯ pytest</span><br><span class="line">-&gt; AssertionError: assert [&#x27;/Users/qianyan/Projects/personal/public/pytree/tests&#x27;, </span><br><span class="line">&#x27;/Users/qianyan/Projects/personal/public/pytree/venv/bin&#x27;, ...] == &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">venv ❯ python3 setup.py pytest</span><br><span class="line">-&gt; AssertionError: assert [&#x27;/Users/qianyan/Projects/personal/public/pytree/tests&#x27;, </span><br><span class="line">&#x27;/Users/qianyan/Projects/personal/public/pytree&#x27;, ...] == &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p>这里<code>python3 setup.py pytest</code>可以通过setup.cfg设置别名（alias）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># setup.cfg</span><br><span class="line">[aliases]</span><br><span class="line">test=pytest</span><br></pre></td></tr></table></figure>
<p><code>python3 setup.py test</code>的效果和前面的命令等同。</p>
<p>使用TDD的方式实现了pytree核心的功能（<a target="_blank" rel="noopener" href="https://github.com/qianyan/pytree">源代码</a>），然后考虑如何把它变成真正的命令行程序。首先要解决的问题是如何以用户友好的方式显示需要哪些传入参数，我们期待<code>pytree -h</code>能提供一些帮助信息，为了不重复造轮子，挑选现成的Option解析库比较轻松。Python内置的argparse已经足够用了，不过docopt值得尝试。</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>setup.py提供了依赖管理功能，声明依赖及其版本号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># setup.py</span><br><span class="line">...</span><br><span class="line">install_requires=[docopt==0.6.2]</span><br></pre></td></tr></table></figure>
<p>然后运行<code>python3 setup.py develop</code>安装。就绪之后，编写cli.py作为命令行程序的入口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin env python3</span><br><span class="line">&quot;&quot;&quot;list contents of directories in a tree-like format.</span><br><span class="line">  Usage: </span><br><span class="line">    pytree &lt;dir&gt;</span><br><span class="line">    pytree -h | --help | --version</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import pytree.core as pytree</span><br><span class="line">import pytree.__version__ as version</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    from docopt import docopt</span><br><span class="line">    arguments = docopt(__doc__, version=version.__version__)</span><br><span class="line">    dir_name = arguments[&#x27;&lt;dir&gt;&#x27;] </span><br><span class="line">    print(&#x27;\n&#x27;.join(pytree.render_tree(pytree.tree_format(&#x27;&#x27;, dir_name))))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>通过打印help信息的方式验证是否符合预期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3 pytree/cli.py --help</span><br><span class="line">list contents of directories in a tree-like format.</span><br><span class="line">  Usage:</span><br><span class="line">    pytree &lt;dir&gt;</span><br><span class="line">    pytree -h | --help | --version</span><br></pre></td></tr></table></figure>
<p>当然理想的结果是直接可以运行<code>pytree --help</code>，setup.py的<code>console_scripts</code>刚好派上用场。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># setup.py</span><br><span class="line">    entry_points = &#123;</span><br><span class="line">        &#x27;console_scripts&#x27;: [</span><br><span class="line">            &#x27;pytree = pytree.cli:main&#x27; #以pytree作为命令行程序的调用名</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此时查看<code>which pytree</code>显示<code>/Users/qianyan/Projects/personal/public/pytree/venv/bin/pytree</code>，说明pytree已经在路径变量当中，可以直接执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pytree tests/fixtures</span><br><span class="line">tests/fixtures</span><br><span class="line">└── child</span><br></pre></td></tr></table></figure>
<p>完成了命令行程序并通过测试，我们尝试发布到测试仓库（TestPyPI）供其他人下载使用。</p>
<h3 id="包发布"><a href="#包发布" class="headerlink" title="包发布"></a>包发布</h3><p>依照<a target="_blank" rel="noopener" href="https://packaging.python.org/tutorials/packaging-projects/">文档描述</a>，先去TestPyPI注册用户，本地打包成发行版，然后安装twine工具发布。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m pip install --upgrade setuptools wheel</span><br><span class="line">$ python3 setup.py sdist bdist_wheel</span><br><span class="line">$ pytree dist # pytree查看dist目录</span><br><span class="line">dist</span><br><span class="line">├── pytree-1.0.2-py3-none-any.whl</span><br><span class="line">└── pytree-1.0.2.tar.gz</span><br><span class="line">$ python3 -m pip install --upgrade twine</span><br><span class="line">$ twine upload --repository-url https://test.pypi.org/legacy/ dist/* #or twine upload --repository testpypi dist/* 如果你配置了~/.pypirc</span><br></pre></td></tr></table></figure>
<p>上传成功需要一段时间，等待服务完成同步才可以下载，我们在另一个虚拟环境中进行验证：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m venv test</span><br><span class="line">$ . test/bin/activate</span><br><span class="line">test &gt; python3 -m pip install --index-url https://test.pypi.org/simple/ pytree==1.0.2</span><br><span class="line">test &gt; ls venv/lib/python3.6/site-packages/</span><br><span class="line">...</span><br><span class="line">pytree</span><br><span class="line">pytree-1.0.2.dist-info</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>确保site-packages目录下有这两个目录：pytree和pytree-1.0.2.dist-info，然后我们就可以完成最后的验证阶段了，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test &gt; pytree tests/fixtures</span><br><span class="line">tests/fixtures</span><br><span class="line">└── child</span><br></pre></td></tr></table></figure>

<p>这里版本号之所以是1.0.2，是因为已经上传过了0.0.1, 1.0.0, 1.0.1 等版本，TestPyPI不允许同名同版本的文件重复上传，即使删除原来的文件也不行。前面的版本都有一定的错误，错误的根因在于<code>find_packages</code>以及<code>package_dir</code>的配置项文档说明很模糊，而且只有到上传到TestPyPI然后下载下来，才能验证出来，这种缓慢的反馈是Python的应该诟病的地方。</p>
<hr>
<p><strong>注意</strong><br>find_package()也是一个深坑，第一个参数如果写成<code>find_packages(&#39;pytree&#39;, exclude=...)</code>，那么pytree下的所有Python文件都会被忽略。原因是pytree已经是package，所以不应该让setup去这个目录找其他的packages. </p>
<p>这个<code>package_dir</code>也是如此，我们如果设置<code>package_dir=&#123;&#39;&#39;: &#39;pytree&#39;&#125;</code>，setup.py就会将<code>/Users/qianyan/Projects/personal/public/pytree/pytree</code>前置到<code>PATH</code>中，这会导致<code>console_scripts&#39;: [&#39;pytree = pytree.cli:main&#39;]</code>抛出错误 ModuleNotFoundError: no module named ‘pytree’，究其原因是<code>pytree/pytree</code>导致setup尝试在<code>pytree/pytree</code>这个package里头找自己（pytree），自然找不到。但是如果改成<code>console_scripts&#39;: [&#39;pytree = cli:main&#39;]</code>，因为cli在<code>pytree/pytree</code>底下，所以就能成功执行。当然这是一种<strong>错误</strong>的写法。</p>
<h2 id="如果遇到了-ModuleNotFoundError-no-module-named-‘pytree’-的错误，最好的方式就是import-sys-pprint然后pprint-pprint-sys-path-，很容易发现Python运行时的执行路径，这有助于排查潜在的配置错误。"><a href="#如果遇到了-ModuleNotFoundError-no-module-named-‘pytree’-的错误，最好的方式就是import-sys-pprint然后pprint-pprint-sys-path-，很容易发现Python运行时的执行路径，这有助于排查潜在的配置错误。" class="headerlink" title="如果遇到了  ModuleNotFoundError: no module named ‘pytree’  的错误，最好的方式就是import sys, pprint然后pprint.pprint(sys.path)，很容易发现Python运行时的执行路径，这有助于排查潜在的配置错误。"></a>如果遇到了  ModuleNotFoundError: no module named ‘pytree’  的错误<br>，最好的方式就是<code>import sys, pprint</code>然后<code>pprint.pprint(sys.path)</code>，很容易发现Python运行时的执行路径，这有助于排查潜在的配置错误。</h2><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/qianyan/pytree/">Pytree Source Code</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.python-guide.org/en/latest/">The Hitchhiker’s Guide to Python</a></li>
<li><a target="_blank" rel="noopener" href="https://www.emacswiki.org/emacs/PythonProgrammingInEmacs">Emacs python-mode</a></li>
<li><a target="_blank" rel="noopener" href="https://pytest.org/">Python Test Tool</a></li>
<li><a target="_blank" rel="noopener" href="https://packaging.python.org/tutorials/packaging-projects/">Packaging Python Projects</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2018/05/13/learn-idris/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/13/learn-idris/" class="post-title-link" itemprop="url">代数定义- idris</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-13 15:38:28" itemprop="dateCreated datePublished" datetime="2018-05-13T15:38:28+08:00">2018-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-07-18 13:08:27" itemprop="dateModified" datetime="2018-07-18T13:08:27+08:00">2018-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="关于环境和数据类型"><a href="#关于环境和数据类型" class="headerlink" title="关于环境和数据类型"></a>关于环境和数据类型</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li>Emacs集成 Idris 开发环境</li>
<li>Idris repl 使用说明</li>
<li>Idris 代数类型定义</li>
</ol>
<h3 id="1-Emacs-安装-idris-mode"><a href="#1-Emacs-安装-idris-mode" class="headerlink" title="1. Emacs 安装 idris-mode"></a>1. Emacs 安装 idris-mode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(use-package idris-mode</span><br><span class="line">  :mode ((&quot;\\.idr$&quot; . idris-mode)</span><br><span class="line">         (&quot;\\.lidr$&quot; . idris-mode))</span><br><span class="line">  :ensure t</span><br><span class="line">  :defer t)</span><br><span class="line"></span><br><span class="line">(provide &#x27;init-idris)</span><br></pre></td></tr></table></figure>
<p>emacs 打开任何以<code>*.idr</code>和<code>*.lidr</code>作为后缀的文件，都可以启用idris-mode.<br>另外，使用<code>C-c C-l</code>可以在<code>*idris-repl*</code>中加载当前文件并启用 type check 进行检查，出现的错误会打印在<code>*idris-notes* buffer</code>中。</p>
<p><strong>注意</strong><br>关于 IO 的调用问题，经典 <code>Hello World</code> 程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module Main</span><br><span class="line"></span><br><span class="line">main : IO ()</span><br><span class="line">main = putStrLn &quot;Hello World&quot;  </span><br></pre></td></tr></table></figure>
<p>当需要在repl中调用 main 方法时，需要通过<code>:x main</code> 执行，才能看到执行结果，<code>Hello World</code> 会显示在<code>*idris-process* buffer</code> 中。原因是 repl 会返回一个 IO action，这个 IO action 只会在 idris 之外 hook 的 terminal 中才会执行。<a target="_blank" rel="noopener" href="https://github.com/idris-lang/Idris-dev/issues/3152">https://github.com/idris-lang/Idris-dev/issues/3152</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:x  &lt;expr&gt;  Execute IO actions resulting from an expression using the interpreter</span><br></pre></td></tr></table></figure>

<h3 id="2-自定义数据类型"><a href="#2-自定义数据类型" class="headerlink" title="2. 自定义数据类型"></a>2. 自定义数据类型</h3><p>我们先定义一下自然数：自然数就是从0开始，后面的数都比前一个自然数多1的数列。我们从小知道的自然数0, 1, 2,…,100,… 看上去只是一系列割裂开的一组符号，但是事实上，数列本身必然存在一些属性，数与数之间必然存在规律。</p>
<p>基于前面提到的自然数的属性，我们定义自然数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data Natural = Z | S Natural</span><br></pre></td></tr></table></figure>
<p>读作：自然数要么是Z（零），要么是自然数的后继(S)</p>
<h4 id="2-1-定义加法"><a href="#2-1-定义加法" class="headerlink" title="2.1 定义加法"></a>2.1 定义加法</h4><p>接下来，我们定义自然数的加法运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plus : Natural -&gt; Natural -&gt; Natural</span><br><span class="line">plus Z     m = m            -- 模式1</span><br><span class="line">plus (S n) m = S (plus n m) -- 模式2</span><br></pre></td></tr></table></figure>
<p>首先定义出了 plus 函数的类型，它是接收两个自然数，然后返回一个自然数的函数，这里使用了柯里化的表现方式。<br><code>plus Z m = m</code> 表示任何自然数加上零，都得自然数本身；<br><code>plus (S n) m = S (plus n m)</code> 表示任何两个自然数相加，都等于其中一个自然数的前趋和另一个自然相加结果的后继。这句话说起来比较绕，但是只要展开之后就比较容易理解了。</p>
<p>考察<code>1 + 1 = 2</code>，可以表达如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(S Z) # 1 是 0 的后继</span><br><span class="line">plus (S Z) (S Z) -- 1 + 1</span><br><span class="line">S (plus Z (S Z)) -- 根据模式2展开上面的式子</span><br><span class="line">(S (S Z))      -- 根据模式1展开上面的式子</span><br></pre></td></tr></table></figure>
<p><code>(S (S Z))</code> 就是自然数2</p>
<h4 id="2-2-定义乘法"><a href="#2-2-定义乘法" class="headerlink" title="2.2 定义乘法"></a>2.2 定义乘法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mult : Natural -&gt; Natural -&gt; Natural</span><br><span class="line">mult Z     m = Z</span><br><span class="line">mult (S n) m = plus m (mult n m)</span><br></pre></td></tr></table></figure>
<p><code>mult Z m = Z</code>表示任何自然数乘以零，都得零；<br><code>mult (S n) m = plus m (mult n m)</code>表示任何两个自然相乘，都等于其中一个自然数和另一个自然数的前趋相乘结果再加上这个自然数。</p>
<hr>
<p>学习资料<br>[1] <a target="_blank" rel="noopener" href="https://github.com/idris-hackers/idris-mode">Idris mode</a><br>[2] <a target="_blank" rel="noopener" href="http://fieldstrength.org/learn-idris/">Learn idris</a><br>[3] <a target="_blank" rel="noopener" href="http://docs.idris-lang.org/en/latest/">Idris docs</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2018/05/01/ruling-the-waves/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/01/ruling-the-waves/" class="post-title-link" itemprop="url">技术简史</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-01 17:48:40" itemprop="dateCreated datePublished" datetime="2018-05-01T17:48:40+08:00">2018-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-05-07 12:17:32" itemprop="dateModified" datetime="2018-05-07T12:17:32+08:00">2018-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%94%9F%E6%B4%BB/" itemprop="url" rel="index"><span itemprop="name">生活</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="太长不读篇"><a href="#太长不读篇" class="headerlink" title="太长不读篇"></a>太长不读篇</h2><p>《技术简史》原著*Ruling the wave, From the Compass to the Internet, a History of Business and Politics along the Technological Frontier)*。依书中的视角，从15世纪的地理大发现到21世纪的网络音乐，每一次技术的创新和商业发展都大致遵循4个阶段规律：</p>
<ol>
<li>创新</li>
<li>市场化</li>
<li>创造性的混乱</li>
<li>制定规则</li>
</ol>
<p>而<strong>制定规则者为王</strong>就是本书的核心观点。引用1993年获得诺贝尔经济学奖的Douglass North的研究：市场刚出现时，稍大的组织可以通过行会或协会来规范市场的交易，但这些早期的市场如果想要最终发展成为高效的大型企业的话，就需要国家介入，制定各种规章制度以保证贸易顺畅。用他的话来说就是，<strong>巩固市场所需的财产所有权必须由政治制度和司法体制通过保证签订契约的成本最小化来落实。</strong></p>
<p>不过，这里的问题是政府就能保证签订契约的成本最小化么？如果出现一种新的技术，它可以让这个成本小于政府的监管和司法投入，那么它就不仅是一种技术的革新，同时是对技术发展既定规律的革新。答案是区块链？没有产权和交易的规则，市场一定不会发展。这里的产权对应区块链应用中资产转账，而交易规则对应的是智能合约。那么答案可能真是区块链了。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>Debora. spa，女，哈佛大学博士，哈佛商学院教授。著有《The baby business》和《Ruling the waves》（译本：技术简史）。这本《Ruling the waves》最早出版于2001年，中文译本于2017年4月由中信出版社出版。主要描述了从15世纪的大航海到21世纪的互联网时代，创新技术的发展规律，得出制定规则者为王的结论。</p>
<p>配合<a target="_blank" rel="noopener" href="https://book.douban.com/subject/27078260/">《维多利亚时代的互联网》</a>一起读，对电报带来的社会变革会更有切身感受，通过时间线串联起来理解效果更佳。</p>
<h2 id="历史在一遍遍重演"><a href="#历史在一遍遍重演" class="headerlink" title="历史在一遍遍重演"></a>历史在一遍遍重演</h2><p>“没文化，真可怕！”<br>回到中世纪那黑暗的1000年间，教会的僧侣掌握着知识的生产和传播，未曾开化的愚民既没有能力也没有渠道获取知识，其中就包括圣经抄本及其解释权。这些愚民只能听从教会宣扬的神祗和信仰，怀疑者统统被审判为异教徒和魔女，火烧异教徒和魔女狩猎甚嚣尘上，一切都是没有文化的恶果。但是压迫必然遭遇反抗，活字印刷术的出现让知识出版变得开放和自由并且廉价，知识的生产和传播开始规模化，人们可以直接获取知识而不再依赖教会，解读圣经的权利得以回归，随之稀释的是教会的控制权。但是教会也不会坐以待毙，他们建立自己的天主教印刷工厂推动反宗教改革，印制大量《圣经》和核心书刊，并且知道如何争取有读写能力的追随者，进而掌握了知识的核心传播形式，其统治地位并没有被动摇。虽然如此，但是世界的规则已经改变，权力发生了转移。</p>
<p>印刷术将物理世界中这些以前需要手抄的竞争性资源变得廉价，让知识持久化下来，打破了时间的侵蚀，但是知识的传播却还是受限于距离，行进缓慢。每当这时，总有英雄出现。19世纪，电报的发明以及历经坎坷的商业化进程，彻底改变信息传播的形式，加速了全球的信息互联。再加上19世纪末，电话和无线电通讯的发明，整个世界宛若突然缩小成一体，信息的传递变得不可思议得快速和廉价。20世纪计算机的发明奠定了20世纪末的互联网诞生的基础，信息传递不仅变得快速，其内容还异彩纷呈。这个时代，没有哪个组织和团体可以垄断信息及其传播形式。</p>
<h2 id="第一次浪潮"><a href="#第一次浪潮" class="headerlink" title="第一次浪潮"></a>第一次浪潮</h2><p>15-17世纪的大航海时代，航海技术的大发展开启了一个新的商业世界。<br>葡萄牙亨利王子，获得“航海家”亨利的称号，1460去世，大航海时代来临。</p>
<p>技术创新<br>14世纪，欧洲的船运贸易无法远离海岸，受制于变幻莫测的天气和有限的航海技术。威尼斯的商人只敢在亚得里亚海和爱奥尼亚海（地中海）航运，不敢穿越直布罗陀海峡（西班牙和北非摩洛哥）来到北大西洋。英国商人也只敢航行到法国西部的比斯开湾。<br><img src="https://upload-images.jianshu.io/upload_images/217988-3dbe0683eb40eec3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="西欧"></p>
<p>14世纪初，船舶工艺升级，厚重的船让位于轻快的帆船，这些船比原来的更大也更轻。另外，13世纪中期，《图解海航手册》可让航海员可以估算地理位置。15世纪早期，指南针等技术也等到了广泛应用。</p>
<p>先驱<br>葡萄牙的亨利王子，为了实际的目的——西非的黄金，基督教布道等，沿着非洲的西海岸航行，并且记录下了航海活动的信息收集。在这过程中，改良了地图绘制和造船工艺，让很少的人就能操作很大的船。早期的船只能顺风航行，但是亨利王子的轻快的小船在逆风时也能航行，这样远航的船只也能顺利返航。</p>
<p>亨利王子与1460年去世，新一代的探险者正式开启了大航海的时代。葡萄牙海员率先南下到达非洲的最南端，并且来到了印度洋的西海岸。1484年，哥伦布得到了西班牙国王费迪南的资助，发现了美洲新大陆；1521年，麦哲伦绕过了南美洲最南端，进入太平洋，然后到达亚洲。这证明了世界是圆的。</p>
<p>1569年，比利时的绘图者墨卡托（Mercator）发明了一种新式的地图绘制方法，墨卡托投影，把地球沿着经线分割开然后展开成一个矩形，这样的绘制技巧在精度上有了质的飞跃。普通的航海员也可以远航了。</p>
<p>创新性的混乱<br>海盗。16-18世纪，伴随着大海航时代的到来，海盗猖獗。主要原因一个是海上并没有很好的法律约束，还有一个最重要的原因是国家在维护自己的权益。这个时代大部分的欧洲国家都在从事私掠活动。给海盗授予掠夺的权利是最经济的打压敌国贸易的政治手段。</p>
<p>大海盗弗朗西斯德雷克（Francis Drake）的故事<br><img src="https://upload-images.jianshu.io/upload_images/217988-a893b072883b535f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="弗朗西斯·德雷克"></p>
<p>德雷克大半个人生都是海盗。早年间，他在英国精英的支持下，做起了“三角贸易”。从非洲俘获奴隶，然后卖到加勒比海的西班牙殖民者，再从他们手上换取毛皮等货物，然后再带回英国。不过，在一次返回英国的航行中，他的船遭到了来自西班牙军队的袭击死里逃生。复仇的怒火在心里燃烧。自从被英国赋予掠夺权之后，他开始袭击美洲的西班牙殖民地，掠夺海上的丝绸和黄金。1581年，伊丽莎白一世女王授予他爵位。一以贯之的海盗生存法则——“在合适的时候，跳上正确的船”。</p>
<p>制定规则<br>1701年，英国政府公开绞死了著名的海盗之一的威廉·基德<br>1721年，当罗杰斯离开拿骚岛，加勒比海最猖狂的“黑胡子”艾华德·蒂奇和“白棉布”杰克也已经绝迹。</p>
<p>1730年，海盗的黄金时代结束了，但是知道1830年才算几乎根除。</p>
<p>为何原本受到国家暗中保护的海盗突然遭到了所有政府的封杀？因为规则改变了。海盗这个团体不再是政府的政治手段，反而成为了问题。1588年，西班牙无敌舰队在和英国的海战中战败，伴随而来的是西班牙在大西洋垄断时代的没落。而且原来的大海航时代的先驱逐渐占领了海洋贸易这些商人，他们为了维护自己的利益，也开始要求政府打击海盗。1856年，欧洲7个国家的代表在巴黎会面，签署了《巴黎宣言》，正式宣布任何海上的私掠行为都被禁止。</p>
<h2 id="电报时代"><a href="#电报时代" class="headerlink" title="电报时代"></a>电报时代</h2><p>技术创新<br>1791年法国的查普兄弟通过铜锅和同步的2倍速时钟传递信息。法国的查普发明了感观电报，1793年，法国建立起第一个观感电报塔。1837年，摩尔斯发明了摩尔斯电码和电报，并将电报推出实验室。</p>
<p>电报先驱<br>库克，菲尔德，奥莱利，彭德这些电报先驱们看到了电报的商业潜力，然后发展起了新的市场。</p>
<p>创新性混乱<br>电报市场发展起来之后，遇到了和其它技术一样的问题。最大的问题就是如何合作：电报的线路是分离的，同时使用的code book（代码本）也不同。</p>
<p>如果电报网络互不兼容，那么每条线路的价值都会被降低。电报先驱们开始制定标准和规则。</p>
<p>制定规则<br>欧洲和美国一开始介入市场的方式不同。欧洲各国都有自己的电报线路和标准，因为当时大部分的电报公司都和政府有关系，为了能够实现国际间的通讯，欧洲大陆共同推行相同的标准和技术规范，这要归功于成立的国际电报联盟。</p>
<p>不过美国恰好相反，政府在早期就退出了电报市场。然后私营企业强强联合，建立起了一套共同遵守的规则。不过市场竞争的本质就是消除竞争，在各自利益的驱使下，短暂建立起的联盟是脆弱。这表现在电报市场就是西部联合公司一家独大，而这实质上就是垄断。最后，政府颁布了公共规则。1910年，美国国会通过一项法案，授予州际商业委员会调查电报收费的权利。1934年，通过通信法案，正式把规范电报业的任务交给了联邦通信委员会。</p>
<h2 id="无线电时代"><a href="#无线电时代" class="headerlink" title="无线电时代"></a>无线电时代</h2><p>技术创新<br>19世纪20年代末，电磁感应让无线电的研究向前一步。1865年，苏格兰数学家麦克斯韦证明了电和光可以以相同的速度在空气中传播。最终在1887年，德国科学家赫兹成功地用实验证明了麦克斯韦用数学说明的现象。</p>
<p>马可尼发明了无线电装置，并成功将它进行了商业化应用。</p>
<p>无线电先驱<br>马可尼无线电报公司和德国德律风根公司，那时候还只是能够传递电码；1918年美国的RCA（美国无线电公司）诞生，已经可以进行声音广播了。</p>
<p>创新性混乱<br>1910年左右，传播信号开始互相干扰。1912年4月12日，豪华巨轮”泰坦尼克号“撞到冰山沉没，因为信号阻塞特别严重，导致家属迟迟得不到救援信息。因为这件事，美国政府要求业余无线电操作员需要取得营业执照，而且无线电频谱变为离散状态。</p>
<p>自从广播播放音乐火了之后，人们开始私自搭设电台，同时混乱使用频道的方式开始发生。</p>
<p>制定规则<br>1927年，美国出台了《无线电法案》，大公司相当统一，无线电行业在这个时候”可能是全美唯一一个全体一致要求管制自身的行业“了。究其缘由，有线电报的所有者和财产所有权是明确的，但是无线电波是无形的，因为没有一个成形的财产所有权分配系统，所以建立频段划分系统除了政府没有人可以胜任。</p>
<h2 id="卫星电视和数字电视时代"><a href="#卫星电视和数字电视时代" class="headerlink" title="卫星电视和数字电视时代"></a>卫星电视和数字电视时代</h2><p>1983年，鲁伯特·默多克（Rupert Murdoch）的新闻集团购买了一家英国的卫星电视SATV（卫星电视）并更名为 Sky，他们想在英国的电视市场努力地开创出一片卫星电视的天地。因为卫星电视在后期的维护以及远距离传播上有天然的优势。而且，BBC电视只为政府代言，播放充满精英文化的正经说道题材也确实让民众难以下咽。以丘吉尔为代表的保守党重新掌权（二战期间）之后，开始稳步地将竞争引入电视市场。</p>
<p>英国的无线电视技术的历史久远。早在1926年，一名叫做约翰·贝尔德（John Baird)的企业家，说服了英国广播公司（BBC）发展广播可视图画的技术，进而演化成了BBC电视业务。经历过一段时间的国有垄断之后，由于政策的允许，各大商业独立电视台也开始进入电视市场，并且在市场份额上形成了势均力敌的局面。当然，政府的监管机制从来没有落下，ITA（独立电视局，类似广电总局）负有监管和审核独立电视节目的责任。只不过这个还只是地面上的无线电视广播，压根没有卫星电视什么事儿。</p>
<p>时间来到了1977年，世界无线电管理委员会分配了已知的卫星空间，同时规定参与国可以得到当时广播卫星所有频道中5个频道。英国将其中的2个频道分配给了老牌的BBC，剩下的3个频道通过竞标的方式分配给了BSB（英国卫星广播公司）。Sky公司却在竞标的过程中失败了，但却不一定是坏事。当BSB调用大量精英研发新技术（D-MAC）标准的时候，Sky公司租了位于法国，比利时和德国三国交界处，一个叫做卢森堡大公国的通讯卫星。这个决策的厉害之处是恰逢欧洲委员会规定：对任何广播卫星的制裁只能由来源国发起。Sky公司绕过了英国的法律约束，同时发动和推出了上门推销技能和免费的售后服务，这些举措成功地吸引了客户，并最终帮助Sky公司占领了市场。在这场商业角逐当中，Sky成功扭转局势，打败了主要竞争对手BSB。1990年，两家公司达成协议，合并成一家公司，并取名为BSkyB公司。同时默多克的新闻集团获得了50%的股份，并拥有绝对的控制权。</p>
<p>BSkyB的故事并没有结束，因为有一位创奇的人物还没有登场。</p>
<p>由于商业模式和原来那些独立电视没有太大区别，导致BSkyB没有足够的订单来获得广告收入，再加上合并之后内部摩擦不断，BSkyB在起飞阶段的日子并不好过。于是，默多克私下邀请萨姆·克里泽木（Sam Chisholm）加入了Sky。在那之前，克里木泽就以果敢和成就而闻名。</p>
<p>克里泽木迅速采取了行动。他首先抢占先机控制电视内容，飞去美国和好莱坞的影片公司签约，这其中就包含默多克自己的福克斯公司（21 Century FOX）。非常意外的，他应好莱坞影片公司对产权的保护要求，发展出了一种全新的商业模式——通过加密技术保护产权，并引导顾客为片源付费，从而建立起来一种关联影片提供商和顾客的全新收费模式。除此之外，他也和体育赛事联盟签约，将原来处于公共领域的体育赛事直播转化成了私营方式。虽然这种方式遭到各方质疑和控诉，但是最终还是安然无事，并获得了巨额回报。</p>
<p>其次运用准入控制手段，他联合以色列的Adi Shamir（RSA加密方式中A指的就是他）建立了一家专门为BSkyB公司提供加密服务的NDC（News datacom）公司。同时积极开发包含加解密、内容管理功能的机顶盒。在稳固新建立的商业模式的同时，还通过市场份额的优势，迫使其它内容供应商加入自己的系统。这种做法巩固了BSkyB的生态环境，也为后来其它竞争手对其垄断的控诉提供了证据。</p>
<p>回顾Sky公司的一路辉煌，就会发现挺符合辩证法中的否定之否定的规律。卫星电视技术，因为其创新的特征，让Sky公司绕过了英国的法律和规则，以一种“海盗式”的手段，打开了顽固的英国电视市场。当竞争者开始用反垄断法为自己发言的时候，它又用自创的商业模式——付费电视，把自己隐藏到整个电视市场这个大背景下，躲过了制裁。貌似一切规则都失效了——这就是创新的力量。但是中国有句老话“成也萧何败也萧何”，技术界从来不缺乏新闻。</p>
<p>数字电视时代扑面而来。由于数字信号比模拟信号具有可压缩，可降噪的优势，很快得到政府的重视。1996年，英国推出了《广播法》并统一建立6个新的数字频道。在过渡到数字电视的阶段，英国政府提供了很多对私营企业十分友好的条件。一开始混有BSkyB血统的BDB（英国数字广播电视，后改名为ONdigital）在政治和商业利益的驱使下，将BSkyB从联盟中踢出，并获得了政府划拨的近一半的地面数字波段。</p>
<p>BDB因为有了数字许可证，便开始和BSkyB展开了合作和竞争。一方面BSkyB依赖于BDB的许可证；另一方面，BDB又依赖BSkyB提供的影片服务。这期间BDB更名为ONdigital。1999年末，BSkyB和ONdigital公司成为了英国数字电视市场的两大巨头。经过这轮技术洗牌之后，政治方向也开始朝着不利于BSkyB公司的方向倾斜，表现在BSkyB对足球俱乐部曼彻斯特连队接管被禁止。另外，政府颁布了新一轮的电视标准中，要求提供一种标准的接口，而BSkyB公司从未使用过，而且这相当于打破了BSkyB的生态闭环，也意味着它不得不和其它电视公司展开公开竞争。</p>
<p>这一波数字技术的截胡操作，让BSkyB失去了垄断的地位。否定之否定同样作用到了BSkyB自己的身上。不管如何，电视技术还在持续发展中。</p>
<h2 id="密码朋克"><a href="#密码朋克" class="headerlink" title="密码朋克"></a>密码朋克</h2><p>密码朋克（crypherpunk）指的是一帮倡导使用强加密技术保护个人隐私的活动家，他们的敌人是企图剥夺民众使用加密技术的政府。触发密码朋克组织形成的导火索是1993年美国政府企图在所有的计算机和手机植入一种Clipper芯片，这种芯片会包含一个私钥，当设备被卖出后，对应的私钥会被存储在第三方的契约账户中。一旦政府获得许可就会取出私钥查看传输的情报。然而，这种措施无疑刺激到了密码朋克们的神经，对于他们而言，这是政府企图建立“网络极权国家”的阴谋，必须反抗！结果白宫方面放弃了这一方案。这是属于密码朋克的胜利。</p>
<p>加密技术的发展有自己鲜明的特征。首先是制定标准的过程，几乎不存在混沌的状态。新的加密技术出现，旧的就随之淘汰，顺应自然；其次它也不存在拥塞状态，毕竟它分明就不是一种通讯技术，相比于电报、无线电、互联网以及区块链在初期遇到的拥塞问题，加密技术几乎不存在需要分割的稀缺资源，也就无需外部力量维持所有权的分配秩序；最后，纵观加密技术的历史，这项技术从诞生之初就很少申请过专利。当然现代加密技术倒是申请了不少专利，但是加密界有自己独特的一套共识——闭源的加密算法是不安全的。这或许不能构成对所有权混乱的理由，不过，由于政府最初对加密技术的封闭，所以它在发展过程中没有出现创造性的混乱状态，所以对于加密技术所有权的任何保护措施也就不太重要了。</p>
<h2 id="微软托拉斯"><a href="#微软托拉斯" class="headerlink" title="微软托拉斯"></a>微软托拉斯</h2><h3 id="微软帝国的崛起和侵权案件"><a href="#微软帝国的崛起和侵权案件" class="headerlink" title="微软帝国的崛起和侵权案件"></a>微软帝国的崛起和侵权案件</h3><p>1968年，比尔·盖茨接触到计算机的世界。他和保罗·艾伦（Paul Allen）一起为DEC（数字设备公司）编写程序。1975年7月，艾伦在Altair机器上成功地演示了改良过的BASIC语言五个月之后，微软（MicroSoft）公司成立了。这时候的微软靠卖BASIC语言的光盘获取版权收入，即便彼时的软件所有权概念还很模糊。</p>
<p>微软的将BASIC语言据为己有的做法在当时引起了轩然大波，而争论的中心发生在一家业余爱好者俱乐部——家酿计算机俱乐部最初的理念是“通过共享经验和相互交流构想，我们促进了这门艺术的发展，使更多的人用低价的计算机成为可能”。成员复制了微软的BASIC代码，并开始随意分发，在他们看来，微软的BASIC代码本来就属于公众。这种做法影响了微软的版权收入，同时也惹恼了比尔·盖茨。盖茨批判这帮人是强盗，但是这些人认为比尔·盖茨把几百人花了几年做出来的软件占为己用的行为才是强盗行径。</p>
<p>虽然盖茨在这次争论中缓和了态度，但是软件的版权问题迟迟没有定论。直到Altair公司被出售给加利福尼亚的一家较大的公司，这个公司声称BASIC语言归自己所有，并且禁止其他生产商使用。这回盖茨没有怂，微软同这家公司进行了长达6个月的诉讼大战，最终赢得了胜利。这个案件不仅仅宣告了微软对BASIC语言的所有权，也意味着一种定论：软件是私有财产。</p>
<p>1983-1986年，苹果公司和微软的达成合作，微软将Word等常用办公软件提供给了苹果，而苹果通过销售Macintosh电脑帮助微软销售软件。但是微软发布了Windows2.03，抢占了苹果公司在PC的市场份额，苹果公司这时冷静不下去了，以盗用Macintosh界面所有权的理由将微软告上法庭。虽然最终对于微软的所有控诉都被法院解除了，苹果公司也因此遭受了巨大的打击，但是微软也因为反托斯拉法案受到了美国联邦贸易委员会（FTC）的调查，并且在1994年签署一项包含了若干义务的法律协议，其中规定了微软不得在操作系统中捆绑销售自家的软件，同时微软也承诺不再使用任何许可协议。</p>
<h3 id="浏览器战争中的反托斯拉"><a href="#浏览器战争中的反托斯拉" class="headerlink" title="浏览器战争中的反托斯拉"></a>浏览器战争中的反托斯拉</h3><p>时间来到了1995年，这是互联网商业化的元年。这一年，如今已经是两大世界级电子商务巨头的eBay和Amazon上线运营，在中国，杭州的大学英语老师马云和宁波的电信员工丁磊离开公职，分别创办了阿里巴巴和网易。Jim clark和Mark Anderson成立的公司Netscape凭借Navigator（前身是Mosaic）这款网络浏览器迅速横扫互联网市场。在CERN（欧洲粒子研究院）研究员Tim Berners-Lee发明了HTML、HTTP协议和URL之后，信息通讯发生了变革，这让非技术用户上网成为了可能。这时候，Anderson等人就想着如何把图像和多媒体引入网络，最后的答案便是通过浏览器。</p>
<p>大公司总是习惯后知后觉，微软也不例外。在Netscape公司的Navigator浏览器迅速占领了超过90%的浏览器市场份额后，微软按捺不住了——以卖自家软件见长的微软很害怕Navigator成为网络的入口，用户便可以下载任何产商的软件。所以微软开始行动了，首先它成立了一个互联网平台和工具部门，其次通过威逼利诱的手段限制和控制Netscape公司，最后通过“行贿”的方式联合AOL推广自己的IE浏览器。当然，这些措施生效了，Netscape在浏览器市场上的份额迅速缩减了一半以上。然而，微软这种行为最终还得诉诸法律。</p>
<p>当商业利益上竞争不过巨头的时候，留给这些创业公司最后的武器就是反垄断法。在这场旷日持久的诉讼案件中，法院确定了微软的反垄断行为，但是并没有接受Jackson法官拆分微软的命令。2001年11月2日，联邦司法部与微软就案件达成了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%88%E4%BC%97%E5%9B%BD%E8%AF%89%E5%BE%AE%E8%BD%AF%E6%A1%88">和解</a>，但是这次和解既没有要求微软修改源码从Windows中剥离IE浏览器，也没有限制微软未来在Windows中捆绑其它软件，所以令很多人感到不满。</p>
<p>微软的故事告诉我们，当进入一个崭新的领域时，原先社会上比较分明的所有权和反托拉斯的界定问题变得模棱两可起来。大公司可以很快地在新兴的市场之上建立起法则这时候法律监管是滞后的。但是一旦新兴企业创造出自己的市场之后，原先的大公司还想要入场并部署自己的规则，那么不论是企业、用户还是政府都会介入进来反对垄断和维护秩序。</p>
<h2 id="网络音乐"><a href="#网络音乐" class="headerlink" title="网络音乐"></a>网络音乐</h2><p>1999年，19岁的Shawn Fanning辍学创建了Napster这个革命性的网站，它允许用户在网站上自由地交换歌曲，这种免费的上传和分发的模式很快就颠覆了传统的唱片行业。传统的唱片行业掌控了音乐录制，分发渠道，前期宣传和明星包装，也同时形成了对音乐制作人的“奴役”和压榨。随着数字音乐技术（MP3）的成熟，有些歌手直接将自己的音乐上传到如Naspter这样的网站上，听众就可以自由地下载和分发了。</p>
<p>随着Napster网站上用户数的不断增加，盗版的问题也日益严重起来。原本歌手将音乐上传到网上，是想脱离唱片公司根深蒂固的体系，但是后果是歌手也没法获得相应的报酬了。于是，围绕网络空间中的知识产权保护也引来了大量的讨论。有人说“未来将会胜利，在网络世界中不存在所有权”，也有人说“知识产权的整个结构和价值都在改变……技术性障碍将几乎为零……法律本身变得无所适从或遭到削弱”。</p>
<p>但是从历史中走过来，我们发现网络世界的版权还是保留了下来。苹果公司的Jobs开创的iTunes和iPod从某种程度上，拯救了数字音乐的版权和唱片公司。早在2004年，iTunes store 在合法数字音乐市场的份额就超过了70%，2011年数字音乐的市场份额更是超过了实体音乐（刻录在唱片等载体上的音乐）。当正版商开始用资本发展网络商业模式时，它也会收购那些盗版的公司，自己也得到进一步发展。从这些方面看，不难得出数字版权更像是在唱片公司、数字音乐公司以及公众参与下共同制定的一项行业标准，然后由政府强制执行。所以最终胜利还是属于那些制定行业标准的家伙，尽管总有人存在一种理想国的幻想。</p>
<p>– 于 2018-05-01</p>
<hr>
<p>[1] <a target="_blank" rel="noopener" href="https://book.douban.com/subject/26767590/">技术简史</a><br><img src="https://upload-images.jianshu.io/upload_images/217988-4b70b752956cb5f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="技术简史核心观点"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2018/04/29/multiple-implements-of-tree-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/29/multiple-implements-of-tree-command/" class="post-title-link" itemprop="url">Tree command 的多重实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-29 21:41:27" itemprop="dateCreated datePublished" datetime="2018-04-29T21:41:27+08:00">2018-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-07-04 08:04:05" itemprop="dateModified" datetime="2018-07-04T08:04:05+08:00">2018-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>利用递归，将目录转换成 <code>&#123;:name: &quot;.&quot;, :children: []&#125;</code> 结构</li>
<li>对于第一层目录名，前缀装饰成 <code>T_branch = &quot;├── &quot; </code>或者 <code>L_branch = &quot;└── &quot;</code></li>
<li>对于子目录，前缀装饰成 <code>I_branch = &quot;│   &quot;</code>或者<code>SPACER   = &quot;    &quot;</code><br>举例如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── tree.py  # 不是最后一项，所以使用 T_branch 前缀</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md # 由于其父亲不是最后一项，所以使用 I_branch 前缀</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data    # 是最后一项，所以使用 L_branch 前缀</span><br><span class="line">    ├── output.txt # 由于其父亲是最后一项，所以使用 SPACE 前缀</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">list a directory in tree way.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">children(path):</span></span><br><span class="line"><span class="string">    map(lambda name: tree(path, name), listdir(path))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">tree(parent, dir_name):</span></span><br><span class="line"><span class="string">    if is_file(parent, dir_name):</span></span><br><span class="line"><span class="string">        return &#123;&#x27;name&#x27;: dir_name, &#x27;children&#x27;: []&#125;</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        children = children(join(parent, dir_name))</span></span><br><span class="line"><span class="string">        return &#123;&#x27;name&#x27;: dir_name, &#x27;children&#x27;: children&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> functools <span class="keyword">as</span> fp</span><br><span class="line"></span><br><span class="line">I_branch = <span class="string">&quot;│   &quot;</span></span><br><span class="line">T_branch = <span class="string">&quot;├── &quot;</span></span><br><span class="line">L_branch = <span class="string">&quot;└── &quot;</span></span><br><span class="line">SPACER = <span class="string">&quot;    &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_children</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> filename: tree_format(path, filename), os.listdir(path))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tree_format</span>(<span class="params">parent, dir_name</span>):</span><br><span class="line">    path = os.path.join(parent, dir_name)</span><br><span class="line">    is_file = os.path.isfile(path)</span><br><span class="line">    children = [] <span class="keyword">if</span> is_file <span class="keyword">else</span> _children(path)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;name&#x27;</span>: dir_name, <span class="string">&#x27;children&#x27;</span>: <span class="built_in">list</span>(children)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">render_tree</span>(<span class="params">tr</span>):</span><br><span class="line">    name = tr[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    children = tr[<span class="string">&#x27;children&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> [name] + fp.reduce(<span class="keyword">lambda</span> l, r: l + r,</span><br><span class="line">                              <span class="built_in">map</span>(<span class="keyword">lambda</span> arg: render(<span class="built_in">len</span>(children))(*arg),</span><br><span class="line">                                  <span class="built_in">enumerate</span>(children)),</span><br><span class="line">                              [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">render</span>(<span class="params">length</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prefix</span>(<span class="params">index, child</span>):</span><br><span class="line">        is_last = (index == length - <span class="number">1</span>)</span><br><span class="line">        prefix_first = L_branch <span class="keyword">if</span> is_last <span class="keyword">else</span> T_branch</span><br><span class="line">        prefix_rest = SPACER <span class="keyword">if</span> is_last <span class="keyword">else</span> I_branch</span><br><span class="line">        tr = render_tree(child)</span><br><span class="line">        head = prefix_first + tr[<span class="number">0</span>]</span><br><span class="line">        tail = [prefix_rest + t <span class="keyword">for</span> t <span class="keyword">in</span> tr[<span class="number">1</span>:]]</span><br><span class="line">        <span class="keyword">return</span> [head] + tail</span><br><span class="line">    <span class="keyword">return</span> prefix</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;\n&#x27;</span>.join(render_tree(tree(<span class="string">&#x27;&#x27;</span>, sys.argv[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">$ python3 tree.py . <span class="comment">#打印当前的目录的所有文件及子目录</span></span><br><span class="line">.</span><br><span class="line">├── tree.py</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data</span><br><span class="line">    ├── output.txt</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure>
<h2 id="Clojure-实现"><a href="#Clojure-实现" class="headerlink" title="Clojure 实现"></a>Clojure 实现</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">ns</span></span> tree</span><br><span class="line">  (<span class="symbol">:require</span> [clojure.java.io <span class="symbol">:as</span> io]</span><br><span class="line">            [clojure.string <span class="symbol">:as</span> str]))</span><br><span class="line">(<span class="keyword">def</span> <span class="title">L-branch</span> <span class="string">&quot;└── &quot;</span>)</span><br><span class="line">(<span class="keyword">def</span> <span class="title">T-branch</span> <span class="string">&quot;├── &quot;</span>)</span><br><span class="line">(<span class="keyword">def</span> <span class="title">I-branch</span> <span class="string">&quot;│   &quot;</span>)</span><br><span class="line">(<span class="keyword">def</span> <span class="title">SPACE</span>    <span class="string">&quot;    &quot;</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">declare</span></span> tree)</span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">children</span> [path]</span><br><span class="line">  (<span class="name"><span class="built_in">map</span></span> #(<span class="name">tree</span> %) (<span class="name">.listFiles</span> path)))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">tree</span> [dir-name]</span><br><span class="line">  (<span class="name"><span class="built_in">let</span></span> [path (<span class="name">io/file</span> dir-name)</span><br><span class="line">        dir? (<span class="name">.isDirectory</span> path)]</span><br><span class="line">    &#123;<span class="symbol">:name</span> (<span class="name">.getName</span> path)</span><br><span class="line">     <span class="symbol">:children</span> (<span class="name"><span class="built_in">if</span></span> dir? (<span class="name">children</span> path))&#125;))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">render-tree</span> [&#123;name <span class="symbol">:name</span> children <span class="symbol">:children</span>&#125;]</span><br><span class="line">  (<span class="name"><span class="built_in">cons</span></span> name</span><br><span class="line">        (<span class="name"><span class="built_in">mapcat</span></span> (<span class="name"><span class="built_in">fn</span></span> [child index]</span><br><span class="line">                  (<span class="name"><span class="built_in">let</span></span> [last? (<span class="name"><span class="built_in">=</span></span> index (<span class="name"><span class="built_in">dec</span></span> (<span class="name"><span class="built_in">count</span></span> children)))</span><br><span class="line">                        prefix-first (<span class="name"><span class="built_in">if</span></span> last? L-branch T-branch)</span><br><span class="line">                        prefix-rest (<span class="name"><span class="built_in">if</span></span> last? SPACE I-branch)</span><br><span class="line">                        sub-tree (<span class="name">render-tree</span> child)]</span><br><span class="line">                    (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">str</span></span> prefix-first (<span class="name"><span class="built_in">first</span></span> sub-tree))</span><br><span class="line">                          (<span class="name"><span class="built_in">map</span></span> #(<span class="name"><span class="built_in">str</span></span> prefix-rest %) (<span class="name"><span class="built_in">rest</span></span> sub-tree)))))</span><br><span class="line">                children</span><br><span class="line">                (<span class="name"><span class="built_in">range</span></span>))))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">-main</span> [&amp; args]</span><br><span class="line">  (<span class="name"><span class="built_in">-&gt;&gt;</span></span> </span><br><span class="line">      (<span class="name">tree</span> (<span class="name"><span class="built_in">first</span></span> args))</span><br><span class="line">      (<span class="name">render-tree</span>)</span><br><span class="line">      (<span class="name">str/join</span> <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">      (<span class="name">println</span>)))</span><br><span class="line">$ lein run -m tree .</span><br><span class="line">.</span><br><span class="line">├── tree.py</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data</span><br><span class="line">    ├── output.txt</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure>
<h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;io/ioutil&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;path&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	I_branch = &quot;│   &quot;</span><br><span class="line">	T_branch = &quot;├── &quot;</span><br><span class="line">	L_branch = &quot;└── &quot;</span><br><span class="line">	SPACER   = &quot;    &quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type entry struct &#123;</span><br><span class="line">	name     string</span><br><span class="line">	children []entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e entry) String() string &#123;</span><br><span class="line">	if len(e.children) == 0 &#123;</span><br><span class="line">		return e.name</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		s := e.name</span><br><span class="line">		for _, child := range e.children &#123;</span><br><span class="line">			s += child.String()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return s</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Children(path string) []entry &#123;</span><br><span class="line">	result := []entry&#123;&#125;</span><br><span class="line">	files, _ := ioutil.ReadDir(path)</span><br><span class="line">	for _, f := range files &#123;</span><br><span class="line">		result = append(result, Tree(path, f.Name()))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Tree(parent, dirName string) entry &#123;</span><br><span class="line">	realPath := path.Join(parent, dirName)</span><br><span class="line">	theChildren := []entry&#123;&#125;</span><br><span class="line">	if f, ok := os.Stat(realPath); ok == nil &#123;</span><br><span class="line">		if f.IsDir() &#123;</span><br><span class="line">			theChildren = Children(realPath)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return entry&#123;name: dirName, children: theChildren&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RenderTree(e entry) []string &#123;</span><br><span class="line">	name := e.name</span><br><span class="line">	children := e.children</span><br><span class="line">	result := []string&#123;name&#125;</span><br><span class="line"></span><br><span class="line">	for index, child := range children &#123;</span><br><span class="line">		subTree := RenderTree(child)</span><br><span class="line">		prefixFirst := T_branch</span><br><span class="line">		prefixRest := I_branch</span><br><span class="line">		if index == len(children)-1 &#123;</span><br><span class="line">			prefixFirst = L_branch</span><br><span class="line">			prefixRest = SPACER</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		result = append(result, prefixFirst+subTree[0])</span><br><span class="line"></span><br><span class="line">		for _, sub := range subTree[1:] &#123;</span><br><span class="line">			result = append(result, prefixRest+sub)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(strings.Join(RenderTree(Tree(&quot;&quot;, os.Args[1])), &quot;\n&quot;))</span><br><span class="line">&#125;</span><br><span class="line">$ go run tree.go .</span><br><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── data.txt</span><br><span class="line">│   └── output.txt</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── recursion.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── tree.py</span><br><span class="line">└── tuples.py</span><br></pre></td></tr></table></figure>
<h2 id="NodeJS-实现"><a href="#NodeJS-实现" class="headerlink" title="NodeJS 实现"></a>NodeJS 实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const I_branch = &#x27;│   &#x27;</span><br><span class="line">const T_branch = &#x27;├── &#x27;</span><br><span class="line">const L_branch = &#x27;└── &#x27;</span><br><span class="line">const SPACER   = &#x27;    &#x27;</span><br><span class="line"></span><br><span class="line">function children(path) &#123;</span><br><span class="line">    return fs.readdirSync(path).map(filename =&gt; tree(path, filename))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tree(parentDir, dirName) &#123;</span><br><span class="line">    let realPath = path.join(parentDir, dirName)</span><br><span class="line">    let isDir = fs.statSync(realPath).isDirectory()</span><br><span class="line">    return &#123;name: dirName, children: isDir ? children(realPath) : []&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prefix(len) &#123;</span><br><span class="line">    return (tr, index) =&gt; &#123;</span><br><span class="line">        let isLast = len == index + 1</span><br><span class="line">        let prefixFirst = isLast ? L_branch : T_branch</span><br><span class="line">        let prefixRest = isLast ? SPACER : I_branch</span><br><span class="line">        let [head, ...tail]= renderTree(tr)</span><br><span class="line"></span><br><span class="line">        return [prefixFirst + head].concat(tail.map(name =&gt; prefixRest + name))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderTree(&#123;name: name, children: children&#125;) &#123;</span><br><span class="line">    return [name]</span><br><span class="line">        .concat(children</span><br><span class="line">            .map(prefix(children.length))</span><br><span class="line">            .reduce((l, r) =&gt; l.concat(r), []))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(renderTree(tree(&#x27;&#x27;, process.argv[2])).join(&#x27;\n&#x27;))</span><br><span class="line"></span><br><span class="line">$ node tree.js .</span><br><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── data.txt</span><br><span class="line">│   └── output.txt</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── recursion.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── tree.py</span><br><span class="line">└── tuples.py</span><br></pre></td></tr></table></figure>
<h2 id="Kotlin-script"><a href="#Kotlin-script" class="headerlink" title="Kotlin script"></a>Kotlin script</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File</span><br><span class="line"></span><br><span class="line">val I_branch = &quot;│   &quot;</span><br><span class="line">val T_branch = &quot;├── &quot;</span><br><span class="line">val L_branch = &quot;└── &quot;</span><br><span class="line">val SPACER   = &quot;    &quot;</span><br><span class="line"></span><br><span class="line">data class Entry (val name: String, val children: List&lt;Entry&gt;)</span><br><span class="line"></span><br><span class="line">fun children(path: File): List&lt;Entry&gt; &#123;</span><br><span class="line">    return path.listFiles().map &#123;tree(it)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun tree(path: File): Entry &#123;</span><br><span class="line">    val isDir = path.isDirectory()</span><br><span class="line">    return Entry(path.getName(), if(isDir) children(path) else listOf&lt;Entry&gt;())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun renderTree(tree: Entry): List&lt;String&gt; &#123;</span><br><span class="line">    val name = tree.name</span><br><span class="line">    val children = tree.children</span><br><span class="line"></span><br><span class="line">    return listOf(name) + children.mapIndexed &#123; i, e -&gt; prefix(children.size)(i, e) &#125;.fold(listOf&lt;String&gt;()) &#123;l, r -&gt; l + r&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun prefix(size: Int): (Int, Entry) -&gt; List&lt;String&gt; &#123;</span><br><span class="line">    return &#123;index, entry -&gt;</span><br><span class="line">        val isLast = index + 1 == size</span><br><span class="line">        val prefixFirst = if(isLast) L_branch else T_branch</span><br><span class="line">        val prefixRest = if(isLast) SPACER else I_branch</span><br><span class="line">        val subTree = renderTree(entry)</span><br><span class="line"></span><br><span class="line">        listOf(prefixFirst + subTree.first()) + subTree.drop(1).map &#123;t -&gt; prefixRest + t&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(renderTree(tree(File(args[0]))).joinToString(&quot;\n&quot;))</span><br><span class="line"></span><br><span class="line">$ kotlinc -script tree.kts .</span><br><span class="line">.</span><br><span class="line">├── tree.py</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data</span><br><span class="line">    ├── output.txt</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure>
<h2 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.io._</span><br><span class="line">val I_branch = &quot;│   &quot;</span><br><span class="line">val T_branch = &quot;├── &quot;</span><br><span class="line">val L_branch = &quot;└── &quot;</span><br><span class="line">val SPACER   = &quot;    &quot;</span><br><span class="line"></span><br><span class="line">case class Entry(name: String, children: List[Entry])</span><br><span class="line"></span><br><span class="line">def children(path: File): List[Entry] = path.listFiles().toList.map((it: File) =&gt; tree(it))</span><br><span class="line"></span><br><span class="line">def tree(path: File): Entry = Entry(path.getName(), if(path.isDirectory()) children(path) else List[Entry]())</span><br><span class="line"></span><br><span class="line">def prefix(size: Int) = (index: Int, entry: Entry) =&gt; &#123;</span><br><span class="line">    val isLast = index + 1 == size</span><br><span class="line">    val prefixFirst = if(isLast) L_branch else T_branch</span><br><span class="line">    val prefixRest = if(isLast) SPACER else I_branch</span><br><span class="line">    val subTree = renderTree(entry)</span><br><span class="line">    List(prefixFirst + subTree.head) ++ subTree.tail.map(t =&gt; prefixRest + t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def renderTree(tree: Entry): List[String] = &#123;</span><br><span class="line">    val name = tree.name</span><br><span class="line">    val children = tree.children</span><br><span class="line"></span><br><span class="line">    return List(name) ++ children</span><br><span class="line">      .zipWithIndex</span><br><span class="line">      .map(&#123;case (e: Entry, i: Int) =&gt; prefix(children.size)(i, e)&#125;)</span><br><span class="line">      .fold(List[String]())((l, r) =&gt; l ++ r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(renderTree(tree(new File(args(0)))).mkString(&quot;\n&quot;))</span><br><span class="line"></span><br><span class="line">$ scala tree.scala .</span><br><span class="line">.</span><br><span class="line">├── tree.py</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data</span><br><span class="line">    ├── output.txt</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure>
<h2 id="Elixir"><a href="#Elixir" class="headerlink" title="Elixir"></a>Elixir</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env elixir</span><br><span class="line"></span><br><span class="line">defmodule Tree do</span><br><span class="line">  def main([dir | _]) do</span><br><span class="line">    dir |&gt; tree_format |&gt; render_tree |&gt; Enum.join(&quot;\n&quot;) |&gt; IO.puts</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  defp children(path) do</span><br><span class="line">    if (path |&gt; File.dir?) do</span><br><span class="line">      File.ls!(path) |&gt; Enum.map(fn f -&gt; tree_format(path, f) end)</span><br><span class="line">    else</span><br><span class="line">      []</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  defp tree_format(parent_dir \\ &quot;.&quot;, dir_name) do</span><br><span class="line">    %&#123;:name =&gt; dir_name, :children =&gt; Path.join(parent_dir, dir_name) |&gt; children&#125;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  defp decorate(is_last?, [parent | children]) do</span><br><span class="line">    prefix_first = (if (is_last?), do: &quot;└── &quot;, else: &quot;├── &quot;)</span><br><span class="line">    prefix_rest = (if (is_last?), do: &quot;    &quot;, else: &quot;│   &quot;)</span><br><span class="line">    [prefix_first &lt;&gt; parent | children |&gt; Enum.map(fn child -&gt; prefix_rest &lt;&gt; child end)]</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  defp render_tree(%&#123;name: dir_name, children: children&#125;) do</span><br><span class="line">    [dir_name </span><br><span class="line">     | children </span><br><span class="line">     |&gt; Enum.with_index(1)</span><br><span class="line">     |&gt; Enum.map(fn &#123;child, index&#125; -&gt; decorate(length(children) == index, render_tree(child)) end) </span><br><span class="line">     |&gt; List.flatten]</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Tree.main(System.argv)</span><br><span class="line"></span><br><span class="line">$ elixir tree.exs .</span><br><span class="line">.</span><br><span class="line">├── tree.py</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data</span><br><span class="line">    ├── output.txt</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qianyan.github.io/2018/02/17/The-Simple-Summary-of-FP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lambeta">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="λ">
      <meta itemprop="description" content="Elegance and familiarity are orthogonal">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | λ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/17/The-Simple-Summary-of-FP/" class="post-title-link" itemprop="url">函数式编程简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-02-17 22:45:31 / 修改时间：22:45:56" itemprop="dateCreated datePublished" datetime="2018-02-17T22:45:31+08:00">2018-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="函数式编程是什么"><a href="#函数式编程是什么" class="headerlink" title="函数式编程是什么"></a>函数式编程是什么</h3><blockquote>
<p>函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 – wiki</p>
</blockquote>
<h3 id="例子一-累加运算"><a href="#例子一-累加运算" class="headerlink" title="例子一 累加运算"></a>例子一 累加运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum</span></span><br><span class="line">List&lt;Integer&gt; nums = Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">sum</span><span class="params">(List&lt;Integer&gt; nums)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Integer num : nums) &#123;</span><br><span class="line">		result += num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(nums); <span class="comment">// -&gt; 46</span></span><br></pre></td></tr></table></figure>
<p>同样的代码用 Java8 Stream 实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 10).stream().reduce(0, Integer::sum);</span><br></pre></td></tr></table></figure>
<p>同样的代码用 Clojure 实现</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">apply</span></span> + [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">10</span>]) <span class="comment">; -&gt; 46</span></span><br><span class="line">#_(<span class="name"><span class="built_in">reduce</span></span> + [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">10</span>])</span><br></pre></td></tr></table></figure>
<h3 id="例子二-fabonacci数列"><a href="#例子二-fabonacci数列" class="headerlink" title="例子二 fabonacci数列"></a>例子二 fabonacci数列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (number == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(number == <span class="number">2</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">3</span>; cnt &lt;= number; cnt++) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">		a = b;</span><br><span class="line">		b = c;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// java8</span><br><span class="line">Stream.iterate(new int[]&#123;1, 1&#125;, s -&gt; new int[]&#123;s[1], s[0] + s[1]&#125;)</span><br><span class="line">				.limit(10)</span><br><span class="line">				.map(n -&gt; n[1])</span><br><span class="line">				.collect(toList())</span><br><span class="line">// -&gt; [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// clojure</span><br><span class="line">(<span class="name"><span class="built_in">-&gt;&gt;</span></span> (<span class="name"><span class="built_in">iterate</span></span> (<span class="name"><span class="built_in">fn</span></span> [[a b]] [b (<span class="name"><span class="built_in">+</span></span> a b)]) [<span class="number">1</span> <span class="number">1</span>])</span><br><span class="line">     (<span class="name"><span class="built_in">map</span></span> second)</span><br><span class="line">     (<span class="name"><span class="built_in">take</span></span> <span class="number">10</span>))</span><br><span class="line"><span class="comment">; -&gt; (1 2 3 5 8 13 21 34 55 89)  </span></span><br></pre></td></tr></table></figure>
<p>比起命令式的语言，函数式语言更加关注执行的结果，而非执行的过程。</p>
<h2 id="函数式编程的历史"><a href="#函数式编程的历史" class="headerlink" title="函数式编程的历史"></a>函数式编程的历史</h2><h3 id="从Hilbert-23个数学难题谈起"><a href="#从Hilbert-23个数学难题谈起" class="headerlink" title="从Hilbert 23个数学难题谈起"></a>从Hilbert 23个数学难题谈起</h3><p>1900年，Hilbert 提出了数学界悬而未决的10大问题，后续陆续添加成了23个问题，被称为著名的 Hilbert 23 Problem。针对其中第2个决定数学基础的问题——算术公理之相容性，年轻的哥德尔提出了哥德尔不完备定理，解决了这个问题形式化之后的前两点，即数学是完备的吗？数学是相容的吗？哥德尔用两条定理给出了否定的回答。所谓不完备，即系统中存在一个为真，但是无法在系统中推导出来的命题。比如：U说：“U在PM中不可证”。虽然和说谎者很类似，但其实有明显的差异。我们可以假设U为可证，那么可以推出PM是矛盾（不相容）的；但是假设U不可证，却推导不出PM是矛盾的。U的含义是在M中不可证，而事实上，它被证明不可证，所以U是PM中不可证的真命题。基于第一条不完备定理，又可以推导出第二条定理。如果一个（强度足以证明基本算术公理的）公理系统可以用来证明它自身的相容性，那么它是不相容的。</p>
<p>而最后一个问题，数学是确定的吗？也就是说，存在一个算法判定一个给定的命题是否是不确定的吗（Entscheidungsproblem 确定性问题）？这个问题引起了阿隆佐·邱奇和年轻的阿兰·图灵的兴趣。阿隆佐·邱奇的lambda calculus和图灵的图灵机构造出了可计算数，图灵的那篇论文  <em>ON COMPUTABLE NUMBERS, WITH AN APPLICATION TO THE ENTSCHEIDUNGSPROBLEM</em>  的意义不在于证明可计算数是否可数，而在于证明可判定性是否成立。在1936年他们对判定性问题分别独立给出了否定的答案。也就是现在被我们熟知的图灵停机问题：不存在这样一个程序（算法），它能够计算任何程序（算法）在给定输入上是否会结束（停机）。图灵借此发明了通用图灵机的概念，为后来的冯·诺依曼体系的计算机体系提供了理论基础。</p>
<h3 id="Lambda-Calculus"><a href="#Lambda-Calculus" class="headerlink" title="Lambda Calculus"></a>Lambda Calculus</h3><p><img src="http://upload-images.jianshu.io/upload_images/217988-bd2f325f4578f4c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lambda Calculus"></p>
<p>Lambda 表达式包含三个要素</p>
<ol>
<li>变量</li>
<li>lambda 抽象</li>
<li>lambda 应用<br>据此我们可以用函数给出布尔值的定义<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data BOOL = FALSE | TRUE</span><br><span class="line">TRUE = λx.λy.x</span><br><span class="line">FALSE = λx.λy.y</span><br><span class="line"></span><br><span class="line">not = λb.b FALSE TRUE</span><br><span class="line">and = λb1.λb2.b1 b2 FALSE</span><br><span class="line">or  = λb1.λb2.b1 TRUE b2</span><br><span class="line">xor = λb1.λb2.b1 (not b2) b2</span><br></pre></td></tr></table></figure>
自然数的定义<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data NAT = Z | S NAT</span><br><span class="line">0 = λf.λs.s</span><br><span class="line">1 = λf.λs.f s</span><br><span class="line">2 = λf.λs.f f s</span><br><span class="line"></span><br><span class="line">succ n = λf.λs.f (n f s)</span><br><span class="line">zero? n = n (λb.FALSE) TRUE</span><br><span class="line">add = succ n1 n2</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="函数式编程语言的发展"><a href="#函数式编程语言的发展" class="headerlink" title="函数式编程语言的发展"></a>函数式编程语言的发展</h3><p>在这之后，随着通用计算机的产生，人们发觉使用机器码写程序太没有效率。所以1956年左右，John Buckus发明了Fortran（FORmula TRANslating 的缩写）语言，如果对编译原理有了解，那么对BNF范式就不陌生了。与此同时，John McCarthy 发明了Lisp语言，现代的Clojure就是Lisp的方言之一。1966年，Niklaus Wirth发明了Pascal。1969年，Ken Thompson和Dennis Ritchie发明了C语言，过程式语言由于其高效和可移植性迅速崛起。1973年，Robin Milner 发明了ML（Meta Language），后来演变成了OCaml和Stardard ML。1977年，John Buckus在其图灵奖的演讲中创造了 Functional Programming 这个词。1990年，惰性求值的函数式编程语言 Haskell 1.0 发布。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-b32e43ff96d620f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编程语言发展历史"></p>
<h3 id="神奇的-Y-Combinator"><a href="#神奇的-Y-Combinator" class="headerlink" title="神奇的 Y Combinator"></a>神奇的 Y Combinator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(def Y (fn [f]</span><br><span class="line">         ((fn [x] (x x))</span><br><span class="line">          (fn [x]</span><br><span class="line">            (f (fn [y]</span><br><span class="line">                 ((x x) y)))))))</span><br></pre></td></tr></table></figure>

<h3 id="Lisp、ML以及Haskell的关系"><a href="#Lisp、ML以及Haskell的关系" class="headerlink" title="Lisp、ML以及Haskell的关系"></a>Lisp、ML以及Haskell的关系</h3><p>Lisp是动态语言，使用S表达式<br>ML和Haskell都是静态强类型函数式语言<br>ML是第一个使用Hindley-Milner type inference algorithm的语言<br>Lisp和ML都是call-by-value，但是Haskell则是call-by-name<br>Lisp和ML都是不纯的编程语言，但是Haskell是side effect free的</p>
<h2 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h2><p>函数是一等公民，指的是你可以将函数作为参数、返回值、数据结构存在，而且不仅可以用函数名引用，甚至可以匿名调用。</p>
<h3 id="1-作为参数"><a href="#1-作为参数" class="headerlink" title="1. 作为参数"></a>1. 作为参数</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">map</span></span> inc [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]) <span class="comment">;-&gt; (2 3 4 5 6) ;; inc is an argument</span></span><br></pre></td></tr></table></figure>
<h3 id="2-作为返回值"><a href="#2-作为返回值" class="headerlink" title="2. 作为返回值"></a>2. 作为返回值</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">add</span> [num] </span><br><span class="line">    (<span class="name"><span class="built_in">fn</span></span> [other-num] (<span class="name"><span class="built_in">+</span></span> num other-num))) <span class="comment">;; as return-value</span></span><br><span class="line">(<span class="keyword">def</span> <span class="title">add-one</span> (<span class="name">add</span> <span class="number">1</span>))</span><br><span class="line">(<span class="name">add-one</span> <span class="number">2</span>) <span class="comment">;-&gt; 3</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">flip</span> [f]  <span class="comment">;; as argument and return-value</span></span><br><span class="line">  (<span class="name"><span class="built_in">fn</span></span> [x y]</span><br><span class="line">    (<span class="name">f</span> y x)))</span><br></pre></td></tr></table></figure>
<h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3. 数据结构"></a>3. 数据结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(def dictionary &#123;:a &quot;abandon&quot;&#125;) ;; map is also a function, data is code.</span><br><span class="line">(dictionary :a) ;-&gt; &quot;abandon&quot;</span><br><span class="line">(:a dictionary) ;-&gt; &quot;abandon&quot;</span><br></pre></td></tr></table></figure>
<h3 id="4-匿名函数"><a href="#4-匿名函数" class="headerlink" title="4. 匿名函数"></a>4. 匿名函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">((fn [x] (* x x))</span><br><span class="line">        2) ;-&gt; 4</span><br><span class="line">    </span><br><span class="line">(map </span><br><span class="line">    (fn [num] (+ 1 num)) ;; anonymous function</span><br><span class="line">    [1 2 3 4 5]) ;-&gt; (2 3 4 5 6)</span><br></pre></td></tr></table></figure>
<h3 id="5-模块化"><a href="#5-模块化" class="headerlink" title="5. 模块化"></a>5. 模块化</h3><p>在面向对象中，对象是一等公民。所以我们处处要从对象的角度去考虑计算问题，然后产生一种共识——数据应该和它相关的操作放到一起，也就是我们所说的封装。确实没错，但是我们得知道封装的意义在哪里？功能内聚好理解（分块）和局部性影响（控制可变性）。函数式编程同样考虑这些，功能内聚不一定要用类的方式（考虑一下JS的prototype，也是一种面向对象），只要模块做得好，一样能达到效果。局部性影响，其本质是封装可变因素以避免其扩散到代码各处。函数式给出了自己的答案，消除可变因素。</p>
<p>高阶函数和惰性求值也非常有利于模块化。</p>
<h2 id="纯函数和不可变性"><a href="#纯函数和不可变性" class="headerlink" title="纯函数和不可变性"></a>纯函数和不可变性</h2><p>纯函数是指执行过程中没有副作用的函数，所谓副作用是说超出函数控制的操作，比如在执行过程中操作文件系统、数据库等外部资源。纯函数还具有引用透明性的特点，也就是同样的输入导致同样的输出，以至于完全可以用函数的值代替对函数的调用。</p>
<h3 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h3><p>举个例子：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">inc</span></span> <span class="number">1</span>) <span class="comment">; -&gt; 2</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">inc</span></span> (<span class="name"><span class="built_in">inc</span></span> <span class="number">1</span>)</span><br><span class="line">   (<span class="name"><span class="built_in">inc</span></span> <span class="number">2</span>))) <span class="comment">; -&gt; true</span></span><br></pre></td></tr></table></figure>
<p>你们可能就会问，这种东西究竟有什么用呢？纯函数可以很方便地进行缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(defn fibonacci [number]</span><br><span class="line">  (if (or (zero? number) (= 1 number)) 1</span><br><span class="line">      (+</span><br><span class="line">       (fibonacci (dec number))</span><br><span class="line">       (fibonacci (- number 2)))))</span><br><span class="line">(fibonacci 30) ; -&gt; &quot;Elapsed time: 185.690208 msecs&quot;</span><br><span class="line"></span><br><span class="line">(def fibonacci</span><br><span class="line">  (memoize (fn [number] ;;</span><br><span class="line">             (if (or (zero? number) (= 1 number)) 1</span><br><span class="line">                 (+</span><br><span class="line">                  (fibonacci (dec number))</span><br><span class="line">                  (fibonacci (- number 2)))))))</span><br><span class="line">(fibonacci 30) ; -&gt; &quot;Elapsed time: 0.437114 msecs&quot;</span><br></pre></td></tr></table></figure>
<h3 id="不可变计算"><a href="#不可变计算" class="headerlink" title="不可变计算"></a>不可变计算</h3><p>谈到不可变性，我们做个游戏。统计在座的一共有多少人数。我们都知道从某个人开始依次报数，最后得到的数字就是总人数，其实这就是一种不可变计算的游戏，为什么这么说呢？因为报数其实一个计算的过程，第一个人计算出1这个数，传递给第二个人。然后第二个人拿着前面的1进行加一操作，然后把结果2传递给后面的人做加法，以此类推。为了提高统计的效率，我也可以进行分组，然后每组自行报数，最后统计结果。但是如果我在白板上写个数字1，然后让大家来过来该这个数字，很大可能会出现错误，因为这个数字成为了竞态条件。在多并发的情况下，就得用读写锁来控制。所以不可变性特别利于并发。<br><img src="http://upload-images.jianshu.io/upload_images/217988-83061fa854cfadf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不可变性"></p>
<h3 id="不可变的链式结构"><a href="#不可变的链式结构" class="headerlink" title="不可变的链式结构"></a>不可变的链式结构</h3><p>好了，现在我们有个新的需求，设计一个不可变列表收集大家的名字。每个节点存储一个姓名的字符串，并且有个指针指向下一个节点。但是这也打破了列表的不可变性。怎么办？我们可以把新的节点指向旧有的列表，然后返回一个新的列表。这就是不可变列表实现的机制。随便一提，这也是区块链不可变特征的由来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-f83728f3beea90e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不可变的链式结构"></p>
<p>Clojure的创造者Rich Hickey扩展了Ideal Hash Tree数据结构，实现了Persistent Vector。由于此处的叶子节点可以扩展成32个，所以可以大量存储数据。利用Ideal Hash Tree的特点可以快速索引出数据，与此同时，数据的“增删改”也能做到近常数化的时间，并且总是产生新的数据结构替换原有的数据结构，即一种不可变的链式存储结构。<br><img src="http://upload-images.jianshu.io/upload_images/217988-db581f0f87265914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Clojure Persistent Vector"></p>
<h3 id="不可变的树状结构"><a href="#不可变的树状结构" class="headerlink" title="不可变的树状结构"></a>不可变的树状结构</h3><p>Zipper数据结构类似于文本编辑器中的 gap buffer，编辑文本时，光标左边和右边分别是独立的buffer，光标处也是单独的buffer，这样便可以方便地添加文字，也很方便删除左右buffer中的文字；移动光标会涉及buffer之间的拷贝。基本上能在常数时间内完成编辑。Zipper数据结构模仿了这种方式，能在常数时间内完成树的编辑工作，也能很快地重新构建一棵树。<br><img src="http://upload-images.jianshu.io/upload_images/217988-6017ad15b573ab02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不可变的树状结构"></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>可计算很大问题就是得实现递归功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defn reverse-seq [coll]</span><br><span class="line">  (when-let [elem (first coll)]</span><br><span class="line">    (concat (reverse-seq (rest coll)) [elem])))</span><br><span class="line">(reverse-seq [1 2 3]) ; -&gt; (3 2 1)</span><br></pre></td></tr></table></figure>
<p>和循环无异的尾递归</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defn gcd [&amp; nums]</span><br><span class="line">  (reduce #(if (zero? %2)</span><br><span class="line">                %</span><br><span class="line">                (recur %2 (mod % %2))) nums))</span><br><span class="line">(gcd 8 16) ; -&gt; 8                </span><br></pre></td></tr></table></figure>
<h2 id="生成式测试"><a href="#生成式测试" class="headerlink" title="生成式测试"></a>生成式测试</h2><p>生成式测试会基于输入假设输出，并且生成许多可能的数据验证假设的正确性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(defn add [a b]</span><br><span class="line">  (+ a b))</span><br><span class="line">;; 任取两个整数，把a和b加起来的结果减去a总会得到b。</span><br><span class="line">(def test-add</span><br><span class="line">  (prop/for-all [a (gen/int)</span><br><span class="line">                 b (gen/int)]</span><br><span class="line">                (= (- (add a b) a) b)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(tc/quick-check 100 test-add)</span><br><span class="line">; -&gt; &#123;:result true, :num-tests 100, :seed 1515935038284&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果表明，刚才运行了100组测试，并且都通过了。理论上，程序可以生成无数的测试数据来验证add方法的正确性。即便不能穷尽，我们也获得一组统计上的数字，而不仅仅是几个纯手工挑选的用例。</p>
<h2 id="抽象是什么"><a href="#抽象是什么" class="headerlink" title="抽象是什么"></a>抽象是什么</h2><p>抽取共性，封装细节，忘记不重要的差异点。这样的好处是可以做到局部化影响和延迟决策。<br><img src="http://upload-images.jianshu.io/upload_images/217988-f9b16b9dc18ba66c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="抽象屏障"></p>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>命名就是一种抽象，重构中最重要的技法就是重命名和提取小函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(* 3 3 3)</span><br><span class="line">(* x x x)</span><br><span class="line">(* y y y)</span><br><span class="line">-&gt;</span><br><span class="line">(defn cube [x]</span><br><span class="line">  (* x x x))</span><br></pre></td></tr></table></figure>
<h3 id="延迟决策"><a href="#延迟决策" class="headerlink" title="延迟决策"></a>延迟决策</h3><p>例如：我们定义数对 pair</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair:: (cons x y)</span><br><span class="line">first pair -&gt; x</span><br><span class="line">second pair -&gt; y</span><br></pre></td></tr></table></figure>
<p>那么它的具体实现会是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(defn cons [x y]</span><br><span class="line">  (fn [m]</span><br><span class="line">    (cond (= m 0) x</span><br><span class="line">          (= m 1) y)))</span><br><span class="line">(defn first [z]</span><br><span class="line">  (z 0))</span><br><span class="line">(defn second [z]</span><br><span class="line">  (z 1))</span><br></pre></td></tr></table></figure>
<p>也可以是这样的，还可以是其它各种各样的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(defn cons [x y]</span><br><span class="line">  (fn [b]</span><br><span class="line">    (b x y))</span><br><span class="line">(defn first [z]</span><br><span class="line">    (z (fn [x y] x)))</span><br><span class="line">(defn second [z]</span><br><span class="line">    (z (fn [x y] y)))</span><br></pre></td></tr></table></figure>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数就是可以接收函数的函数，高阶函数提供了足够的抽象，屏蔽了很多底层的实现细节。比如Clojure中的<code>map</code>高阶函数，它接收<code>(fn [v] ...)</code>，把一组数据映射成另外一组数据。</p>
<h3 id="过程抽象"><a href="#过程抽象" class="headerlink" title="过程抽象"></a>过程抽象</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">map</span></span> inc [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]) <span class="comment">; -&gt; (2 3 4 5 6)</span></span><br></pre></td></tr></table></figure>
<p>这些函数抽象出映射这样语义，除了容易记忆，还能很方便地重新编写成高效的底层实现。也就是说，一旦出现了更高效的<code>map</code>实现算法，现有的代码都能立刻从中受益。</p>
<h2 id="函数的组合"><a href="#函数的组合" class="headerlink" title="函数的组合"></a>函数的组合</h2><p>函数组合之后会产生巨大的能量</p>
<h3 id="神奇的加法"><a href="#神奇的加法" class="headerlink" title="神奇的加法"></a>神奇的加法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((comp (map inc) (filter odd?)) +) 1 2) ; -&gt; 4</span><br></pre></td></tr></table></figure>
<p>怎么去理解这个函数的组合？我们给它取个好听的名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(def special+ ((comp (map inc) (filter odd?)) +))</span><br><span class="line">(special+ 1 2) ; -&gt; 4</span><br><span class="line"></span><br><span class="line">; &lt;=&gt; 等价于</span><br><span class="line">(if (odd? (inc 2))</span><br><span class="line">    (+ 1 3))</span><br><span class="line">    1)</span><br></pre></td></tr></table></figure>
<p>这个未必是个好的组合方式，但是不可否认的是，我们可以用这些随意地将这些函数组合到一起，得到我们想要的结果。</p>
<h3 id="transducer"><a href="#transducer" class="headerlink" title="transducer"></a>transducer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(def xf (comp (filter odd?) (take 10)))</span><br><span class="line">(transduce xf conj (range))</span><br><span class="line">;; [1 3 5 7 9 11 13 15 17 19]</span><br></pre></td></tr></table></figure>
<p>这里直接将求值延迟到了<code>transduce</code>计算的时候，换句话说，<code>xf</code>定义了一种过程：filter出奇数并取出前10个元素。同等的代码，如果用表达式直接书写的话，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(-&gt;&gt; (range)</span><br><span class="line">     (filter odd?)</span><br><span class="line">     (take 10))</span><br></pre></td></tr></table></figure>
<p>这里的问题就是我们没能使用高阶函数抽象出过程，如果把 conj 换成其他的reduce运算，现在的过程无法支撑，但是tranducers可以！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(transduce xf + (range)) ;-&gt; 100</span><br></pre></td></tr></table></figure>
<p>我们再看一个tranducer的神奇使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(defn log [&amp; [idx]]</span><br><span class="line">  (fn [rf]</span><br><span class="line">    (fn</span><br><span class="line">      ([] (rf))</span><br><span class="line">      ([result] (rf result))</span><br><span class="line">      ([result el]</span><br><span class="line">        (let [n-step (if idx (str &quot;Step: &quot; idx &quot;. &quot;) &quot;&quot;)]</span><br><span class="line">          (println (format &quot;%sResult: %s, Item: %s&quot; n-step result el)))</span><br><span class="line">        (rf result el)))))</span><br><span class="line"></span><br><span class="line">(def ^:dynamic *dbg?* false)</span><br><span class="line"></span><br><span class="line">(defn comp* [&amp; xforms]</span><br><span class="line">  (apply comp</span><br><span class="line">         (if *dbg?*</span><br><span class="line">           (-&gt;&gt; (range)</span><br><span class="line">                (map log)</span><br><span class="line">                (interleave xforms))</span><br><span class="line">           xforms)))</span><br><span class="line"></span><br><span class="line">(binding [*dbg?* true]</span><br><span class="line">  (transduce</span><br><span class="line">   (comp*</span><br><span class="line">    (map inc)</span><br><span class="line">    (filter odd?))</span><br><span class="line">   +</span><br><span class="line">   (range 5))) ;; -&gt; 9</span><br><span class="line">   </span><br><span class="line">Step: 0. Result: 0, Item: 1</span><br><span class="line">Step: 1. Result: 0, Item: 1</span><br><span class="line">Step: 0. Result: 1, Item: 2</span><br><span class="line">Step: 0. Result: 1, Item: 3</span><br><span class="line">Step: 1. Result: 1, Item: 3</span><br><span class="line">Step: 0. Result: 4, Item: 4</span><br><span class="line">Step: 0. Result: 4, Item: 5</span><br><span class="line">Step: 1. Result: 4, Item: 5</span><br></pre></td></tr></table></figure>
<p>之所以会出现上述的结果，是因为<code>interleave xforms</code>将<code>(map inc)</code>以及<code>(filter odd?)</code>和logs进行了交叉，得到的结果是<code>(comp (map inc) (log) (filter odd?) (log))</code>，所以如果是偶数就会被filter清除，看不见log了。</p>
<p>首先一定得理解：每个tranducer函数都是同构的！<br>形式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defn m [f]</span><br><span class="line">    (fn [rf] </span><br><span class="line">        (fn [result elem]</span><br><span class="line">            (rf result (f elem)))))</span><br></pre></td></tr></table></figure>
<p>这意味着<code>(m f)</code>的函数都是可以组合的，组合的形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(comp (m f) (m1 f1) ...)</span><br></pre></td></tr></table></figure>
<p>展开之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((m f) </span><br><span class="line">    ((m1 f1) </span><br><span class="line">        ((m2 f2) ...)))</span><br><span class="line">-&gt;</span><br><span class="line">(fn [result elem]</span><br><span class="line">    (((m1 f1) </span><br><span class="line">        ((m2 f2) ...)) result (f elem)))</span><br></pre></td></tr></table></figure>
<p>所以可以看到第一个执行的一定是 comp 的首个 reducing function 参数。故：</p>
<ol>
<li>xform 作为组合的前提</li>
<li>执行顺序从左到右；</li>
<li><code>+</code> 作为 reducing function 最后执行；</li>
</ol>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p>什么是<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/324c9ce77317">Monad</a>呢？A monad is just a monoid in the category of endofunctors.</p>
<ol>
<li>Identity—For a monad m, m flatMap unit &#x3D;&gt; m </li>
<li>Unit—For a monad m, unit(v) flatMap f &#x3D;&gt; f(v) </li>
<li>Associativity—For a monad m, m flatMap g flatMap h &#x3D;&gt; m flatMap {x &#x3D;&gt; g(x) flatMap h} <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// java8 实现的 9*9 乘法表</span><br><span class="line">public class ListMonad&lt;T&gt; &#123;</span><br><span class="line">    private List&lt;T&gt; elements;</span><br><span class="line"></span><br><span class="line">    private ListMonad(T elem) &#123;</span><br><span class="line">        this.elements = singletonList(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ListMonad(List&lt;T&gt; elems) &#123;</span><br><span class="line">        this.elements = elems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;U&gt; ListMonad&lt;U&gt; flatmap(Function&lt;T, ListMonad&lt;U&gt;&gt; fn) &#123;</span><br><span class="line">        List&lt;U&gt; newElements = new ArrayList&lt;&gt;();</span><br><span class="line">        this.elements.forEach(elem -&gt; newElements.addAll(fn.apply(elem).elements));</span><br><span class="line">        return new ListMonad&lt;&gt;(newElements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;X&gt; ListMonad&lt;X&gt; uint(X elem) &#123;</span><br><span class="line">        return new ListMonad&lt;&gt;(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;U&gt; ListMonad&lt;U&gt; apply(ListMonad&lt;Function&lt;T, U&gt;&gt; m) &#123;</span><br><span class="line">        return m.flatmap(this::map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;U&gt; ListMonad&lt;U&gt; map(Function&lt;T, U&gt; fn) &#123;</span><br><span class="line">        return flatmap(t -&gt; uint(fn.apply(t)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ListMonad&lt;Integer&gt; m = new ListMonad&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9));</span><br><span class="line">        ListMonad&lt;Integer&gt; m1 = new ListMonad&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9));</span><br><span class="line"></span><br><span class="line">        ListMonad&lt;Integer&gt; list = m.apply(m1.map(x -&gt; y -&gt; x * y));</span><br><span class="line">        // [1...81]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="表达式优于语句"><a href="#表达式优于语句" class="headerlink" title="表达式优于语句"></a>表达式优于语句</h2><h3 id="S表达式"><a href="#S表达式" class="headerlink" title="S表达式"></a>S表达式</h3><ol>
<li>原子，或者；</li>
<li>形式为 (x • y) 的表达式，其中x和y也是S表达式。</li>
</ol>
<p>举个例子，递增一组数据，过滤奇数，然后进行排序，最终取出第一个。如果取不到，返回<code>:not-found</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(-&gt; [1 2 3] </span><br><span class="line">    (-&gt;&gt; (map inc) </span><br><span class="line">         (filter odd?) </span><br><span class="line">         (sort) </span><br><span class="line">         (first)) </span><br><span class="line">    (or :not-found))</span><br><span class="line">; -&gt; 3 </span><br><span class="line">(-&gt; [1 1 3] </span><br><span class="line">    (-&gt;&gt; (map inc) </span><br><span class="line">         (filter odd?) </span><br><span class="line">         (sort) </span><br><span class="line">         (first)) </span><br><span class="line">    (or :not-found)</span><br><span class="line">; -&gt; :not-found    </span><br></pre></td></tr></table></figure>
<p>当然你也可以写成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(if-let [r (first (sort (filter odd? (map inc [1 1 1]))))] </span><br><span class="line">    r </span><br><span class="line">    :not-found)</span><br><span class="line">; -&gt; :not-found    </span><br></pre></td></tr></table></figure>
<p>其实两者都是S表达式，但是下面的写法更加偏向于语句。从串联起来读来讲，前者明显是由于后者的。这要是放在其他函数式语言上，效果更加显著。比如下面重构if-else控制语句到Optional类型。</p>
<h3 id="if-else-Optional"><a href="#if-else-Optional" class="headerlink" title="if-else -&gt; Optional"></a>if-else -&gt; Optional</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Rule&gt; rule = ruleOf(id);</span><br><span class="line"><span class="keyword">if</span>(rule.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">return</span> transform(rule.get());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Rule <span class="title function_">transform</span><span class="params">(Rule rule)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Rule.builder()</span><br><span class="line">                .withName(<span class="string">&quot;No.&quot;</span> + rule.getId())</span><br><span class="line">                .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是典型的语句可以重构到表达式的场景，关键是怎么重构呢？<br>第一步，调转<code>if</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Optional</span> <span class="variable">rule</span> <span class="operator">=</span> ruleOf(id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!rule.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> transform(rule.get());</span><br></pre></td></tr></table></figure>
<p>第二步，<code>Optional.map</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">return</span> rule.map(r -&gt; transform(r)).get();</span><br></pre></td></tr></table></figure>
<p>第三步，<code>inline transform</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">rule.map(r -&gt; Rule.builder()</span><br><span class="line">                    .withName(&quot;No.&quot; + r.getId())</span><br><span class="line">                    .build()).get();</span><br></pre></td></tr></table></figure>
<p>第四步，<code>Optional.orElseThrow</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">rule.map(r -&gt; Rule.builder()</span><br><span class="line">                    .withName(&quot;No.&quot; + r.getId())</span><br><span class="line">                    .build())</span><br><span class="line">    .orElseThrow(() -&gt; new RuntimeException());</span><br></pre></td></tr></table></figure>
<p>第五步，注<code>if</code>释语句中的<code>throw new RuntimeException()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(!rule.isPresent()) &#123;</span><br><span class="line">   // throw new RuntimeException();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这时候发现语句中为空，即可将整个语句删除。可以考虑<code>inline rule</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ruleOf(id).map(r -&gt; Rule.builder()</span><br><span class="line">                    .withName(&quot;No.&quot; + r.getId())</span><br><span class="line">                    .build())</span><br><span class="line">    .orElseThrow(() -&gt; new RuntimeException());</span><br></pre></td></tr></table></figure>
<p>完毕。</p>
<h2 id="我们认识事物的方式"><a href="#我们认识事物的方式" class="headerlink" title="我们认识事物的方式"></a>我们认识事物的方式</h2><ol>
<li>把几个简单的想法合并成一个复合概念，从而创造出所有复杂的概念。</li>
<li>简单的或复杂的两种思想融合在一起，并立即把它们联系起来，不要把它们统一起来，从而得到它所有的关系思想。</li>
<li>把他们与其他所有陪伴他们的真实存在的想法分开：这就是所谓的抽象，因此所有的一般想法都是被提出来的。</li>
</ol>
<h2 id="推荐的书籍"><a href="#推荐的书籍" class="headerlink" title="推荐的书籍"></a>推荐的书籍</h2><ol>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1391740/">逻辑的引擎</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26587213/">函数式编程思维</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1148282/">算机程序的构造和解释</a><br><img src="http://upload-images.jianshu.io/upload_images/217988-8bb6c8f3354a5640.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="推荐的书籍"></li>
</ol>
<hr>
<p>参考资料</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98">图灵停机问题</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/pongba/article/details/1336028">康托尔、哥德尔、图灵 - 永恒的金色对角线</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.klipse.tech/lambda/2016/08/07/pure-y-combinator-clojure.html">Y combinator in Clojure</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%9A%8423%E4%B8%AA%E9%97%AE%E9%A2%98">希尔伯特的23个问题</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28112037">再谈哥德尔不完备定理</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">wiki 函数式编程</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97">lambda 演算</a></li>
<li><a target="_blank" rel="noopener" href="http://athena.ecs.csus.edu/~csc135fp/project/history.html">History of functional programming</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24648375">函数式编程的早期历史</a></li>
<li><a target="_blank" rel="noopener" href="http://www.sohu.com/a/164321809_136745">走进计算机文化史</a></li>
<li><a target="_blank" rel="noopener" href="https://sarabander.github.io/sicp/html/index.xhtml">SICP</a></li>
<li><a target="_blank" rel="noopener" href="http://www.math.cmu.edu/~wgunther/talks/gsLambdaCalculus.pdf">Lambda Calculus and the Decision Problem</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">lambeta</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>






  <script src="/js/third-party/addtoany.js"></script>

  





</body>
</html>
