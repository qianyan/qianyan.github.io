<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vim in practice (0)</title>
    <url>/2013/12/10/vim-tips/</url>
    <content><![CDATA[<h1 id="Skill"><a href="#Skill" class="headerlink" title="Skill"></a>Skill</h1><h4 id="合并两行技巧"><a href="#合并两行技巧" class="headerlink" title="合并两行技巧"></a>合并两行技巧</h4><pre><code>普通模式下（n），光标在上一行，
使用 （J） ： 合并有一个空格
使用 （gJ）：合并没有空格
</code></pre>
<h4 id="写文档，加行号"><a href="#写文档，加行号" class="headerlink" title="写文档，加行号"></a>写文档，加行号</h4><pre><code>:%s/^/\=printf(&#39;%3d  &#39;, line(&#39;.&#39;) )
 %s!nl ( nl 表示 number line )
</code></pre>
<h4 id="替换一个单词"><a href="#替换一个单词" class="headerlink" title="替换一个单词"></a>替换一个单词</h4><pre><code>cw
</code></pre>
<h4 id="编辑buffer或者文件"><a href="#编辑buffer或者文件" class="headerlink" title="编辑buffer或者文件"></a>编辑buffer或者文件</h4><pre><code>:bn(next)
:bp(prev)
</code></pre>
<h4 id="重复命令"><a href="#重复命令" class="headerlink" title="重复命令"></a>重复命令</h4><pre><code>.   重复以上命令
N . 重复以上命令N次
</code></pre>
<h4 id="录制宏"><a href="#录制宏" class="headerlink" title="录制宏"></a>录制宏</h4><pre><code>qa -&gt; 进入宏录制
Yp -&gt; 复制一行进行粘贴
&lt;C-a&gt; （这里我将其替换为&lt;A-a&gt; 实现递增，因为windows会使用惯用键） -&gt; 实现递增
q  -&gt; 退出宏录制
@a -&gt; 将寄存器记录重发
@@ 重复上一个操作
</code></pre>
<h4 id="关于tabedit使用"><a href="#关于tabedit使用" class="headerlink" title="关于tabedit使用"></a>关于tabedit使用</h4><pre><code>set guitablabel=%N/\ %t\ %M  -&gt; tab上面会显示 1/ name.suffix 的格式
map &lt;C-tab&gt; gt -&gt; gt表示切换tab标签
</code></pre>
<h4 id="查找当前word对应的匹配项"><a href="#查找当前word对应的匹配项" class="headerlink" title="查找当前word对应的匹配项"></a>查找当前word对应的匹配项</h4><pre><code>% : 到对应的 (, &#123;, [.
* (resp. #) : 到对应的 (resp. previous) 光标标识的单词
</code></pre>
<h4 id="在当前行进行定位"><a href="#在当前行进行定位" class="headerlink" title="在当前行进行定位"></a>在当前行进行定位</h4><pre><code>0 → go to column 0
^ → go to first character on the line
$ → go to the last character on the line
fa → go to next occurrence of the letter a on the line.
, (resp. ;) will seek for the next (resp. previous) occurrence.
t, → go just before the character ,.
3fa → search the 3rd occurrence of a on this line.
F and T → like f and t but backward.
</code></pre>
<h4 id="如何让Dos下编写的文件在-nix下正常显示"><a href="#如何让Dos下编写的文件在-nix下正常显示" class="headerlink" title="如何让Dos下编写的文件在*nix下正常显示"></a>如何让Dos下编写的文件在*nix下正常显示</h4><pre><code>一般DOS的换行符是\r\n(CRLF)，而*nix则是\n(LF)
也就是Ctrl-v Ctrl-l
:%s/^M//g 去除^M，记住^M不是字面上，而是通过输入Ctrl-v enter打出来的
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>这座城市</title>
    <url>/2013/12/15/My-City/</url>
    <content><![CDATA[<h3 id="这座城市"><a href="#这座城市" class="headerlink" title="这座城市"></a>这座城市</h3><p>在成都。我想，看不到月亮，就看看灯光吧。正好住的房间有一扇大大的飘窗，差不多占据了一面墙，静坐在书桌前，稍微抬头就能将天华一路的高楼和街道尽收眼底。白天城市喧嚣，难得闲心看风景，加上连日来的雾霾天气实在影响观赏度，便将这份心情压在心底。倒是今天下起了小雨，稍稍降低了污染指标。在大口呼吸新鲜空气的同时，也便得了几分兴致看起夜景来。</p>
<p>成都的夜景美不美？我倒不敢妄论，只是从高楼一角，小窥城市一隅，斑斑点点的灯火就已经让我目眩了。街道还是白天的街道，人是不见了，只成对的路灯从这边排列到视野尽头，偶尔几辆汽车从尽头那边缓缓行驶过来，慢悠悠地如同冬眠。</p>
<p>夜深了，灯火也开始昏黄。城市开始慢慢地进入一种制衡点，像余音未止的古钟。街道还在有节奏地蠕动，送走疲劳的车和里面的人。一辆咆哮的跑车划过静谧的夜空，也不过是安眠曲里的高音，转瞬即逝。这样的夜晚，真的很适合睡眠。但是总有人不肯入眠。</p>
<p>白天，走过一段泥泞的街旁小道，惊喜的是路上铺满了银杏的落叶。夜雨过后，除了换了新鲜空气，也带来了冬日的冷气，这一年又近年末。脚下踩着松软的落叶，我瞬间明白了隔壁那条街一辆被银杏树叶盖的严严实实的车子的悲惨遭遇，也感受到清洁工阿姨工作的艰辛，更徒然生起一些时光容易把人抛，韶华不为少年留的感觉。</p>
<p>很多人的文章中，我常看到这样的描述：“虽然我已经开始工作了，但是大一的生活还历历在目，恍如昨日”。我也不只一次地听到学长、学姐说出这样的心声——直到我也变成学长，也不能免俗地对学弟、学妹语重心长地劝诫同样的心声。有时候，我们都懂得同样的道理，但总在潜意识里认定特别的自己，最后历尽坎坷，终于成了深沉的学长和学姐。其实，这也没什么大不了，你不可能因为不可信的未来，苛求现在的自己;因为珍惜未来的校园美好回忆，强迫自己喜欢食堂的饭菜;恐惧未来的生活，拼命让现在的自己活得有意义。本来，生活就是不被任何人定义的，你觉得有意义就够了。</p>
<p>远处的灯光卖着萌。高楼顶上忽闪忽闪两盏灯尽力保持着神秘，可叹人类终究还是有了知乎，连电梯为什么没有零层的难题都有近乎真理的答案，你的神秘也就掩耳盗铃铛儿响叮当了，顺带，我替穿红衣帽的白胡子老头向大家祝一句”Merry Christmas”。他老人家忙，铃铛刚被偷了，正在警局备案。</p>
<p>生活是需要回顾的，就好象每次迭代的Retro，做的好的，保持；做的不好，寻找解决方案；有疑问的，提出来。大体遵循这样的模式，你就能持续提高。实习有段时间了，对于成都这座城市，不可谓不熟了。半个来月，交了两三个好友，大家对技术一样狂热；混熟了java大牛级人物郑晔，见识了优秀代码的模样；和PM结对编程，被其高超的前端技术深深折服。也见识了客户的嚣张，感受到了不成长毋宁死的压力。除此之外，几乎每天公司都会组织各种不同主题的session，参与过一些后受益匪浅。还有每周二的Ruby on Rails义梦中国的善举，虽仍未有幸参与其中，但早已心驰神往了。</p>
<p>夜晚很漫长，既然无心睡眠，就操笔书就一篇乱七八糟吧。我如是想，这座城市，是我梦想的起源地……</p>
<p>好梦</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>Geek thought</title>
    <url>/2013/12/13/geeker/</url>
    <content><![CDATA[<h3 id="关于敏捷"><a href="#关于敏捷" class="headerlink" title="关于敏捷"></a>关于敏捷</h3><ol>
<li>我们用TDD的方式验证代码的正确性</li>
<li>用CI验证自己开发的代码对于团队的影响</li>
<li>用迭代的方式快速地实现一部分需求放到相关人那里去验证</li>
<li>用持续交付的做法把实现尽早放到产品环境中去验证</li>
<li>用精益创业的理念把想法放到用户那里去验证</li>
</ol>
<h3 id="一段老手和菜鸟的对话"><a href="#一段老手和菜鸟的对话" class="headerlink" title="一段老手和菜鸟的对话"></a>一段老手和菜鸟的对话</h3><h4 id="关于菜鸟期"><a href="#关于菜鸟期" class="headerlink" title="关于菜鸟期"></a>关于菜鸟期</h4><blockquote>
<p>每位入职的新手都有一段菜鸟期，我可以接受你在这段时期菜鸟的表现<br>你可以在菜鸟期间表现出任何愚蠢的行为，包括问愚蠢的问题<br>不要怕自己的问题愚蠢，不要担心自己因为愚蠢被看低。因为你不在菜鸟<br>期使劲地表现自己的愚蠢，你就没有机会表现了。</p>
</blockquote>
<h4 id="关于时间管理"><a href="#关于时间管理" class="headerlink" title="关于时间管理"></a>关于时间管理</h4><blockquote>
<p>我们的时间都一样，关键在于你怎么把握。我在你娱乐的时间来学习知识，<br>我在你熟睡的时候，起早敲代码、写博客，我把知识积累的优先级排到最高。<br>一切都只在于你，你不成长，不能怪别人，只能怪你自己。</p>
</blockquote>
<h4 id="关于新知识的学习"><a href="#关于新知识的学习" class="headerlink" title="关于新知识的学习"></a>关于新知识的学习</h4><blockquote>
<p>为什么我学得快，你不行？为什么我的代码看起来就是那么漂亮，你不行？<br>这都在于积累，因为我有积累，你没有，你的接收速度就不会快。所以你要积累。</p>
</blockquote>
<h4 id="关于坚持写博客"><a href="#关于坚持写博客" class="headerlink" title="关于坚持写博客"></a>关于坚持写博客</h4><blockquote>
<p>别告诉我你没时间，时间是挤出来的。你说你记了笔记，但是你没有把它用<br>自己的话写成博客，所以那些只是在那里，依旧不是你的。知识得理解了，得会用了，<br>那才是属于你的。</p>
</blockquote>
<h4 id="关于坚持提交代码"><a href="#关于坚持提交代码" class="headerlink" title="关于坚持提交代码"></a>关于坚持提交代码</h4><blockquote>
<p>我把提交代码当作娱乐，更是在突破我的极限。你在自己的舒适区里待久了，就不会有任何提高。<br>所以你必须往前跨一步，逃离自己的舒适区。你已经不是学生了，你不能将自己继续孤立到团队之外，你需要<br>融入办公环境，接触更多的人，让自己不舒服起来。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>geek</tag>
      </tags>
  </entry>
  <entry>
    <title>Build Js backbone with YEOMAN under Ubuntu</title>
    <url>/2013/12/17/yeoman/</url>
    <content><![CDATA[<ol>
<li><p><strong>确认系统中安装了Node.js, Git, 可选安装Ruby和Compass</strong></p>
</li>
<li><p><strong>如果系统未安装Node.js，使用PPA安装Node.js</strong></p>
<blockquote>
<p>sudo apt-get install python-software-properties</p>
</blockquote>
<blockquote>
<p>sudo add-apt-repository ppa:chris-lea&#x2F;node.js</p>
</blockquote>
<blockquote>
<p>sudo apt-get update</p>
</blockquote>
<blockquote>
<p>sudo apt-get install nodejs</p>
</blockquote>
<blockquote>
<p>~$ node –version</p>
</blockquote>
</li>
<li><p><strong>安装npm(Node Package Manager)</strong></p>
<ol>
<li>curl -L <a href="https://npmjs.org/install.sh">https://npmjs.org/install.sh</a> | sudo sh	</li>
<li>$ npm –version</li>
</ol>
</li>
<li><p><strong>安装yo, grunt, bower</strong></p>
<ol>
<li>会自动安装grunt、bower <blockquote>
<p>sudo npm install -g yo</p>
</blockquote>
</li>
<li>为了搭建一个web app，需要<em>web app generator</em>来自动生成<blockquote>
<p>sudo npm install -g generator-webapp</p>
</blockquote>
</li>
<li>搭建web app的骨架, 即目录结构和某些必要的配置文件<blockquote>
<p> yo webapp</p>
</blockquote>
</li>
<li>安装backbone.js，同时将其依赖写入到bower.json中的devDependencies<blockquote>
<p>bower install backbone –save-dev</p>
</blockquote>
</li>
<li>安装underscore.js，backbone依赖之<blockquote>
<p>bower install underscore –save-dev</p>
</blockquote>
</li>
<li>安装require.js<blockquote>
<p>bower install requirejs –save-dev</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>运行 grunt 启动服务</strong></p>
<blockquote>
<p>grunt serve</p>
</blockquote>
<blockquote>
<p>默认浏览器会自动打开，访问localhost:9000</p>
</blockquote>
<blockquote>
<p>控制台会自动打出 ‘Allo, ‘Allo! 字符</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>yeoman</tag>
      </tags>
  </entry>
  <entry>
    <title>Zeal</title>
    <url>/2014/01/01/zeal-api-searing-tool-on-linux/</url>
    <content><![CDATA[<h3 id="introduce"><a href="#introduce" class="headerlink" title="introduce"></a>introduce</h3><ul>
<li>Zeal is a offline API documentation browser for linux, just like Dash on Mac OS X</li>
<li>All documentation available for Dash is also available for Zeal.</li>
</ul>
<h3 id="how-to-install-zeal-on-Ubuntu-linux"><a href="#how-to-install-zeal-on-Ubuntu-linux" class="headerlink" title="how to install zeal on Ubuntu linux"></a>how to install zeal on Ubuntu linux</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-sdk-team/ppa</span><br><span class="line">sudo add-apt-repository ppa:jerzy-kozera/zeal-ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install zeal</span><br></pre></td></tr></table></figure>
<h3 id="Just-like"><a href="#Just-like" class="headerlink" title="Just like"></a>Just like</h3><p><img src="http://i.imgur.com/m2MS8pyh.png" alt="here" title="zeal"></p>
<p>You can click <a href="http://zealdocs.org/">here</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>zeal</tag>
      </tags>
  </entry>
  <entry>
    <title>Basic clojure knowledge</title>
    <url>/2014/01/04/clojure-basic-kownladge/</url>
    <content><![CDATA[<h1 id="Basic-Knowledeg"><a href="#Basic-Knowledeg" class="headerlink" title=" Basic Knowledeg"></a> Basic Knowledeg</h1><h3 id="1-prefix-notation"><a href="#1-prefix-notation" class="headerlink" title="1. prefix notation"></a>1. prefix notation</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(- 3 2 1) ; =&gt; 0</span><br><span class="line">(+ 1 2 3) ; =&gt; 6</span><br><span class="line">(&lt; 1 2 3) ; =&gt; true</span><br><span class="line">(&lt; 1 4 2) ; =&gt; false</span><br></pre></td></tr></table></figure>
<h3 id="2-data-type"><a href="#2-data-type" class="headerlink" title="2. data type"></a>2. data type</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(class 1) ;=&gt; java.lang.Long</span><br><span class="line">(class 1.0) ;=&gt; java.lang.Double</span><br><span class="line">(class true) ;=&gt; java.lang.Boolean</span><br><span class="line">(class &quot;str&quot;) ;=&gt; java.lang.String</span><br><span class="line"></span><br><span class="line">(class (byte 1)) ;=&gt; java.lang.Byte</span><br><span class="line">(class (short 1)) ;=&gt; java.lang.Short</span><br><span class="line">(class (int 1)) ;=&gt; java.lang.Integer</span><br><span class="line">(class (float 1.0)) ;=&gt; java.lang.Float</span><br><span class="line">(class (char &#x27;a&#x27;)) or (class \a) ;=&gt; java.lang.Character</span><br><span class="line"></span><br><span class="line">(class (/ 1 3)) ;=&gt; clojure.lang.Ratio, support lazy evaluating.</span><br><span class="line"></span><br><span class="line">(class 36786883868216818816N) ;=&gt; clojure.lang.BigInt</span><br><span class="line">(class 3.14159265358M) ;=&gt; java.math.BigDecimal</span><br></pre></td></tr></table></figure>
<h3 id="3-expression"><a href="#3-expression" class="headerlink" title="3. expression"></a>3. expression</h3><ul>
<li>if [else]<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if (&lt; 1 2)</span><br><span class="line">	(println &quot;it is true&quot;)</span><br><span class="line">	(println &quot;it is false&quot;)</span><br><span class="line">) ;=&gt; it is true</span><br><span class="line"></span><br><span class="line">(if &quot;&quot;</span><br><span class="line">	(prn &quot;it is true&quot;)) ;=&gt; it is true</span><br><span class="line"></span><br><span class="line">(if 0</span><br><span class="line">	(prn &quot;it is true&quot;)) ;=&gt; it is true</span><br><span class="line"></span><br><span class="line">(if nil</span><br><span class="line">	(prn &quot;it is true&quot;)) ;=&gt; nil!!</span><br></pre></td></tr></table></figure></li>
<li>or&#x2F;and<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(prn (or true false)) ;=&gt; true</span><br><span class="line">(prn (and true false)) ;=&gt; false</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-data-structures"><a href="#4-data-structures" class="headerlink" title="4. data structures"></a>4. data structures</h3><ul>
<li>list<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(list 1 2 3)</span><br><span class="line">`(1 2 3)</span><br><span class="line">;=&gt; (1 2 3)</span><br></pre></td></tr></table></figure></li>
<li>vector<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1 2 3] ;=&gt; [1 2 3]</span><br></pre></td></tr></table></figure></li>
<li>set<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&#123;1 2 3&#125; ;=&gt; #&#123;1 2 3&#125;</span><br></pre></td></tr></table></figure></li>
<li>map<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;:one 1,</span><br><span class="line">:two 2,</span><br><span class="line">:three 3&#125; ;=&gt; &#123;:one 1, :three 3, :two 2&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-operation-on-data-structures"><a href="#5-operation-on-data-structures" class="headerlink" title="5. operation on data structures"></a>5. operation on data structures</h3><ul>
<li>op list (seq access)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def list0 `(1 2 3))</span><br><span class="line">(first list0) ;=&gt; 1</span><br><span class="line">(rest list0) ;=&gt; (2 3)</span><br><span class="line">(last list0) ;=&gt; 3</span><br><span class="line">(cons 0 list0) ;=&gt; (0 1 2 3)</span><br></pre></td></tr></table></figure></li>
<li>op vector (rand access)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def vec0 [4 5 6])</span><br><span class="line">(nth vec0 2) ;=&gt; 6</span><br><span class="line">(vec0 2) ;=&gt; 6, with index.</span><br><span class="line">(concat [1 2 3] vec0) ;=&gt; (1 2 3 4 5 6), it called sequence.</span><br></pre></td></tr></table></figure></li>
<li>op set<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def set0 #&#123;5 7 2 6&#125;)</span><br><span class="line">(count set0) ;=&gt; 4</span><br><span class="line">(set0  2) ;=&gt; 2</span><br></pre></td></tr></table></figure></li>
<li>op map<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def map0 &#123;:one 1, :two 2, :three 3&#125;)</span><br><span class="line">(map0 :one) ;=&gt; 1</span><br><span class="line">(:one map0) ;=&gt; 1</span><br><span class="line">(merge &#123;:four 4&#125; map0) ;=&gt; &#123;:two 2, :three 3, :one 1, :four 4&#125;</span><br><span class="line"></span><br><span class="line">(def map1 (sorted-map 2 :two 1 :one)) ;=&gt; &#123;1 :one, 2 :two&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Clojure</category>
      </categories>
      <tags>
        <tag>language</tag>
      </tags>
  </entry>
  <entry>
    <title>Login shell vs Interactive Shell</title>
    <url>/2014/01/15/login-and-interactive-shell/</url>
    <content><![CDATA[<p>###Bash - login-sh &amp; interactive-sh</p>
<h4 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h4><ul>
<li>what is login shell?<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $0</span><br><span class="line">&gt; -bash (prefix should be &#x27;-&#x27;, this mean bash is login shell)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="interactive-shell"><a href="#interactive-shell" class="headerlink" title="interactive shell"></a>interactive shell</h4><ul>
<li>what is interactive shell?<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $-</span><br><span class="line">&gt; 569JNRTXZghilms (you can see &#x27;i&#x27;, that means it is interactive shell)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="the-defference-between-the-two-shells"><a href="#the-defference-between-the-two-shells" class="headerlink" title="the defference between the two shells?"></a>the defference between the two shells?</h4><p>the order of loading profile</p>
<ul>
<li>login shell<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/profile</span><br><span class="line">~/.bash_profile</span><br><span class="line">~/.profile</span><br></pre></td></tr></table></figure></li>
<li>interactive shell<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/bash.bashrc</span><br><span class="line">~/.bashrc</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="why-can-I-load-bashrc-on-Ubuntu-linux"><a href="#why-can-I-load-bashrc-on-Ubuntu-linux" class="headerlink" title="why can I load .bashrc on Ubuntu linux?"></a>why can I load .bashrc on Ubuntu linux?</h4><p><em>because</em> in ~&#x2F;.profile also <em>source</em> the .bashrc</p>
<h4 id="what-kind-of-shell-is-neither-login-sh-nor-interactive-sh"><a href="#what-kind-of-shell-is-neither-login-sh-nor-interactive-sh" class="headerlink" title="what kind of shell is neither login-sh nor interactive-sh"></a>what kind of shell is neither login-sh nor interactive-sh</h4><p>shell run in the command scripts.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate Many-To-One with Secondary Tables</title>
    <url>/2013/12/20/hibernate-many-to-one-with-secondary-tables/</url>
    <content><![CDATA[<h3 id="Hibernate-Secondary-Tables"><a href="#Hibernate-Secondary-Tables" class="headerlink" title="Hibernate Secondary Tables"></a>Hibernate Secondary Tables</h3><ol>
<li>Hibernate Secondary Table的应用场景</li>
</ol>
<hr>
<blockquote>
<p>两张表有外键关联，主要应用于One-To-One或Many-To-One的两张表之间。</p>
</blockquote>
<blockquote>
<p>比如，以Many-To-One为例：</p>
</blockquote>
<blockquote>
<p>表一:</p>
</blockquote>
<pre><code>CREATE TABLE Person (
    id INT NOT NULL PRIMARY KEY,
    parent_id INT,
    num INT NOT NULL
);
</code></pre>
<blockquote>
<p>表二:</p>
</blockquote>
<pre><code>CREATE TABLE Name (
   id INT NOT NULL PRIMARY KEY,
   name VARCHAR(20) NOT NULL,
   person_id INT NOT NULL,
   FOREIGN KEY(person_id) REFERENCES Person(id)
);
</code></pre>
<ol start="2">
<li>对应的映射实体</li>
</ol>
<hr>
<blockquote>
</blockquote>
<pre><code>@Entity
@Table(name = &quot;Person&quot;)
@SecondaryTable(name = &quot;Name&quot;, 
pkJoinColumns=&#123; @PrimaryKeyJoinColumn(name=&quot;id&quot;, referencedColumnName=&quot;person_id&quot;) )
public class Person &#123;
   @Id
   @GeneratedValue(strategy = GenerationType.AUTO)
   @Column(name = &quot;id&quot;)
   private int id;
</code></pre>
<blockquote>
<pre><code>   @Column(name = &quot;num&quot;, nullable = false)
   private int num;
 
   @Column(name = &quot;parent_id&quot;, nullable = false)
   private Person parent;
 
   @Column(name = &quot;name&quot;, table = &quot;Name&quot;)
   private String name;
&#125;
</code></pre>
</blockquote>
<ol start="3">
<li>业务需求</li>
</ol>
<hr>
<blockquote>
<p>*<em>现在要求查询固定的num&#x3D;<em>123</em>下所有的孩子中名字叫做name&#x3D;<em>english_name</em>的人（注意这里的num不是主键，但是唯一标识这个人)</em>*</p>
</blockquote>
<blockquote>
<p>我们很轻易地写出下面这样的语句</p>
</blockquote>
<pre><code>SELECT a FROM person a WHERE a.parent.num=&#39;123&#39; AND a.name=&#39;english_name&#39;;
</code></pre>
<blockquote>
<p>但是结果出乎我们意料，假如这里我们的Name表中每个人都对应<em>中文名</em>,<em>english_name</em>，<em>japanese_name</em>，那么返回的就是连续的3组含有<em>english_name</em>的记录。</p>
</blockquote>
<blockquote>
<p>这个显然不符合我们的要求,那么到底什么地方出了错误呢？</p>
</blockquote>
<blockquote>
<p>我首先想到的解决方案是</p>
</blockquote>
<pre><code>SELECT DISTINCT(a) FROM person a WHERE a.parent.num=&#39;123&#39; AND a.name=&#39;english_name&#39;;
</code></pre>
<blockquote>
<p>添加了DISTINCT。此时，返回的结果果然正确。但是这不符合我的直觉，试想想每次平白无故地拿回许多不需要的数据，最后还要进行筛选，实在得不偿失。</p>
</blockquote>
<ul>
<li>由于我选择的ORM框架是Hibernate，这其中有一个好处就是可以直接打印发送给数据库服务器的SQL语句。没有办法，为了解原因所在，不得不动手分析起万恶的SQL语句。<blockquote>
<p>语句是这样的，为了可读，我对Hibernate生成的SQL语句进行了一些调整,结构没有改变。</p>
</blockquote>
  select<br>  person_A.id as ID,<br>  person_A.num as NUM,<br>  person_A.parent_id as PARENT,<br>  name_A.name as NAME<br>  from<br>  Person person_A<br>  left outer join<br>  Name name_A<br>      on person_A.ID&#x3D;name_A.person_id cross<br>  join<br>  Person person_B<br>  left outer join<br>  Name name_B<br>      on person_B.id&#x3D;name_B.person_id<br>  where<br>  person_A.parent_id&#x3D;person_B.id<br>  and person_B.num&#x3D;123<br>  and name_B.name&#x3D;’english_name’</li>
</ul>
<blockquote>
<p>起初，我以为是cross join的问题，cross join顾名思义，就是著名的笛卡尔乘积，即叉乘。但是cross join在这里的作用不过是一个<strong>逗号</strong>。<br>这样的语句就和我们熟悉的联合两张表来查是一样的了。<br>举个例子， 即</p>
</blockquote>
<pre><code>SELECT * FROM A, B WHERE A.ID=B.a_id AND B.num=222;
</code></pre>
<blockquote>
<p>因为有了B.num&#x3D;222和A.Id&#x3D;B.a_id的限制，就不会有叉乘的结果出现。</p>
</blockquote>
<ul>
<li>那么为什么会出3组重复的数据呢？<blockquote>
<p>进一步分析，我发现where子句中</p>
</blockquote>
  person_A.parent_id&#x3D;person_B.id<br>  and person_B.num&#x3D;123 <blockquote>
<p>已经限定了person_A的父Id，但是最重要的是，该父Id在两张联合表中不是唯一的！它对应了3条不同记录，这3条记录中的name字段取值不同。<br>明确这点，我又进一步分析得出<br>3条不同的父Id记录，分别派生出3组不同的子记录群，每组中的每条记录也不是唯一的，它们一样对应3种不同的名字。<br>最后，分析where子句限定</p>
</blockquote>
  and name_B.name&#x3D;’english_name’<blockquote>
<p>这条语句不过是将每组中名字是english_name的字段取出来，取出来的记录仍然是3组重复的记录。<br>所以得出的结果是必然的。</p>
</blockquote>
</li>
</ul>
<ol start="4">
<li>解决方案</li>
</ol>
<hr>
<blockquote>
<p>仔细分析之后我发现，其实只需要将限定person_A的Parent Person的名字先限制在<strong>english_name</strong>上，那么这样的Parent Person就是唯一的。通过这个唯一的Parent Person，就会得到了一组子记录，它们的名字还是会有不同（对应各自的中文名，英文名或者日文名），这样的结果还不是我所期望的，所以更进一步，我将这样一组子记录的名字也限定在<strong>english_name</strong>上。那么查出的结果就是唯一的了。</p>
</blockquote>
<pre><code>SELECT a FROM person a WHERE a.parent.num=&#39;123&#39; AND 
a.parent.name = &#39;english_name&#39; AND a.name = &#39;english_name&#39;;
</code></pre>
<blockquote>
<p>以上就是我解决整个问题的过程。</p>
</blockquote>
<ol start="5">
<li>总结</li>
</ol>
<hr>
<blockquote>
<p>任何问题都有解决方案</p>
</blockquote>
<blockquote>
<p>不要想当然认为工具会按照你的想法去工作</p>
</blockquote>
<blockquote>
<p>SQL万恶，但是不熟悉它，你的代码会更邪恶。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle auto-generate java project</title>
    <url>/2014/01/02/gradle-gen-project/</url>
    <content><![CDATA[<p>##How to generate java project with gradle</p>
<h3 id="gradle1-7"><a href="#gradle1-7" class="headerlink" title="gradle1.7"></a>gradle1.7</h3><p>Contains the build-setup plugin, supports declaring project type when setting up a build.</p>
<ul>
<li><strong>task-type</strong><ul>
<li>SetupBuild</li>
</ul>
</li>
<li><strong>plugin</strong><ul>
<li>build-setup</li>
</ul>
</li>
<li><strong>task</strong><ul>
<li>buildSetup</li>
</ul>
</li>
</ul>
<p>so, you can type</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle setupBuild --type java-library</span><br></pre></td></tr></table></figure>

<h3 id="gradle1-9"><a href="#gradle1-9" class="headerlink" title="gradle1.9"></a>gradle1.9</h3><ul>
<li><p><strong>task-type</strong></p>
<ul>
<li>SetupBuild -&gt; InitBuild</li>
</ul>
</li>
<li><p><strong>plugin</strong></p>
<ul>
<li>build-setup -&gt; build-init</li>
</ul>
</li>
<li><p><strong>task</strong></p>
<ul>
<li>buildSetup -&gt; init</li>
</ul>
</li>
</ul>
<h3 id="init-project-on-gradle-1-9-or-more-greater"><a href="#init-project-on-gradle-1-9-or-more-greater" class="headerlink" title="init project on gradle 1.9 or more greater"></a>init project on gradle 1.9 or more greater</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle init --type [java-library | scala-library | groovy-library | basic | pom]</span><br><span class="line">gradle1.10 support *gradle help --task init* to show task usage details</span><br></pre></td></tr></table></figure>

<p><img src="http://img.blog.csdn.net/20140101234320859" alt="skeleton of java project" title="java project skeleton"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>How to install mysql with vagrant</title>
    <url>/2014/05/16/vagrant-mysql/</url>
    <content><![CDATA[<h3 id="修改Vagrantfile"><a href="#修改Vagrantfile" class="headerlink" title="修改Vagrantfile"></a>修改Vagrantfile</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把客户机器（ubuntu）的port 3306 映射到宿主机器上的port 3306</span><br><span class="line">config.vm.network :forwarded_port, guest: 3306, host: 3306</span><br><span class="line"></span><br><span class="line"># 执行安装程序</span><br><span class="line">config.vm.provision :shell :path =&gt; &quot;install_mysql.sh&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="mysql安装程序"><a href="#mysql安装程序" class="headerlink" title="mysql安装程序"></a>mysql安装程序</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;Setup mysql-server-5.5 if not exists..&quot;</span><br><span class="line">sudo debconf-set-selections &lt;&lt;&lt; &#x27;mysql-server-5.5</span><br><span class="line">mysql-server/root_password password root&#x27;</span><br><span class="line">sudo debconf-set-selections &lt;&lt;&lt; &#x27;mysql-server-5.5</span><br><span class="line">mysql-server/root_password_again password root&#x27;</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install mysql-server-5.5</span><br><span class="line"></span><br><span class="line">if [ ! -f /var/log/databasesetup ];</span><br><span class="line">then</span><br><span class="line">	echo &quot;CREATE USER &#x27;codeeker&#x27; IDENTIFIED BY &#x27;codeeker&#x27;&quot; | mysql -uroot -proot</span><br><span class="line">	echo &quot;CREATE DATABASE mall&quot; | mysql -uroot -proot</span><br><span class="line">	echo &quot;GRANT ALL ON mall.* TO &#x27;codeeker&#x27;@&#x27;%&#x27;&quot; | mysql -uroot -proot</span><br><span class="line">	echo &quot;flush privileges&quot; | mysql -uroot -proot</span><br><span class="line"></span><br><span class="line">	touch /var/log/databasesetup #为了不重复执行创建用户的操作</span><br><span class="line"></span><br><span class="line">	if [ -f /vagrant/data/initial.sql ];</span><br><span class="line">	then</span><br><span class="line">			mysql -uroot -proot codeeker &lt; /vagrant/data/initial.sql</span><br><span class="line">	fi</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><h4 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h4><ul>
<li>报错误<code>Lost connection to MySQL server at &#39;reading initial communication packet&#39;, system error: 0</code></li>
<li>原因是 &#x2F;etc&#x2F;mysql&#x2F;my.cnf中有<code>bind-address = 127.0.0.1</code>，会拒绝非localhost的访问，包括vagrant映射port到的宿主主机上</li>
<li>解决的方法是修改<code>bind-address = 0.0.0.0</code>，表示接受本网络中所有的ip登录</li>
</ul>
<h4 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h4><p><code>echo &quot;CREATE USER &#39;codeeker&#39; IDENTIFIED BY &#39;codeeker&#39;&quot; | mysql -uroot -proot</code></p>
<p>如果写成了</p>
<p><code>echo &quot;CREATE USER &#39;codeeker&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;codeeker&#39;&quot; | mysql -uroot -proot</code></p>
<p>那么在宿主的机器上，会报<code>access deny</code>错误。</p>
<ul>
<li>原因是这样创建的用户，只能在localhost上登录</li>
<li>解决的方法是去掉<code>@&#39;localhost&#39;</code></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell技巧</title>
    <url>/2014/02/06/usable-shell-knowledge/</url>
    <content><![CDATA[<h1 id="Shell-Skills"><a href="#Shell-Skills" class="headerlink" title="Shell Skills"></a>Shell Skills</h1><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo !!"></a>sudo !!</h4><pre><code>以root的身份执行上一条命令 。
场景举例：比如Ubuntu里用apt-get安装软件包的时候是需要root身份的，我们经常会忘记在apt-get前加sudo。每次不得不加上sudo再重新键入这行命令，这时可以很方便的用sudo !!完事。
（在shell下，有时候你会输入很长的命令，你可以使用!xxx来重复最近的一次命令，比如，你以前输入过，vi /where/the/file/is, 下次你可以使用 !vi 重得上次最近一次的vi命令。）
</code></pre>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd -"></a>cd -</h4><pre><code>回到上一次的目录 。
场景举例：当前目录为/home/a，用cd ../b切换到/home/b。这时可以通过反复执行cd -命令在/home/a和/home/b之间来回方便的切换。
（cd ~ 是回到自己的Home目录，cd ~username，是进入某个用户的Home目录）
</code></pre>
<h4 id="‘ALT-’-or-‘-’"><a href="#‘ALT-’-or-‘-’" class="headerlink" title="‘ALT+.’ or ‘ .’"></a>‘ALT+.’ or ‘<ESC> .’</h4><pre><code>热建alt+. 或 esc+. 可以把上次命令行的参数重复出来,有点像!$，但是它只会在当前行出现，而不会想!$在下一行将命令展开以补全。
</code></pre>
<h4 id="old-new"><a href="#old-new" class="headerlink" title="^old^new"></a>^old^new</h4><pre><code>替换前一条命令里的部分字符串。
场景：echo &quot;wanderful&quot;，其实是想输出echo &quot;wonderful&quot;。只需要^a^o就行了，对很长的命令的错误拼写有很大的帮助。（陈皓注：也可以使用 !!:gs/old/new）
eg:
&gt; echo &quot;wanderful&quot;
&gt; ^a^o
&gt; echo &quot;wonderful&quot; (*auto popup*)
</code></pre>
<h4 id="w-sudo-tee"><a href="#w-sudo-tee" class="headerlink" title="w !sudo tee %"></a>w !sudo tee %</h4><pre><code>在vi中保存一个只有root可以写的文件
</code></pre>
<h4 id="file-txt"><a href="#file-txt" class="headerlink" title="&gt; file.txt"></a>&gt; file.txt</h4><pre><code>创建一个空文件，比touch短。
</code></pre>
<h4 id="ps-aux-sort-nk-4-tail"><a href="#ps-aux-sort-nk-4-tail" class="headerlink" title="ps aux | sort -nk +4 | tail"></a>ps aux | sort -nk +4 | tail</h4><pre><code>列出头十个最耗内存的进程
</code></pre>
<h4 id="ctrl-x-e"><a href="#ctrl-x-e" class="headerlink" title="ctrl-x e"></a>ctrl-x e</h4><pre><code>快速启动你的默认编辑器（由变量$EDITOR设置）。
</code></pre>
<h4 id="python-m-SimpleHTTPServer"><a href="#python-m-SimpleHTTPServer" class="headerlink" title="python -m SimpleHTTPServer"></a>python -m SimpleHTTPServer</h4><pre><code>一句话实现一个HTTP服务，把当前目录设为HTTP服务目录，可以通过http://localhost:8000访问 这也许是这个星球上最简单的HTTP服务器的实现了。
</code></pre>
<h4 id="man-ascii"><a href="#man-ascii" class="headerlink" title="man ascii"></a>man ascii</h4><pre><code>显示ascii码表。
</code></pre>
<h4 id="ssh-user-server-bash-path-to-local-script-sh"><a href="#ssh-user-server-bash-path-to-local-script-sh" class="headerlink" title="ssh user@server bash &lt; &#x2F;path&#x2F;to&#x2F;local&#x2F;script.sh"></a>ssh user@server bash &lt; &#x2F;path&#x2F;to&#x2F;local&#x2F;script.sh</h4><pre><code>在远程机器上运行一段脚本。这条命令最大的好处就是不用把脚本拷到远程机器上。
</code></pre>
<h4 id="du-s-sort-n-tail"><a href="#du-s-sort-n-tail" class="headerlink" title="du -s * | sort -n | tail"></a>du -s * | sort -n | tail</h4><pre><code>列出当前目录里最大的10个文件。
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Custom Oh-my-zsh theme to support svn</title>
    <url>/2014/07/05/custom-oh-my-zsh-theme-to-support-svn/</url>
    <content><![CDATA[<ol>
<li><p>Find your theme file in ~&#x2F;.oh-my-zsh&#x2F;themes&#x2F;, then edit it;</p>
</li>
<li><p>Add <code>local svn_info=&#39;$(svn_prompt_info)&#39;</code>;</p>
</li>
<li><p>Append <code>%&#123;$reset_color%&#125;$&#123;svn_info&#125;</code> to Prompt variable;</p>
</li>
<li><p>Add followings to END-OF-FILE.</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZSH_THEME_SVN_PROMPT_PREFIX=&quot;%&#123;$fg_bold[blue]%&#125;svn:(&quot;</span><br><span class="line">ZSH_THEME_SVN_PROMPT_SUFFIX=&quot;%&#123;$fg_bold[blue]%&#125;)&quot;</span><br><span class="line">ZSH_THEME_SVN_PROMPT_DIRTY=&quot;%&#123;$fg[red]%&#125; ✘ %&#123;$reset_color%&#125;&quot;</span><br><span class="line">ZSH_THEME_SVN_PROMPT_CLEAN=&quot;%&#123;$FG[040]%&#125; ✔&quot;</span><br></pre></td></tr></table></figure>
<h3 id="And-you-can-refer-the-theme-awesomepanda"><a href="#And-you-can-refer-the-theme-awesomepanda" class="headerlink" title="And you can refer the theme (awesomepanda)"></a>And you can refer the theme <em>(awesomepanda)</em></h3>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>绵阳夜雨</title>
    <url>/2014/05/14/night-rain-in-Mianyang/</url>
    <content><![CDATA[<p>灯火比白昼柔和</p>
<p>我的影子比夜长</p>
<p>也比夜凉</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>poetry</tag>
      </tags>
  </entry>
  <entry>
    <title>Powerful sublime text3 plugins</title>
    <url>/2014/07/06/sublime-plugins-install/</url>
    <content><![CDATA[<h2 id="Sublime-Text3-Plugins"><a href="#Sublime-Text3-Plugins" class="headerlink" title="Sublime Text3 Plugins"></a>Sublime Text3 Plugins</h2><h3 id="jshint-for-sublime-installation"><a href="#jshint-for-sublime-installation" class="headerlink" title="jshint for sublime installation"></a>jshint for sublime installation</h3><ol>
<li>brew install nodejs</li>
<li>npm install -g jshint</li>
<li>open sublime &amp; package control install jshint</li>
<li>that’s ok</li>
</ol>
<hr>
<h3 id="install-SublimeOnSaveBuild"><a href="#install-SublimeOnSaveBuild" class="headerlink" title="install SublimeOnSaveBuild"></a>install SublimeOnSaveBuild</h3><ol>
<li>open sublime &amp; package control install SublimeOnSaveBuild</li>
<li>that will build jshint once save</li>
</ol>
<hr>
<h3 id="expand-region"><a href="#expand-region" class="headerlink" title="expand region"></a>expand region</h3><ol>
<li>open sublime &amp; package control install Expand_region</li>
<li>change the default-keymap<br>{ “keys”: [“super+w”], “command”: “expand_region”}</li>
</ol>
<hr>
<h3 id="jshint-gutter"><a href="#jshint-gutter" class="headerlink" title="jshint gutter"></a>jshint gutter</h3><ol>
<li>open sublime &amp; package control install jshint gutter</li>
<li>ctrl+shit+j to lint code!</li>
</ol>
<hr>
<h3 id="PackageResourceViewer"><a href="#PackageResourceViewer" class="headerlink" title="PackageResourceViewer"></a>PackageResourceViewer</h3><ol>
<li>install PackageResourceViewer by package control</li>
<li>ctrl+shift+p to use ‘open resource’</li>
<li>find tm.theme, then add something end</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dict&gt;</span><br><span class="line">           &lt;key&gt;name&lt;/key&gt;</span><br><span class="line">           &lt;string&gt;Bracket Curly&lt;/string&gt;</span><br><span class="line">           &lt;key&gt;scope&lt;/key&gt;</span><br><span class="line">           &lt;string&gt;brackethighlighter.curly&lt;/string&gt;</span><br><span class="line">           &lt;key&gt;settings&lt;/key&gt;</span><br><span class="line">           &lt;dict&gt;</span><br><span class="line">               &lt;key&gt;foreground&lt;/key&gt;</span><br><span class="line">               &lt;string&gt;#CC99CC&lt;/string&gt;</span><br><span class="line">           &lt;/dict&gt;</span><br><span class="line">       &lt;/dict&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="BracketHighter"><a href="#BracketHighter" class="headerlink" title="BracketHighter"></a>BracketHighter</h3><ol>
<li>must have packageresourceviewer at first</li>
<li>clear the annotation of color, and then save</li>
</ol>
<h3 id="Trailing-Spaces"><a href="#Trailing-Spaces" class="headerlink" title="Trailing Spaces"></a>Trailing Spaces</h3><ol>
<li>install Trailing Spaces by package control</li>
<li>configure keymap</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;command&quot;: &quot;toggle_trailing_spaces&quot;,</span><br><span class="line">        &quot;keys&quot;: [</span><br><span class="line">            &quot;ctrl+shift+d&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;command&quot;: &quot;delete_trailing_spaces&quot;,</span><br><span class="line">        &quot;keys&quot;: [</span><br><span class="line">            &quot;ctrl+shift+t&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>configure trailing_spaces.sublime-settings</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## color: invaild, comment, error</span><br><span class="line">&#123;</span><br><span class="line">	&quot;trailing_spaces_highlight_color&quot;: &quot;comment&quot;,</span><br><span class="line">	&quot;trailing_spaces_trim_on_save&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Centurion-theme"><a href="#Centurion-theme" class="headerlink" title="Centurion theme"></a>Centurion theme</h3><ol>
<li>install theme Centurion first,</li>
<li>open Preferences-&gt;Settings - User,</li>
<li>insert <code>&#123;&quot;theme&quot;: &quot;Centurion.sublime-theme&quot;&#125;</code>,</li>
<li>every time, subl3 use .sublime-theme as suffix.</li>
</ol>
<hr>
<h3 id="install-SyncedSideBar-keep-sync-between-sidebar-and-opening-file"><a href="#install-SyncedSideBar-keep-sync-between-sidebar-and-opening-file" class="headerlink" title="install SyncedSideBar (keep sync between sidebar and opening file)"></a>install SyncedSideBar (keep sync between sidebar and opening file)</h3><ol>
<li>install SyncedSideBar,</li>
<li>open Preference-&gt;Key Bindings - User,</li>
<li>configure keymap</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;command&quot;: &quot;reveal_in_side_bar&quot;,</span><br><span class="line">      &quot;keys&quot;: [&quot;alt+f1&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>Rake version conflicts</title>
    <url>/2014/07/05/rake-version-conflicts-and-chiness-support-for-generating-octopress/</url>
    <content><![CDATA[<h3 id="Rake-Version-Conflicts"><a href="#Rake-Version-Conflicts" class="headerlink" title="Rake Version Conflicts"></a>Rake Version Conflicts</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bundle exec rake CMD.</span><br></pre></td></tr></table></figure>

<h3 id="Invalid-byte-sequence-in-US-ASCII"><a href="#Invalid-byte-sequence-in-US-ASCII" class="headerlink" title="Invalid byte sequence in US-ASCII"></a>Invalid byte sequence in US-ASCII</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*Excpetion*</span><br><span class="line">bundle exec rake generate</span><br><span class="line">(in /Users/qianyan/Dropbox/octopress)</span><br><span class="line">Generating Site with Jekyll</span><br><span class="line">identical source/stylesheets/screen.css</span><br><span class="line">Configuration from /Users/qianyan/Dropbox/octopress/_config.yml</span><br><span class="line">Building site: source -&gt; public</span><br><span class="line">YAML Exception reading 2013-12-10-hello-world.markdown: invalid byte sequence in US-ASCII</span><br></pre></td></tr></table></figure>
<h3 id="Resolve-this-problem"><a href="#Resolve-this-problem" class="headerlink" title="Resolve this problem"></a>Resolve this problem</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; vim ~/.zshrc</span><br><span class="line">export LC_ALL=en_US.UTF-8</span><br><span class="line">export LANG=en_US.UTF-8</span><br><span class="line">&gt; source ~/.zshrc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>rake</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL乱码及解决方案</title>
    <url>/2014/09/21/mysql-mess-encoding/</url>
    <content><![CDATA[<h2 id="Mysql-5-5-CharacterSet-Configuration"><a href="#Mysql-5-5-CharacterSet-Configuration" class="headerlink" title="Mysql 5.5 CharacterSet Configuration"></a>Mysql 5.5 CharacterSet Configuration</h2><h3 id="Client-Configuration"><a href="#Client-Configuration" class="headerlink" title="Client Configuration"></a>Client Configuration</h3><ul>
<li>#1 No need to restart server for setting client</li>
</ul>
<p><strong>When</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set = utf8</span><br></pre></td></tr></table></figure>
<p><strong>Then</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql  Ver 14.14 Distrib 5.5.38, for debian-linux-gnu (x86_64) using readline 6.2</span><br><span class="line"></span><br><span class="line">Connection id:		40</span><br><span class="line">Current database:</span><br><span class="line">Current user:		root@localhost</span><br><span class="line">SSL:			Not in use</span><br><span class="line">Current pager:		stdout</span><br><span class="line">Using outfile:		&#x27;&#x27;</span><br><span class="line">Using delimiter:	;</span><br><span class="line">Server version:		5.5.38-0ubuntu0.12.04.1 (Ubuntu)</span><br><span class="line">Protocol version:	10</span><br><span class="line">Connection:		Localhost via UNIX socket</span><br><span class="line">Server characterset:	latin1</span><br><span class="line">Db     characterset:	latin1</span><br><span class="line">Client characterset:	utf8</span><br><span class="line">Conn.  characterset:	utf8</span><br></pre></td></tr></table></figure>
<ul>
<li>#2 It will change <code>character_set_client &amp; character_set_connection &amp; character_set_results</code> without client’s setting.</li>
</ul>
<p><strong>When</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">#default-character-set = utf8</span><br></pre></td></tr></table></figure>
<p><strong>Then</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection id:		37</span><br><span class="line">Current database:	mall</span><br><span class="line">Current user:		root@localhost</span><br><span class="line">SSL:			Not in use</span><br><span class="line">Current pager:		stdout</span><br><span class="line">Using outfile:		&#x27;&#x27;</span><br><span class="line">Using delimiter:	;</span><br><span class="line">Server version:		5.5.38-0ubuntu0.12.04.1 (Ubuntu)</span><br><span class="line">Protocol version:	10</span><br><span class="line">Connection:		Localhost via UNIX socket</span><br><span class="line">Server characterset:	utf8</span><br><span class="line">Db     characterset:	utf8</span><br><span class="line">Client characterset:	latin1</span><br><span class="line">Conn.  characterset:	latin1</span><br><span class="line">UNIX socket:		/var/run/mysqld/mysqld.sock</span><br><span class="line">Uptime:			14 min 4 sec</span><br></pre></td></tr></table></figure>
<p><strong>And Then</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For a special DB.</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | latin1                     |</span><br><span class="line">| character_set_connection | latin1                     |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | latin1                     |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="Server-Configuration"><a href="#Server-Configuration" class="headerlink" title="Server Configuration"></a>Server Configuration</h3><ul>
<li>#1 Restart mysql server without <em>character-set-server&#x3D;utf8</em></li>
</ul>
<p><strong>When</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#character-set-server=utf8</span><br></pre></td></tr></table></figure>
<p><strong>Then</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql  Ver 14.14 Distrib 5.5.38, for debian-linux-gnu (x86_64) using readline 6.2</span><br><span class="line"></span><br><span class="line">Connection id:		42</span><br><span class="line">Current database:</span><br><span class="line">Current user:		root@localhost</span><br><span class="line">SSL:			Not in use</span><br><span class="line">Current pager:		stdout</span><br><span class="line">Using outfile:		&#x27;&#x27;</span><br><span class="line">Using delimiter:	;</span><br><span class="line">Server version:		5.5.38-0ubuntu0.12.04.1 (Ubuntu)</span><br><span class="line">Protocol version:	10</span><br><span class="line">Connection:		Localhost via UNIX socket</span><br><span class="line">Server characterset:	latin1</span><br><span class="line">Db     characterset:	latin1</span><br><span class="line">Client characterset:	utf8</span><br><span class="line">Conn.  characterset:	utf8</span><br><span class="line">UNIX socket:		/var/run/mysqld/mysqld.sock</span><br><span class="line">Uptime:			8 min 47 sec</span><br></pre></td></tr></table></figure>
<ul>
<li>#2 Create a new database <em>newa</em> without <em>character-set-server&#x3D;utf8</em></li>
</ul>
<p><strong>When</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># character-set-server=utf8</span><br></pre></td></tr></table></figure>
<p><strong>Then</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection id:		36</span><br><span class="line">Current database:	newa</span><br><span class="line">Current user:		root@localhost</span><br><span class="line">SSL:			Not in use</span><br><span class="line">Current pager:		stdout</span><br><span class="line">Using outfile:		&#x27;&#x27;</span><br><span class="line">Using delimiter:	;</span><br><span class="line">Server version:		5.5.38-0ubuntu0.12.04.1 (Ubuntu)</span><br><span class="line">Protocol version:	10</span><br><span class="line">Connection:		Localhost via UNIX socket</span><br><span class="line">Server characterset:	utf8</span><br><span class="line">Db     characterset:	latin1</span><br><span class="line">Client characterset:	utf8</span><br><span class="line">Conn.  characterset:	utf8</span><br><span class="line">UNIX socket:		/var/run/mysqld/mysqld.sock</span><br><span class="line">Uptime:			12 sec</span><br></pre></td></tr></table></figure>
<ul>
<li>#3 Restart server with <em>character-set-server&#x3D;utf8</em></li>
</ul>
<p><strong>When</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br></pre></td></tr></table></figure>
<p><strong>Then</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection id:		38</span><br><span class="line">Current database:</span><br><span class="line">Current user:		root@localhost</span><br><span class="line">SSL:			Not in use</span><br><span class="line">Current pager:		stdout</span><br><span class="line">Using outfile:		&#x27;&#x27;</span><br><span class="line">Using delimiter:	;</span><br><span class="line">Server version:		5.5.38-0ubuntu0.12.04.1 (Ubuntu)</span><br><span class="line">Protocol version:	10</span><br><span class="line">Connection:		Localhost via UNIX socket</span><br><span class="line">Server characterset:	utf8</span><br><span class="line">Db     characterset:	utf8</span><br><span class="line">Client characterset:	utf8</span><br><span class="line">Conn.  characterset:	utf8</span><br><span class="line">UNIX socket:		/var/run/mysqld/mysqld.sock</span><br><span class="line">Uptime:			23 min 46 sec</span><br></pre></td></tr></table></figure>
<p><strong>But For <em>newa</em> DB</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CConnection id:		38</span><br><span class="line">Current database:	newa</span><br><span class="line">Current user:		root@localhost</span><br><span class="line">SSL:			Not in use</span><br><span class="line">Current pager:		stdout</span><br><span class="line">Using outfile:		&#x27;&#x27;</span><br><span class="line">Using delimiter:	;</span><br><span class="line">Server version:		5.5.38-0ubuntu0.12.04.1 (Ubuntu)</span><br><span class="line">Protocol version:	10</span><br><span class="line">Connection:		Localhost via UNIX socket</span><br><span class="line">Server characterset:	utf8</span><br><span class="line">Db     characterset:	***latin1***</span><br><span class="line">Client characterset:	utf8</span><br><span class="line">Conn.  characterset:	utf8</span><br><span class="line">UNIX socket:		/var/run/mysqld/mysqld.sock</span><br><span class="line">Uptime:			22 min 36 sec</span><br></pre></td></tr></table></figure>
<p><strong>So That Means</strong></p>
<blockquote>
</blockquote>
<p>The character set used by the default database. The server sets this variable whenever the default database changes. If there is no default database, the variable has the same value as character_set_server.</p>
<h3 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h3><ul>
<li><p>For client, connection, results, you should add<br><code>[client] default-character-set = utf8</code></p>
</li>
<li><p>For server and DB, you should add<br><code>[mysqld] character-set-server=utf8</code></p>
</li>
<li><p>You should drop original DB when created in error character set, just like <em>newa</em> DB</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>从OO到AOP再到FP</title>
    <url>/2014/09/22/cong-oodao-aopzai-dao-fp/</url>
    <content><![CDATA[<h3 id="我的疑问"><a href="#我的疑问" class="headerlink" title="我的疑问"></a>我的疑问</h3><hr>
<h4 id="面向对象编程和函数式编程的最大不同点在什么地方？"><a href="#面向对象编程和函数式编程的最大不同点在什么地方？" class="headerlink" title="面向对象编程和函数式编程的最大不同点在什么地方？"></a>面向对象编程和函数式编程的最大不同点在什么地方？</h4><ul>
<li><p>数据从何而来？面向对象编程中的数据都是对象本身产生的，也就是说对象的基础建立在它本身的属性上，没有属性，那么这个对象什么都不能做。函数式（闭包）的过程数据来自于外部，也就是说闭包本身是不维护数据的。这样的好处是只管逻辑，而不用维护数据本身复杂的状态。</p>
</li>
<li><p>数据的状态如何？面向对象编程中数据（也就是属性）是可以改变的，而函数式中数据是不可以改变的。</p>
</li>
<li><p>没有属性的对象，还是面向对象嘛？我认为controller, service, DAO(repository)其实都是没有数据的对象！也就是说这些分层结构其实都是函数式编程可以应用的地方。有人会说奇怪了，controller中明明有service属性，service中明明有DAO属性啊，怎么能说没有数据呢？其实，这个只是调用链（我喜欢把它们看作是filter），真正的数据（大概被称为model）是被一层层传递下去的。可能又有人会反驳，函数式中最大的特点就是数据不可变，这些真正的数据（model）在传递过程中其实是会被改变的，所以怎么能说这些地方可以应用函数式编程？我认为，这些数据在各个层上应该是不同类的。展现给view的，和存储到database中的model是很难相同的，所以也就存在一种模型之间转化的可能，一个模型变成另一个新的模型，模型本身是不会变的。</p>
</li>
<li><p>没有方法的值对象呢？就是数据吧。</p>
</li>
</ul>
<h4 id="AOP和函数式编程有没有关系？"><a href="#AOP和函数式编程有没有关系？" class="headerlink" title="AOP和函数式编程有没有关系？"></a>AOP和函数式编程有没有关系？</h4><hr>
<h5 id="AOP是什么？"><a href="#AOP是什么？" class="headerlink" title="AOP是什么？"></a>AOP是什么？</h5><blockquote>
<p>AOP是面向切面编程。我们平时编写web程序的时候，通常都会使用controller-&gt;service-&gt;dao这样的层次结构的调用链。事实上，有些逻辑不是纵向延伸的，对于单个的层级，如service，一个典型的应用就是Log处理：我们需要对service中涉及写入数据库的操作进行记录，这样的逻辑对于service上的所有需要log记录的方法而言是通用的。所以没有必要在各个不同的services上手工记录log，我们只需要将这部分log的逻辑抽出来作为独立的方法，然后很形象地表述成在services上的方法打上一个个洞，将这部分独立的方法像插槽（阀门）一样插入这些洞里，流过services上这些被记录的方法上的数据及其本身就会被完整的记录下来。</p>
</blockquote>
<blockquote>
<p>AOP的概念也很有趣。事实上，AOP中的Joinpoint,Pointcut,Advice可以分别类比为钩子，晾衣杆和晾衣服这个动作。Joinpoint就是要拿来鼓捣的方法，Pointcut则是将这些方法串起来，Advice是统一处理这些方法的逻辑操作，同时也包括了它自身的执行时机，是在Pointcut之前、之后或是其中，当然更有甚者，是在方法返回之后，还是抛出异常之后呢？</p>
</blockquote>
<blockquote>
<p>那么接下来，我们来看看AOP和函数式编程到底有没有关系。第一个方面，AOP其实是间接地拿函数作为自己的参数了。举个例子，拦截controller的方法：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@AfterReturning(value = &quot;execution(* controller.*.*(..)) &amp;&amp; args(customer)&quot;,</span><br><span class="line">        returning = &quot;result&quot;)</span><br><span class="line">public void aMethod(Customer customer, String result) &#123;</span><br><span class="line">    System.out.println(&quot;before&quot;);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    System.out.println(&quot;after&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实这样的方式——既拿到了输入参数，又拿到了输出参数，就等于已经拿到了整个方法，何况还有牛掰的@Around，直接拿人家的方法到自己的方法体里执行。而函数式第一要点就是函数是一等公民，函数可以作为参数传递。所以说从获取参数这个层面说，两者实在太相像了。</p>
</blockquote>
<blockquote>
<p>第二个方面，抽取共有逻辑。函数式中有惰性求值，假设我们在函数式中预留一个Function作为钩子，任何想使用这部分函数逻辑的在需要的时候，通过某种机制传递真正的Function到我们的预留参数中，是不是也能实现抽取共有逻辑呢？还有，我们之所以有很多services，是因为model（domain）存在差异，假设函数式中没有OO的概念，model似乎就趋同了，那么或许我们根本不需要services。所以函数式是可以抽取共有逻辑的，或者说这部分逻辑本来就不应该分散到各个services中。</p>
</blockquote>
<blockquote>
<p>结论处，我大胆地猜测：AOP其实就是OO被掣肘之后，利用函数式缝补自身的妥协方案。AOP本来就是Functional programming.</p>
</blockquote>
<h4 id="Functional-Programming的要点"><a href="#Functional-Programming的要点" class="headerlink" title="Functional Programming的要点"></a>Functional Programming的要点</h4><hr>
<ul>
<li>声明式编程</li>
<li>不变量</li>
<li>无副作用的函数</li>
<li>不会依附于任何类或者对象，这点“functional programming for java developer”中有清楚描述。在java中写的大部分函数式代码都是静态的，但逻辑上，它不属于这个类。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>OO</tag>
        <tag>FP</tag>
      </tags>
  </entry>
  <entry>
    <title>AngularJS components</title>
    <url>/2014/09/25/a-way-to-handle-angularjs-components-problem/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><hr>
<p>假设某种Web App的业务场景是这样的：每个页面仅仅只有简单的表单，包括文字提醒label, 单选radio button, 问题列表dropdown menu, 处理页面前后跳转的button, 复杂一点的如价格输入input，时间选择date picker。而且这些可以独立展现业务价值，也就是说任何一个或者多个这样的页面元素可以经过简单组合，甚至无需组合就能反映一个独立的业务提问（具备评估填写人能力的价值），那么我们就可以将这些页面元素及其简单的组合体作为一个独立的component。这些component最大的好处就是恰如其分地反映了它本身的业务，但是这也不能成为封装成component的理由——因为我们完全可以通过一个良好名称的id来反映。独立出来的好处无非两个：可插拔，能复用。</p>
<p>首先，来讨论一下可插拔这个问题。假如BA美女告诉说某个业务提问T不应该再出现在A页面了，它应该出现在B页面。若不是component，问题来了：我们需要删掉本页面的T，连带着需要删除分散的js和css文件。麻烦！若是独立一个component，简单了先解除该页面对T的使用（在AngularJS中是删除对应的指令），然后在B页面导入进来。因为是component，且每个页面的结构都是表单，代码结构也类似，所以改动的量少。方便！</p>
<p>再来讨论一下能复用这个问题。我刚才提到过，因为是反映一个独立的业务提问，所以很可能在其他同类的产品上，这东西也是存在的，可能唯一不同的就是问法不同，以及提示信息有别。换句话说这些问句和提示是可编辑的。有人说那简单呐，component的所有提问和提示信息弄成可编辑的不就行了？component是可变的（可编辑），但是具体在哪个页面给出什么提问和提示总是不变的吧。我原来也是这样想的，但是仔细想想我发现这里有一个矛盾之处：我们想复用业务，而不是组件！这世界上最不可信的就是业务，最可能变的也是业务，但我们还异想天开地复用业务。任何一个独立的component，在具体的业务上，都很可能不是简单地替换显示文本，它完全会增加一小条额外的询问条目！那么原来的component就只能乖乖地被copy&#x2F;paste成另一个可怜的component——因为它们是不同的业务啊！BA如是说。作为程序员，我讨厌重复的代码，这也是我们不断使用重构的原因。但是就因为业务不同，哪怕代码相似度是99%，我也得重新创建一个，这个实在不值得！</p>
<p>而且，更奇葩地是这些可编辑信息居然被写入了后端的properties文件当中，使用Java这样静态的语言来抽象出一个给这些component提供文本信息的接口。试想一下，哪天某个BA告诉我：我想为某个业务X，添加一个subTitle。我的回答：不行呐，我们的接口只提供了一个label，而且这里已经使用了，我如果加一个新的，会影响其他的所有component的。BA：!&amp;^$%@$. 我接着说：我可以提供一个sub.label的property key，这样前端可以写成 [X.sub].label，如何？BA：呵呵……</p>
<h3 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h3><hr>
<h4 id="简单得出几个结论"><a href="#简单得出几个结论" class="headerlink" title="简单得出几个结论"></a>简单得出几个结论</h4><ul>
<li>不用妄图复用业务，即使它们在UI表现上极其相似；</li>
<li>业务和UI的关系，等同于饮料和瓶子的关系，瓶子一个模子就够了，饮料随便换；</li>
<li>饮料要换个瓶模子了，那换就是，具体是从原来的模子继承，还是组合，饮料不需要关心。</li>
</ul>
<h4 id="如何做瓶子，如何换饮料，如何组合成卖品"><a href="#如何做瓶子，如何换饮料，如何组合成卖品" class="headerlink" title="如何做瓶子，如何换饮料，如何组合成卖品"></a>如何做瓶子，如何换饮料，如何组合成卖品</h4><p>做瓶子简单。作为程序员，我使用AngularJS的Directive构建基础的common components，如radio button, dropdown menu, search box. 这些仅仅和UI相关。当然这些还仅仅是瓶子的组成成分。</p>
<p>那么接下来，如何换饮料呢？饮料有自己的骄傲——它不仅口味各异，还分品牌！每种品牌下的饮料自然不同。那我们只好先做一下分类。先从品牌开始，先分成X, Y, Z这几类，然后开始分口味了，又分成A, B, C这几类。这个季度，老板说我们要推出X类的A, B, C饮料！怎么做？我们把A, B, C写入配置文件(properties)，拿A举例子：A有颜色，甜度，气味三个属性，分别对应如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A:</span><br><span class="line">  color: red</span><br><span class="line">  sweet: middle</span><br><span class="line">  smell: nice</span><br></pre></td></tr></table></figure>
<p>Ok，接下来我们来构造A这款饮料的<strong>业务</strong>的directive</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function(global, angular)&#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    angular.module(&#x27;a.b.c&#x27;,[])</span><br><span class="line">        .directive(&#x27;A&#x27;, function()&#123;</span><br><span class="line">           return &#123;</span><br><span class="line">               restrict: &#x27;AE&#x27;,</span><br><span class="line">               templateUrl: &#x27;views/A.html&#x27;</span><br><span class="line">           &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;)(this, angular);</span><br></pre></td></tr></table></figure>
<p>好了，我们有业务细节A了，又有业务A的directive了。我们理所应当地认为这个directive和A应该是一体的，为什么不直接将A细节写入directive的scope中呢？答案是X, Y, Z在这里是可以复用这个directive的，所以不能硬编码。不能硬编码，我首先的直觉就是变量替换，又要求复用，那么就立马想到了继承或者组合。又因为组合优于继承（更现实的是我不知道如何在AngularJS中实现继承），我决定使用组合。接下来这个过程的产出物就是我们的卖品，构造如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># define in common module</span><br><span class="line">A:&#123;</span><br><span class="line">  color: red,</span><br><span class="line">  sweet: middle,</span><br><span class="line">  smell: nice</span><br><span class="line">&#125;</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">(function(global, angular)&#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    angular.module(&#x27;a.b.c&#x27;, [&#x27;common&#x27;])</span><br><span class="line">        .directive(&#x27;A&#x27;, [&#x27;me&#x27;, function()&#123;</span><br><span class="line">           return &#123;</span><br><span class="line">               restrict: &#x27;AE&#x27;,</span><br><span class="line">               scope: &#123;</span><br><span class="line">                  self: &#x27;=&#x27;</span><br><span class="line">               &#125;,</span><br><span class="line">               link: function($scope) &#123;</span><br><span class="line">               	   $scope.self = me;</span><br><span class="line">               &#125;,</span><br><span class="line">               templateUrl: &#x27;views/A.html&#x27;</span><br><span class="line">           &#125;;</span><br><span class="line">        &#125;]);</span><br><span class="line">&#125;)(this, angular);</span><br></pre></td></tr></table></figure>
<p>从代码中很容易看出，我们把A这个业务，组成了一个叫做common的module，可以类比为装着众多饮料的机器，然后对准一个叫做A的瓶子注入，注意A这个瓶子用到了很多common components。这整个过程就是Angular完成这个A的directive的过程，也就是饮料和瓶子组装的过程。然后这个A的directive就是我们的卖品。</p>
<h3 id="实际成效"><a href="#实际成效" class="headerlink" title="实际成效"></a>实际成效</h3><hr>
<p>事实验证，上述的方式是不合理的。理由有下面三点：</p>
<ul>
<li>依赖过剩。我们将会有很多的components，如果每次都得手动注入common依赖的话，量实在是太大了。</li>
<li>非独立。一个纯净的业务组件不应该有第三方的依赖，有依赖，必然导致无法独立使用。</li>
<li>不可扩展设备。这个最大的怪兽就是我们将业务的东西全部放到了前端，如果要兼容其他设备，我们后端的这块业务功能是缺失的，不能给其他设备提供支持。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>angularJs</tag>
      </tags>
  </entry>
  <entry>
    <title>程序语言的精髓</title>
    <url>/2014/10/11/briefing-of-programming-language/</url>
    <content><![CDATA[<p><code>当夜幕已近闭合，沉睡的晚灯张起结界，昏黄中没半点柔情，仿佛在告诉行人：非诚勿扰</code></p>
<blockquote>
<p>夜晚11:11分，注定孤独的时分。Carl倚靠窗台失神了半晌，回过来就顺手拉紧了窗帘。拧开台灯，桌上静静地躺着一本书，是日本人西尾太和的《代码之髓》。他翻开扉页，签上自己的大名，满足地撇撇嘴，开始看起来。</p>
</blockquote>
<h3 id="Lisp是这个世界上最精练，最美观的语言"><a href="#Lisp是这个世界上最精练，最美观的语言" class="headerlink" title="Lisp是这个世界上最精练，最美观的语言"></a>Lisp是这个世界上最精练，最美观的语言</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(setq f</span><br><span class="line">      (let ((x 1))</span><br><span class="line">        (lambda (y) (* x y))))</span><br></pre></td></tr></table></figure>
<p>直观上，这个函数f的结果就是(* 1 y)，也就是y的值。那么实际调用的结果如何呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(let ((x 2))</span><br><span class="line">  (funcall f 2))</span><br></pre></td></tr></table></figure>
<p>即f(2)的结果是2？实际运行的结果让人大跌眼镜，是4！</p>
<blockquote>
<p>Carl揉揉被蹂躏多时的眼球，问自己：为什么是这样，像梦一场？</p>
</blockquote>
<p>行文到这里，我们的黑暗主角慢慢走向台前——作用域(Scope)。作用域在程序的世界里，见怪不怪，谁都知道它的第一要务就是防止命名冲突！</p>
<blockquote>
<p>Carl点点头，道：嗯，教材里是这么说的。他抬头看了一下光，阴影里有种烦躁的情绪在跳动。</p>
</blockquote>
<p>其实，作用域是分类别的。Lisp中用到了其中之一的动态作用域(Dynamic Scope)，动态作用域最根本的特点是从时间维度上判断进入和离开某个函数具有独立的作用域。上面Lisp的例子当中，<code>(let ((x 2)) (funcall f 2))</code>表示一个函数，也就是独立的作用域。它调用了f这个函数，但从时间上看，调用点依旧处于原来的作用域当中，所以x&#x3D;2这样的变量在f函数里是有效的，最后的结果是(* 2 y)，等于4也就理所应当了。</p>
<blockquote>
<p>Carl接受了这样的解释，他想：既然存在，那么一定合理。闭目养神的时间里，他的思维遨游了很久，有溺水的迹象，仿佛得到了神启。他想到了人生，理想，家人，婚姻和<code>python2</code></p>
</blockquote>
<h3 id="在python2里面，这个世界里有怪物存在——嵌套的函数和外部作用域的再绑定。"><a href="#在python2里面，这个世界里有怪物存在——嵌套的函数和外部作用域的再绑定。" class="headerlink" title="在python2里面，这个世界里有怪物存在——嵌套的函数和外部作用域的再绑定。"></a>在<code>python2</code>里面，这个世界里有怪物存在——嵌套的函数和外部作用域的再绑定。</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = &quot;global&quot;</span><br><span class="line">def foo():</span><br><span class="line">	x = &quot;foo&quot;</span><br><span class="line">	def bar():</span><br><span class="line">		print x</span><br><span class="line">	bar()</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>答案是global，而不是想当然的foo。<code>python2</code>里头使用了静态作用域(Static Scope), 与动态作用域相对。静态作用域的显著特点是源码级别上拥有独立的作用域，简单地可以理解成每一个函数都是独立的作用域。然后，2011年发布的<code>python2.1</code>修改了逻辑，最终返回了foo，他们显然认为嵌套的函数不是函数，而是形同if&#x2F;else这样的嵌套结构体。感觉上，又回到了当初动态作用域的年代。</p>
<blockquote>
<p>Carl咽了口水，他讨厌动态作用域如同父母窥视了孩子狭小私人空间，这让他很不舒服。有一首诗：阴郁的日子总会过去。接下来，事情总算不太坏。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo():</span><br><span class="line">	x = &quot;old&quot;</span><br><span class="line">	def bar():</span><br><span class="line">		x ＝ &quot;new&quot;</span><br><span class="line">	bar()</span><br><span class="line">	print x</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>这回得到的还是old。</p>
<blockquote>
<p>Carl笑了，这才像话。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo():</span><br><span class="line">	x = &quot;old&quot;</span><br><span class="line">	def bar():</span><br><span class="line">		nonlocal x</span><br><span class="line">		x ＝ &quot;new&quot;</span><br><span class="line">	bar()</span><br><span class="line">	print x</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>这回得到的却是new。</p>
<blockquote>
<p>Carl哭了。他想起来了，java里的类，private, protected修饰符，还有静态变量。他触摸到了作用域的本质，如同一直看不见的手，抚摸那薄膜面纱背后吹弹可破的脸蛋。至于有没有被赐予洪亮的耳光，那已经是后话了。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>language</tag>
      </tags>
  </entry>
  <entry>
    <title>vim in practice (1)</title>
    <url>/2014/10/30/vim-in-practice/</url>
    <content><![CDATA[<h2 id="Vim-Practice"><a href="#Vim-Practice" class="headerlink" title="Vim Practice"></a>Vim Practice</h2><h3 id=""><a href="#" class="headerlink" title="&lt;leader&gt;"></a>&lt;leader&gt;</h3><blockquote>
<p>Vim have a extra key to activate mappings, and call this “prefix” key the “leader”.</p>
<blockquote>
<p>*Mapping keys is one of the places where Vim comments does’t work. </p>
</blockquote>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mapleader=&#x27;,&#x27;</span><br><span class="line">nnoremap &lt;leader&gt;ev :vsplit $MYVIMRC&lt;cr&gt;</span><br><span class="line">nnoremap &lt;leader&gt;sv :source $MYVIMRC&lt;cr&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Abbrevation"><a href="#Abbrevation" class="headerlink" title="Abbrevation"></a>Abbrevation</h3><blockquote>
<p>Vim has a feature called “abbreviations” that feel similar to mappings but are meant for use in insert, replace, and command modes. </p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iabbrev what what</span><br><span class="line">when you type *what&lt;space&gt;*</span><br><span class="line">were substituted with *what&lt;space&gt;*</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Disable-old-keys"><a href="#Disable-old-keys" class="headerlink" title="Disable old keys"></a>Disable old keys</h3><blockquote>
<p>This effectively disables the escape key in insert mode by telling Vim to perform <nop> (no operation) instead.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inoremap &lt;esc&gt; &lt;nop&gt; &quot;no operation</span><br></pre></td></tr></table></figure>

<h3 id="Autocommands"><a href="#Autocommands" class="headerlink" title="Autocommands"></a>Autocommands</h3><blockquote>
<p>Autocommands are the way to tell Vim to run commands whenever certain events happen.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:autocmd BufNewFile * :write</span><br><span class="line">         ^          ^ ^</span><br><span class="line">         |          | |</span><br><span class="line">         |          | The command to run.</span><br><span class="line">         |          |</span><br><span class="line">         |          A &quot;pattern&quot; to filter the event.</span><br><span class="line">         |</span><br><span class="line">         The &quot;event&quot; to watch for.</span><br><span class="line"></span><br><span class="line">:autocmd BufWritePre,BufRead *.html :normal gg=G</span><br><span class="line">:help autocmd-events</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="System-clipboard"><a href="#System-clipboard" class="headerlink" title="System clipboard"></a>System clipboard</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BundleInstall fakeclip</span><br><span class="line">1. Normal mode</span><br><span class="line">&quot;+Y or &quot;+yy (use system register&lt;+&gt; to copy)</span><br><span class="line">2. Visual mode</span><br><span class="line">&quot;+Y</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>funny Q</title>
    <url>/2014/11/17/funny-q/</url>
    <content><![CDATA[<h2 id="funny-Q"><a href="#funny-Q" class="headerlink" title="funny Q"></a>funny Q</h2><h3 id="q"><a href="#q" class="headerlink" title="$q"></a>$q</h3><blockquote>
<p>$q can be used in two fashions — one which is more similar to Kris Kowal’s Q or jQuery’s Deferred implementations, and the other which resembles ES6 promises to some degree.</p>
</blockquote>
<h3 id="ES6-style"><a href="#ES6-style" class="headerlink" title="ES6 style"></a>ES6 style</h3><blockquote>
<p>The streamlined ES6 style promise is essentially just using $q as a constructor which takes a resolver function as the first argument. </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// assume that $q and $resource are available.</span><br><span class="line">function = asyncGo() &#123;</span><br><span class="line">    return $q( function(resolve, reject) &#123;</span><br><span class="line">        $resource(&quot;www.example.com&quot;, &#123;&#125;, &#123;&#125;)</span><br><span class="line">        .get(&#123;&#125;, function(result) &#123;</span><br><span class="line">            resolve(&quot;hello, &quot; + result);</span><br><span class="line">        &#125;, function(error) &#123;</span><br><span class="line">            reject(&quot;sorry, &quot; + error + &quot; is not allowed&quot;);</span><br><span class="line">        &#125;) </span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var promise = asyncGo();</span><br><span class="line">promise.then(function(greeting)&#123;</span><br><span class="line">    console.log(greeting);</span><br><span class="line">&#125;, function(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Deferred-style"><a href="#Deferred-style" class="headerlink" title="Deferred style"></a>Deferred style</h3><blockquote>
<p>The purpose of the deferred object is to expose the associated Promise instance as well as APIs that can be used for signaling the successful or unsuccessful completion, as well as the status of the task.</p>
</blockquote>
<ul>
<li><p>resolve(value) – resolves the derived promise with the value. If the value is a rejection constructed via $q.reject, the promise will be rejected instead.</p>
</li>
<li><p>reject(reason) – rejects the derived promise with the reason. This is equivalent to resolving it with a rejection constructed via $q.reject.</p>
</li>
<li><p>notify(value) - provides updates on the status of the promise’s execution. This may be called multiple times before the promise is either resolved or rejected.</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promiseB = promiseA.then(function(result) &#123;</span><br><span class="line">  return result + 1;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// promiseB will be resolved immediately after promiseA is resolved and its value</span><br><span class="line">// will be the result of promiseA incremented by 1</span><br></pre></td></tr></table></figure>

<h3 id="q-vs-rootScope"><a href="#q-vs-rootScope" class="headerlink" title="$q vs. $rootScope"></a>$q vs. $rootScope</h3><h4 id="q-is-integrated-with-the-rootScope-Scope-Scope-model-observation-mechanism-in-angular"><a href="#q-is-integrated-with-the-rootScope-Scope-Scope-model-observation-mechanism-in-angular" class="headerlink" title="$q is integrated with the $rootScope.Scope Scope model observation mechanism in angular"></a>$q is integrated with the $rootScope.Scope Scope model observation mechanism in angular</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">it(&#x27;should simulate promise&#x27;, inject(function($q, $rootScope) &#123;</span><br><span class="line">  var deferred = $q.defer();</span><br><span class="line">  var promise = deferred.promise;</span><br><span class="line">  var resolvedValue;</span><br><span class="line"></span><br><span class="line">  promise.then(function(value) &#123; resolvedValue = value; &#125;);</span><br><span class="line">  expect(resolvedValue).toBeUndefined();</span><br><span class="line"></span><br><span class="line">  // Simulate resolving of promise</span><br><span class="line">  deferred.resolve(123);</span><br><span class="line">  // Note that the &#x27;then&#x27; function does not get called synchronously.</span><br><span class="line">  // This is because we want the promise API to always be async, whether or not</span><br><span class="line">  // it got called synchronously or asynchronously.</span><br><span class="line">  expect(resolvedValue).toBeUndefined();</span><br><span class="line"></span><br><span class="line">  // Propagate promise resolution to &#x27;then&#x27; functions using $apply().</span><br><span class="line">  $rootScope.$apply();</span><br><span class="line">  expect(resolvedValue).toEqual(123);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p><code>then</code> that can accept three arguments(three callback types)–success, failure, progress.<br>for defer object, resolve will apply to success, reject apply to failure and notify apply to progress.</p>
<p>a defer object contains always, done, fail methods! so the always and done will trigger if resovle be called and return a promise object, which contains resolved result.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>q</tag>
      </tags>
  </entry>
  <entry>
    <title>Thinking in IoC</title>
    <url>/2014/11/02/thinking-in-ioc/</url>
    <content><![CDATA[<h3 id="为什么要面向接口编程？"><a href="#为什么要面向接口编程？" class="headerlink" title="为什么要面向接口编程？"></a>为什么要面向接口编程？</h3><hr>
<h4 id="背景提要"><a href="#背景提要" class="headerlink" title="背景提要"></a>背景提要</h4><blockquote>
<p>莱恩是一名程序员，混迹Java界三载有余。从刚接触这门语言起，就被前辈告知必须遵循面向接口编程这一原则。之后，反复翻阅《设计模式》，面向接口编程的理念便深入脑髓。当然，他也不是没有思想的小白，“不好的东西不用”这种基本常识还是有的。人类这种动物，最擅长地就是提问，莱恩也会问“为什么我要面向接口编程呐？”。有经验的老人告诉过他，这样有利于解除耦合，根据依赖倒置原则——高层次的模块不应该依赖低层次的模块，抽象不应该依赖实现，实现应该依赖抽象。换句话说，就是要面向抽象编程。这顿论调，老生常谈了，但是高度概括的东西没有实践的基石，就如同空中楼阁，虚幻飘渺，能否理解，需要看小沙弥的悟性。</p>
</blockquote>
<h4 id="IoC中谁的控制权被反转？"><a href="#IoC中谁的控制权被反转？" class="headerlink" title="IoC中谁的控制权被反转？"></a>IoC中谁的控制权被反转？</h4><blockquote>
<p>莱恩实践过Java界家喻户晓的framework spring，被它强大的IoC容器深深吸引。好莱坞经典语录：“Don’t call me, I’ll call you”。它揭示的是这样一个道理：我需要你自然会找你。莱恩不禁问自己：IoC容器究竟和这个道理有什么关系呢？<br>大师说：获取和管理对象的方式被倒转了。</p>
</blockquote>
<p>接下来，通过一个实际的例子探索IoC容器的意义所在。</p>
<h4 id="面向接口编程＝定义行为的标准"><a href="#面向接口编程＝定义行为的标准" class="headerlink" title="面向接口编程＝定义行为的标准"></a>面向接口编程＝定义行为的标准</h4><p>以开关和灯泡为例：</p>
<blockquote>
<p>最简单的实现：开关依赖(<em>use</em>)灯泡，然后控制。</p>
</blockquote>
<p>这个例子中，开关创建并维护了灯泡的实例。不过有一天，灯泡要延伸出多种类型了。没关系，简单实现：</p>
<blockquote>
<p>开关依赖灯泡这个抽象东西，其余的灯泡派生自灯泡。</p>
</blockquote>
<p>好像问题也不大。然而，实际上开关不会只控制灯泡，还有冰箱，电视，空调呢？我们终于发现，其实开关的职责不是去开关灯泡，而是开合电源。<em>but who cares the electrinic?</em> 所以我们假设电源就是一只信号，某位ruby大牛把所有对象的调用，都看作是向这些对象发送message。用在这里，倒是很合理。</p>
<p>那么现在我们运用接口隔离原则，提升一个最小接口。</p>
<blockquote>
<p>依赖又不是只有聚合、组合，还有继承和<strong>实现(implement)<strong>。这样的话，我们把灯泡依赖到一个具有开合行为的接口。</strong>开关</strong>此时就定义了电源开合的接口。</p>
</blockquote>
<p>这里，灯泡并不知道哪只开关让自己或亮或暗，而开关也只知道开合某个电源接口。言而总之，所谓的面向接口编程等同于定义行为的标准。不过问题来了，谁为开关连上灯泡呢？我们现在只知道开关持有一个开合接口，不能在开关里新建一个灯泡的对象，否则好不容易获得依赖抽象的好处便会付诸东流了。</p>
<p>怎么办？记住计算机中的任何问题都能通过构造一个抽象层解决。IoC容器就是干这件事的，根据各个实例之间的依赖关系创建和管理对象的实例。</p>
<p>所以说，IoC中被反转控制权的是获取和管理对象的方式，它被反转到IoC容器当中了。“I’ll call you.”中的I也就是IoC容器。</p>
<h4 id="谈谈IoC和DI"><a href="#谈谈IoC和DI" class="headerlink" title="谈谈IoC和DI"></a>谈谈IoC和DI</h4><p>大部分书上，都把这两者混为一谈。</p>
<p>DI是IoC的子集。IoC是个泛泛之论，通俗来讲，任何有利于程序高内聚低耦合的框架都具有IoC的特征。在OO里，Dependency被反转；在基于Event的编程模型里，Event Loop被反转了；在Observer Pattern中，Subject通知Observer的方式被反转了。</p>
<h4 id="方法级别上的IoC"><a href="#方法级别上的IoC" class="headerlink" title="方法级别上的IoC"></a>方法级别上的IoC</h4><p>Template Method方法具有IoC的特点：</p>
<ul>
<li>父类方法决定了必要的流程和某些不变的部分；</li>
<li>子类继承父类，重写可变的方法；</li>
<li>子类只关心职责，而不关心流程。</li>
</ul>
<p>所以是父类定义了标准，让子类实现之。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<ul>
<li>IoC不等于DI；</li>
<li>IoC不是对象的专利，方法级别一样适用。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>Thinking about microservice</title>
    <url>/2014/11/09/thinking-about-microservice/</url>
    <content><![CDATA[<h2 id="谈谈我对microservice的理解"><a href="#谈谈我对microservice的理解" class="headerlink" title="谈谈我对microservice的理解"></a>谈谈我对microservice的理解</h2><h2 id="1-在比较中理解"><a href="#1-在比较中理解" class="headerlink" title="1. 在比较中理解"></a>1. 在比较中理解</h2><h3 id="功能上"><a href="#功能上" class="headerlink" title="功能上"></a>功能上</h3><h4 id="传统的service"><a href="#传统的service" class="headerlink" title="传统的service"></a>传统的service</h4><ul>
<li>功能全面，大而全；</li>
<li>系统内部耦合严重，数据服务部分互相依赖，逻辑错综复杂；</li>
<li>表现层和服务层耦合，解除耦合难以实现；</li>
<li>整个应用程序独立存在，完全不可以复用。</li>
</ul>
<h4 id="新型的microservice"><a href="#新型的microservice" class="headerlink" title="新型的microservice"></a>新型的microservice</h4><ul>
<li>多模块，每个模块功能单一；</li>
<li>采用统一的数据传输格式；</li>
<li>数据服务单独部署，可以互相依赖；</li>
<li>采用RESTful服务标准，表现层和服务层解耦；</li>
<li>分布式部署，服务可以冗余，容灾</li>
<li>采用分布式事务：BASE原则，1. Basiclly Available 2. Soft state 3.Eventually Consistent</li>
</ul>
<h3 id="开发中"><a href="#开发中" class="headerlink" title="开发中"></a>开发中</h3><h4 id="传统的service-1"><a href="#传统的service-1" class="headerlink" title="传统的service"></a>传统的service</h4><ul>
<li>代码组织结构和逻辑复杂，难以阅读；</li>
<li>功能性测试简单；</li>
<li>系统对外暴露较少，沟通成本较低。</li>
</ul>
<h4 id="新型的microservice-1"><a href="#新型的microservice-1" class="headerlink" title="新型的microservice"></a>新型的microservice</h4><ul>
<li>代码结构简单，易于阅读；</li>
<li>需要大量的mock service，以完成功能性测试；</li>
<li>web技术上可能存在跨域问题；</li>
<li>系统对外依赖较重，交互频繁；</li>
<li>人员沟通成本巨大。</li>
</ul>
<h2 id="Service-Dependency-Management"><a href="#Service-Dependency-Management" class="headerlink" title="Service Dependency Management"></a>Service Dependency Management</h2><blockquote>
<p>既然服务之间的依赖很困扰，那么为何不学习maven或者gradle，将服务依赖统一管理起来？<br>Taobao中configServer是一个独立的中央管理服务器，其作用无非让应用知晓其他应用，然后去调用；这就是依赖！<br>而且假设不同服务是有版本号的，事实上很多人已经这么做了，这个实在太类似jar的依赖管理了。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>maven in action</title>
    <url>/2014/11/19/maven-in-action/</url>
    <content><![CDATA[<h2 id="maven-phases-and-plugins-goal"><a href="#maven-phases-and-plugins-goal" class="headerlink" title="maven phases and plugins goal"></a>maven phases and plugins goal</h2><h3 id="three-built-in-Lifecycle"><a href="#three-built-in-Lifecycle" class="headerlink" title="three built-in Lifecycle"></a>three built-in Lifecycle</h3><ul>
<li>default</li>
<li>clean</li>
<li>site</li>
</ul>
<h3 id="built-in-Lifecycle-is-made-up-of-phases"><a href="#built-in-Lifecycle-is-made-up-of-phases" class="headerlink" title="built-in Lifecycle is made up of phases"></a>built-in Lifecycle is made up of phases</h3><ul>
<li>default<ul>
<li>validate - validate project is correct and all neccessary infomation is avaiable</li>
<li>compile</li>
<li>test</li>
<li>package</li>
<li>integration-test</li>
<li>verify - run and checks to verify the package is valid and meets quality criteria</li>
<li>install - install to local repository</li>
<li>deploy - copy the final package to the remote repository for sharing.</li>
</ul>
</li>
</ul>
<h3 id="a-build-phase-is-made-up-of-plugin-goals"><a href="#a-build-phase-is-made-up-of-plugin-goals" class="headerlink" title="a build phase is made up of plugin goals"></a>a build phase is made up of plugin goals</h3><ul>
<li>a plugin goal represents a specific task, and bound to those build phases.</li>
<li>it’s bound to zero or more build phases</li>
<li><code>mvn clean dependency:copy-dependencies package</code></li>
<li>a phase can also have zero or more goals bound to it. if a build phase has no goals bound to it, it cannot execute.</li>
</ul>
<p><code>编写插件的时候，我们会给每一个goal默认绑定一个phase，所以在对应的plugin中，我们或许不需要显式绑定两者</code></p>
<h3 id="maven-core-concept-coordinate-and-dependency"><a href="#maven-core-concept-coordinate-and-dependency" class="headerlink" title="maven core concept: coordinate and dependency"></a>maven core concept: coordinate and dependency</h3><h4 id="coordinate"><a href="#coordinate" class="headerlink" title="coordinate"></a>coordinate</h4><ul>
<li>groupId</li>
<li>artifactId</li>
<li>version</li>
<li>packaging - jar（default）, war</li>
<li>classfier - javadoc.jar, sources.jar. cannot defined directly</li>
</ul>
<h4 id="dependency"><a href="#dependency" class="headerlink" title="dependency"></a>dependency</h4><ul>
<li>dependency scope: (compile, test, provided, runtime, system, import), provided(servlet-api) system should with systemPath.</li>
<li>transitive dependency</li>
<li>dependency mediate (the shortest path, otherwise declartive order in pom)</li>
<li>execlusion dependency(groupId &amp; artifactId)</li>
</ul>
<p>How to look for dependency</p>
<p><code>mvn dependency:list mvn dependency:tree</code></p>
<p><code>mvn dependency:analyze</code> : 标注声明但未使用的依赖或者使用但未声明的依赖(传递依赖)</p>
<h4 id="dependency-management"><a href="#dependency-management" class="headerlink" title="dependency management"></a>dependency management</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>
<p><code>防止subModules继承不必要的依赖，同时如果需要，只要在subModule中声明此依赖的groupId, artifactId，无需对应的versionId，因为这是可以继承自parentModule的</code></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript Hoisting</title>
    <url>/2015/01/27/Javascript-Hoisting/</url>
    <content><![CDATA[<p>编程过程中，别人谈到Javascript中的funcation是顺序执行的，所以书写的顺序要留心，不然会出未定义就执行的错误。当然，C语言出身的程序员不以为意，会认为理所当然，C语言就是这么干的。但Javascript并非如此！</p>
<figure class="highlight javascript"><figcaption><span>ints.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ints</span>(<span class="params">arrOfNumberStr</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> arrOfNumberStr.<span class="title function_">map</span>(toInt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">toInt</span>(<span class="params">str</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parseInt</span>(str, <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">ints</span>([<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;11&#x27;</span>]);</span><br><span class="line">-&gt; [<span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>
<p>从执行结果上来看，先调用后执行时正确的。但是JS是解析执行的，如果没有预先定义，执行到调用处必然会失败，那么为什么这段代码可以工作呢？</p>
<p>先看一段略做修改之后的代码</p>
<figure class="highlight javascript"><figcaption><span>ints_fail.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ints</span>(<span class="params">arrOfNumberStr</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> arrOfNumberStr.<span class="title function_">map</span>(toInt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> toInt = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parseInt</span>(str, <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">ints</span>([<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;11&#x27;</span>]);</span><br><span class="line">-&gt; <span class="title class_">TypeError</span>: <span class="literal">undefined</span> is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>
<p>执行结果失败了。回头看这两段代码的定义，不难发现程序对于<code>toInt</code>的定义方式有差别，一种用常规的函数定义方式，一种使用<strong>var</strong>定义。</p>
<p>接着再看一段代码</p>
<figure class="highlight javascript"><figcaption><span>variables.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params">n</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;n; i++);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">loop</span>(<span class="number">10</span>);</span><br><span class="line">-&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>估计学习C语言的人开始惊讶了：这个<code>i</code>的作用域不是应该只在<code>for loop</code>中吗？</p>
<p>那么到底是什么原因造成的呢？这就是Javascript Hoisting！简单解释，声明提升到作用域的最前面。</p>
<p>接上面的<em>variable.js</em></p>
<figure class="highlight javascript"><figcaption><span>variables_hoisting.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params">n</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和原来的写法是等价的，所以<code>i</code>的作用域在整个<code>function</code>中都是有效的。依次类推，<em>init_fail.js</em>中的<code>var toInt</code>这样的函数声明也会被提升到作用域的最上方，但是只是声明被提升了，真正赋值还是在后面，所以此时调用该函数，它还是<code>undefined</code>。</p>
<p>但是对于<em>init.js</em>而言，它的声明方式会将整个函数都提升，所以它是先于调用方赋值初始化的，所以能工作。</p>
<h3 id="‘use-strict’-可以防止-only-reference-hoisting"><a href="#‘use-strict’-可以防止-only-reference-hoisting" class="headerlink" title="‘use strict’ 可以防止 only reference hoisting?"></a>‘use strict’ 可以防止 only reference hoisting?</h3><hr>
<p>如果变量未声明，<strong>use strict</strong>模式下赋值会报错。</p>
<figure class="highlight javascript"><figcaption><span>use_strict.js</span></figcaption><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">123</span>;<span class="comment">//works fine</span></span><br><span class="line">    bar = <span class="number">345</span>;<span class="comment">//ReferenceError: bar is not defined</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>如果在以前例子中使用<strong>use strict</strong>，并不能提前报出<code>toInt</code>未赋值的错误。直到运行期间，才会发现<code>toInt</code>依然<code>undefined</code>。</p>
<figure class="highlight javascript"><figcaption><span>use_strict_for_hoisting.js</span></figcaption><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">ints</span>(<span class="params">arrOfNumberStr</span>) &#123;</span><br><span class="line">	<span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> arrOfNumberStr.<span class="title function_">map</span>(toInt);</span><br><span class="line">	<span class="keyword">var</span> toInt = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parseInt</span>(str, <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)([<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;11&#x27;</span>]);</span><br><span class="line">-&gt; <span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: <span class="literal">undefined</span> is not a <span class="keyword">function</span>(<span class="params">…</span>)</span><br></pre></td></tr></table></figure>

<h3 id="优先使用function-declaration"><a href="#优先使用function-declaration" class="headerlink" title="优先使用function declaration"></a>优先使用function declaration</h3><hr>
<blockquote>
<p>Why? Function declarations are named, so they’re easier to identify in call stacks. Also, the whole body of a function declaration is hoisted, whereas only the reference of a function expression is hoisted. This rule makes it possible to always use Arrow Functions in place of function expressions. – from <a href="https://github.com/airbnb/javascript#functions">javascript style guide</a></p>
</blockquote>
<p>下篇会记录Javascript的<a href="http://lambeta.com/2015/01/30/Javascript-Scope/">作用域</a>，<code>Global Scope, Lexical Scope, Dynamic Scope, Function Scope</code></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript Modularize</title>
    <url>/2015/01/25/Javascript-Modularize/</url>
    <content><![CDATA[<h3 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h3><h4 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h4><blockquote>
<p>一个包含了自由变量的开发表达式，和该自由变量的约束环境组合之后，产生了一种封闭的状态。</p>
</blockquote>
<p>举个例子，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inc</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> counter++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//invoke</span></span><br><span class="line"><span class="keyword">var</span> id = <span class="title function_">inc</span>();</span><br><span class="line"><span class="title function_">id</span>(); <span class="comment">//0</span></span><br><span class="line"><span class="title function_">id</span>(); <span class="comment">//1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>变量counter只在inc中可见，inc就是counter的约束环境，而内部的function就是开放的表达式，达到的封闭状态就是闭包。</p>
<h3 id="Javascript-Closure"><a href="#Javascript-Closure" class="headerlink" title="Javascript Closure"></a>Javascript Closure</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>);</span><br><span class="line">&#125;())</span><br><span class="line">or</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>注意两种闭包的写法: **()**一个在内，另一个在外，两者是等价的。<br>这种写法有两个作用</p>
<ol>
<li>立即执行(Immediately-Invoked Function Expression, IIFE)</li>
<li>封装内部变量，使之对外不可见</li>
</ol>
<p><strong>NOTICE</strong><br><code>对外不可见，不代表闭包内部不能访问全局变量。闭包内部是可以访问外部变量的，如上面的例子所示</code></p>
<blockquote>
<p>JavaScript has a feature known as implied globals. Whenever a name is used, the interpreter walks the scope chain backwards looking for a var statement for that name. If none is found, that variable is assumed to be global. If it’s used in an assignment, the global is created if it doesn’t already exist. This means that using or creating global variables in an anonymous closure is easy. Unfortunately, this leads to hard-to-manage code, as it’s not obvious (to humans) which variables are global in a given file.</p>
</blockquote>
<p>以上就是理由。这种做法不好的地方有三个：</p>
<ol>
<li>代码不便管理，这是全局变量的弊病</li>
<li>依赖关系不明确</li>
<li>性能损失，因为需要向后查找变量声明</li>
</ol>
<p>正确的做法是导入作用域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function(window)&#123;</span><br><span class="line">	console.log(window);</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure>

<p>借助closure，我们可以简单实现JS的模块化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var module = (function()&#123;</span><br><span class="line">	var counter = 0;</span><br><span class="line">	return &#123;</span><br><span class="line">		inc: function() &#123;</span><br><span class="line">			return counter++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">//invoke</span><br><span class="line">module.counter //undefined</span><br><span class="line">module.inc(); //0</span><br><span class="line">module.inc(); //1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="Augmentation-mixin-trait-…"><a href="#Augmentation-mixin-trait-…" class="headerlink" title="Augmentation (mixin, trait …)"></a>Augmentation (mixin, trait …)</h3><p>模块化之后，如何扩展这部分的功能？</p>
<h4 id="Loose-augmentation"><a href="#Loose-augmentation" class="headerlink" title="Loose augmentation"></a>Loose augmentation</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var module = (function(self)&#123;</span><br><span class="line"></span><br><span class="line">	self.todo = function() &#123;</span><br><span class="line">		console.log(&#x27;cannot access counter&#x27;);</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;)(module || &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>之所以称为宽松augmentation，是因为多个modules可以异步加载。如果变量没有声明，就会重新创建。与之对应的就是Tight augmentation</p>
<h4 id="Tight-augmentation"><a href="#Tight-augmentation" class="headerlink" title="Tight augmentation"></a>Tight augmentation</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var module = (function(self)&#123;</span><br><span class="line"></span><br><span class="line">	self.todo = function() &#123;</span><br><span class="line">		console.log(&#x27;cannot access counter&#x27;);</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;)(module)</span><br></pre></td></tr></table></figure>
<p>这样就要求严格的加载顺序了。</p>
<p>更多模式参考 <a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html">JavaScript Module Pattern: In-Depth</a></p>
<p>通用的JS规范共有两种：CommonJS和AMD</p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>该标准中，有一个自由函数require，用于加载模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//math.js</span><br><span class="line">exports.add = function() &#123;</span><br><span class="line">    var sum = 0, i = 0, args = arguments, l = args.length;</span><br><span class="line">    while (i &lt; l) &#123;</span><br><span class="line">        sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样就可以在其他模块中引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//increment.js</span><br><span class="line">var add = require(&#x27;math&#x27;).add;</span><br><span class="line">exports.increment = function(val) &#123;</span><br><span class="line">    return add(val,1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>NOTICE</strong></p>
<p><code>任何require进来的模块，其变量都是私有的</code></p>
<p>举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//program.js</span><br><span class="line">var inc = require(&#x27;increment&#x27;).increment;</span><br><span class="line">var a = 1;</span><br><span class="line">inc(a); // 2</span><br><span class="line">inc.add //undefined</span><br><span class="line">module.id == &quot;program&quot;;</span><br></pre></td></tr></table></figure>
<p>这里的inc.add对于program.js是不可见的。</p>
<p>NodeJs的模块系统实现了改标准 <a href="http://nodejs.org/docs/latest/api/modules.html">Nodejs Module</a></p>
<h3 id="AMD-Asynchronous-Module-Definition"><a href="#AMD-Asynchronous-Module-Definition" class="headerlink" title="AMD (Asynchronous Module Definition)"></a>AMD (Asynchronous Module Definition)</h3><p>对于浏览器环境，由于js文件在服务端，异步加载使得CommonJS不实用了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define(&quot;alpha&quot;, [&quot;require&quot;, &quot;exports&quot;, &quot;beta&quot;],</span><br><span class="line">function (require, exports, beta) &#123;</span><br><span class="line">       exports.verb = function() &#123;</span><br><span class="line">           return beta.verb();</span><br><span class="line">           //Or:</span><br><span class="line">           return require(&quot;beta&quot;).verb();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样，只有等到所有的模块加载成功后，才会调用回调函数。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript Modularize 2nd</title>
    <url>/2015/01/27/Javascript-Modularize-2nd/</url>
    <content><![CDATA[<h4 id="NodeJS-Module-require"><a href="#NodeJS-Module-require" class="headerlink" title="NodeJS Module require"></a>NodeJS Module require</h4><p>require实现了CommonJS标准，在Node中作为一个全局的函数来支持模块管理。<br>但是开发中遇到了一个有意思的场景：</p>
<p>假如ModuleA和ModuleB同时依赖一个第三方库，简单起见，设为<code>var Foo = &#123;request: &#39;foo&#39;&#125;</code></p>
<p>现在ModuleA引入Foo.js</p>
<figure class="highlight javascript"><figcaption><span>ModuleA</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = <span class="built_in">require</span>(<span class="string">&#x27;Foo&#x27;</span>);</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">request</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>ModuleB中也引入Foo.js</p>
<figure class="highlight javascript"><figcaption><span>ModuleB</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = <span class="built_in">require</span>(<span class="string">&#x27;Foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">request</span>); <span class="comment">//bar</span></span><br></pre></td></tr></table></figure>
<p>结果是这个对象的属性被改变了！这不就相当于全局变量了吗？</p>
<p>不过，据此可以推测NodeJS是如何实现require的：</p>
<ol>
<li>内部把依赖的module用function包装了一遍，使得require的变量变成私有的；</li>
<li>内部使用缓存机制，防止重复加载相同的JS文件。</li>
</ol>
<figure class="highlight javascript"><figcaption><span>module.js</span><a href="https://github.com/joyent/node/blob/069dd07a1732c6a752773aaed9e8c18ab472375f/lib/module.js#L354">NodeJs</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title class_">Module</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">require</span> = <span class="keyword">function</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="title function_">assert</span>(util.<span class="title function_">isString</span>(path), <span class="string">&#x27;path must be a string&#x27;</span>);</span><br><span class="line">  <span class="title function_">assert</span>(path, <span class="string">&#x27;missing path&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Module</span>.<span class="title function_">_load</span>(path, <span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这段代码就是require源代码，直接进入_load：</p>
<figure class="highlight javascript"><figcaption><span>Module._load</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title class_">Module</span>.<span class="property">_load</span> = <span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">    <span class="title function_">debug</span>(<span class="string">&#x27;Module._load REQUEST  &#x27;</span> + (request) + <span class="string">&#x27; parent: &#x27;</span> + parent.<span class="property">id</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> filename = <span class="title class_">Module</span>.<span class="title function_">_resolveFilename</span>(request, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cachedModule = <span class="title class_">Module</span>.<span class="property">_cache</span>[filename];</span><br><span class="line">  <span class="keyword">if</span> (cachedModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedModule.<span class="property">exports</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">var</span> <span class="variable language_">module</span> = <span class="keyword">new</span> <span class="title class_">Module</span>(filename, parent);</span><br><span class="line">...</span><br><span class="line">  <span class="title class_">Module</span>.<span class="property">_cache</span>[filename] = <span class="variable language_">module</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> hadException = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="title function_">load</span>(filename); <span class="comment">//invoke extensions[&#x27;.js|json&#x27;] -&gt; _compile js</span></span><br><span class="line">    hadException = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hadException) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="title class_">Module</span>.<span class="property">_cache</span>[filename];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我省略一些无关紧要的代码，仅从以上代码可以看出，确实有cache使用了，所以require到内存中的对象其实只有一个！</p>
<figure class="highlight plaintext"><figcaption><span>Module.prototype._compile</span></figcaption><table><tr><td class="code"><pre><span class="line">// create wrapper function</span><br><span class="line">  var wrapper = Module.wrap(content);</span><br><span class="line">  var compiledWrapper = runInThisContext(wrapper, &#123; filename: filename &#125;);</span><br><span class="line">...</span><br><span class="line">  var args = [self.exports, require, self, filename, dirname];</span><br><span class="line">  return compiledWrapper.apply(self.exports, args);</span><br></pre></td></tr></table></figure>
<p>上面是一小段compile的代码，执行到这里的顺序是_load -&gt; _extensions[‘.js’] -&gt; _compile.<br>可以看到确实进行了wrap操作，将js文件中的内容wrap成一个function, 最后传入self.exports (module.exports)，这样module.exports便继承了原JS执行的结果。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript Scope</title>
    <url>/2015/01/30/Javascript-Scope/</url>
    <content><![CDATA[<blockquote>
<p>The extent of a scope refers to the lifetime of a variable (i.e., how long a variable holds a certain value)</p>
</blockquote>
<h3 id="Global-Scope"><a href="#Global-Scope" class="headerlink" title="Global Scope"></a>Global Scope</h3><p>Javascript中任意不使用var创建的变量具有全局作用域。</p>
<figure class="highlight javascript"><figcaption><span>global</span></figcaption><table><tr><td class="code"><pre><span class="line">globalVariable = <span class="string">&quot;global&quot;</span>;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(globalVariable);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">-&gt; <span class="variable language_">global</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> globalVariable;</span><br><span class="line"></span><br><span class="line">-&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>当然，任意定义在文件最顶层的变量，事实上，由于<a href="http://yanqian.me/2015/01/27/Javascript-Hoisting/">Javascript Hositing</a>作用，所有定义在最外层的变量都会被提升至作用域首部，都具有全局作用域。</p>
<p>值得注意的是使用var定义的变量是不能delete的，它不是全局变量的属性：</p>
<figure class="highlight javascript"><figcaption><span>del_variable</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVariable = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> globalVariable;</span><br><span class="line"></span><br><span class="line">-&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>除此之外，任意被暴露到最外层的变量，一旦被全局作用域捕获，其本身都会存在被随意修改的风险。</p>
<h3 id="Lexical-Scope"><a href="#Lexical-Scope" class="headerlink" title="Lexical Scope"></a>Lexical Scope</h3><blockquote>
<p>Lexical scope refers to the visibility of a variable and its value analogous to its textual representation.</p>
</blockquote>
<p>Javascript会从内向外寻找变量的绑定，所以变量的定义距离使用处最近，则该变量会被使用。</p>
<figure class="highlight javascript"><figcaption><span>lexical_scope</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lexicalScope</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> lexicalVariable = <span class="string">&quot;outer&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> lexicalVariable = <span class="string">&quot;inner&quot;</span>;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(lexicalVariable);</span><br><span class="line">		(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="keyword">var</span> lexicalVariable = <span class="string">&quot;innerMost&quot;</span>;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(lexicalVariable);</span><br><span class="line">		&#125;)();</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(lexicalVariable);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">lexicalScope</span>();</span><br><span class="line">-&gt; inner</span><br><span class="line">innerMost</span><br><span class="line">inner</span><br></pre></td></tr></table></figure>

<h3 id="Dynamic-Scope"><a href="#Dynamic-Scope" class="headerlink" title="Dynamic Scope"></a>Dynamic Scope</h3><blockquote>
<p>the value of any given binding cannot be known until the caller of any given function is known— which may be too late.</p>
</blockquote>
<figure class="highlight javascript"><figcaption><span>dynamic_scope</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">globalThis</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125;</span><br><span class="line"><span class="title function_">globalThis</span>();</span><br><span class="line">-&gt; some <span class="variable language_">global</span> object, probably <span class="title class_">Window</span></span><br><span class="line">globalThis.<span class="title function_">call</span>(<span class="string">&#x27;barnabas&#x27;</span>);</span><br><span class="line">-&gt; <span class="string">&#x27;barnabas&#x27;</span></span><br><span class="line">globalThis.<span class="title function_">apply</span>(<span class="string">&#x27;orsulak&#x27;</span>, [])</span><br><span class="line">-&gt; <span class="string">&#x27;orsulak&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在Javascript中，<em>this</em>所处的作用域就是动态作用域。也就是说，<em>globalThis()<em>返回值完全由调用方决定，</em>this</em>变量的对照表是不断改变的。更多参考<a href="http://yanqian.me/2014/10/11/funcation-scope/">这里</a></p>
<h3 id="Function-Scope"><a href="#Function-Scope" class="headerlink" title="Function Scope"></a>Function Scope</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function strangerIdentity(n) &#123;</span><br><span class="line">	for(this[&#x27;i&#x27;] = 0; this[&#x27;i&#x27;] &lt; n; this[&#x27;i&#x27;]++);</span><br><span class="line">	return this[&#x27;i&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- case 1</span><br><span class="line">strangerIdentity(100);</span><br><span class="line">-&gt; 100</span><br><span class="line">i</span><br><span class="line">-&gt; 100</span><br><span class="line"></span><br><span class="line">--- case 2</span><br><span class="line">var id = new strangerIdentity(100);</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">-&gt; strangerIdentity &#123;i: 100&#125;</span><br><span class="line">id.i</span><br><span class="line">-&gt; 100</span><br><span class="line">i</span><br><span class="line">-&gt;  Uncaught ReferenceError: i is not defined</span><br></pre></td></tr></table></figure>
<p>在Javascript中，只有一个<strong>Function</strong>才会产生新的作用域。直接调用一个funcation，其内部的指针指向global对象。但当使用<em>new</em>后，其作用域绑定到一个<strong>Function Object</strong>上。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Testable Javascript</title>
    <url>/2015/02/01/Testable-Javascript/</url>
    <content><![CDATA[<blockquote>
<p>singletons suffer state pollution between tests</p>
</blockquote>
<figure class="highlight javascript"><figcaption><span>singletons.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">	<span class="attr">counter</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">inc</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ++<span class="variable language_">this</span>.<span class="property">counter</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><figcaption><span>test.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="built_in">require</span>(<span class="string">&#x27;singletons&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">testCase</span>(&#123;</span><br><span class="line">    <span class="string">&quot;should equal one after calling inc&quot;</span>: <span class="keyword">function</span> (<span class="params">test</span>) &#123;</span><br><span class="line">        test.<span class="title function_">equal</span>(<span class="number">1</span>, singleton.<span class="title function_">inc</span>());</span><br><span class="line">        test.<span class="title function_">done</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;should get one after calling inc&quot;</span>: <span class="keyword">function</span>(<span class="params">test</span>) &#123;</span><br><span class="line">    	test.<span class="title function_">equal</span>(<span class="number">1</span>, singleton.<span class="title function_">inc</span>());</span><br><span class="line">    	test.<span class="title function_">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>结果第二个测试会失败，但是从测试本身是看不出为什么第一个可以通过，而第二个则相反。当然，我们可以通过<code>setUp</code>或<code>tearDown</code>方法来重置对象的状态，但是这无疑增加了维护测试的成本，你得记着重置对象这件事本身就是负担。</p>
<p>下面就是解决方案</p>
<figure class="highlight javascript"><figcaption><span>singletons_impr.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">counter</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="attr">inc</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> ++<span class="variable language_">this</span>.<span class="property">counter</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再看我们的测试</p>
<figure class="highlight javascript"><figcaption><span>test.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="built_in">require</span>(<span class="string">&#x27;singletons_impr&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">testCase</span>(&#123;</span><br><span class="line">    <span class="string">&quot;should equal one after calling inc&quot;</span>: <span class="keyword">function</span> (<span class="params">test</span>) &#123;</span><br><span class="line">        test.<span class="title function_">equal</span>(<span class="number">1</span>, <span class="title function_">singleton</span>().<span class="title function_">inc</span>());</span><br><span class="line">        test.<span class="title function_">done</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;should get one after calling inc&quot;</span>: <span class="keyword">function</span>(<span class="params">test</span>) &#123;</span><br><span class="line">    	test.<span class="title function_">equal</span>(<span class="number">1</span>, <span class="title function_">singleton</span>().<span class="title function_">inc</span>());</span><br><span class="line">    	test.<span class="title function_">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>这样两次返回的对象都是全新的，测试通过。</p>
<p>不过，似乎这样让测试变得更加麻烦了，好处不明显。但是结合这篇文章<a href="http://yanqian.me/2015/01/27/Javascript-Modularize-2nd/">[Javascript Modularize 2nd]</a>，就会巧妙地解决多个模块依赖某一个模块，某个模块修改被传染至其他模块的问题。因为每个被引入的模块都将被重新执行生成一遍，成为独立的对象。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li><code>module.exports</code>最好使用<code>function</code>方式导出。</li>
</ul>
<p>参考链接<br>[1]  <a href="http://www.adequatelygood.com/Writing-Testable-JavaScript.html">Writing Testable JavaScript</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript Promise</title>
    <url>/2015/02/03/Javascript-Promise/</url>
    <content><![CDATA[<p>Promise对象最早被C++工程师使用，接着以Deferred对象出现在Python中。随着NodeJS的兴起，Promise在javascript中的应用越来越广。</p>
<p>大凡技术成熟之后都会逐渐形成一个标准，Promise的标准定义在<a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS</a>中，全称是<a href="http://wiki.commonjs.org/wiki/Promises/A">Promise&#x2F;A</a>，不过新近出现了改良版的<a href="https://promisesaplus.com/">Promise&#x2F;A+</a>，只不过它仅仅对原来的标准部分澄清，同时依据实践稍作扩展。</p>
<blockquote>
<p>The core Promises&#x2F;A+ specification does not deal with how to create, fulfill, or reject promises, choosing instead to focus on providing an interoperable(协作的) <strong>then</strong> method. Future work in companion specifications may touch on these subjects.</p>
</blockquote>
<p>但是使用Promise还是有些地方值得留意的。</p>
<h4 id="1-Then的Resovler-Function不返回任何值"><a href="#1-Then的Resovler-Function不返回任何值" class="headerlink" title="1. Then的Resovler Function不返回任何值"></a>1. Then的Resovler Function不返回任何值</h4><hr>
<p>举个例子，打印deferred数组的首个元素</p>
<figure class="highlight javascript"><figcaption><span>promise_sample.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printFirstAndLast</span>(<span class="params">itemsDeferred</span>)&#123;</span><br><span class="line">    <span class="title function_">findFirst</span>(itemsDeferred).<span class="title function_">then</span>(util.<span class="property">puts</span>); <span class="comment">//=&gt; 0</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">last</span>(itemsDeferred).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">last</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> deferred = <span class="title function_">defer</span>();</span><br><span class="line">        deferred.<span class="title function_">resolve</span>(last);</span><br><span class="line">        <span class="title function_">findFirst</span>(deferred).<span class="title function_">then</span>(util.<span class="property">puts</span>) <span class="comment">//=&gt; 1</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result:&#x27;</span>, result); <span class="comment">//=&gt; 2</span></span><br><span class="line">    &#125;, <span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason:&#x27;</span>, reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">last</span>(<span class="params">itemsDeferred</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> itemsDeferred.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">items</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="title function_">slice</span>(<span class="number">1</span>, items.<span class="property">length</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findFirst</span>(<span class="params">itemsDeferred</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> itemsDeferred.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">items</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="keyword">var</span> deferred = <span class="title function_">defer</span>();</span><br><span class="line">deferred.<span class="title function_">resolve</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="title function_">printFirstAndLast</span>(deferred);</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="attr">result</span>: <span class="literal">undefined</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>从输出看，由于我故意没有返回1处的Promise对象，最后一个<em>then</em> 的2处代码先被执行，打印出undefined，然后才会执行完1处的代码，打印出数字2。</p>
<p>这样的现象有两处值得注意的地方</p>
<ul>
<li>执行顺序混乱</li>
<li>最后then的结果是undefined</li>
</ul>
<p>顺序混乱是由于标识为1处的resolve的时间较长，回调的时间较久，所以后执行。</p>
<p> 2处为undefined，是因为1处没有返回值，<strong>我们知道javascript的function始终会返回值且这两种方式：<code>return;</code>(返回void)和不显式写return语句都会返回undefined</strong>。所以将值为undefined的promise对象传给下一个<em>then</em>方法。</p>
<h4 id="2-Then的Rejector-Function不返回Reject-Promise"><a href="#2-Then的Rejector-Function不返回Reject-Promise" class="headerlink" title="2. Then的Rejector Function不返回Reject Promise"></a>2. Then的Rejector Function不返回Reject Promise</h4><hr>
<figure class="highlight javascript"><figcaption><span>reject.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printFirstAndLast</span>(<span class="params">itemsDeferred</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> itemDeferred.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;, <span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">        util.<span class="title function_">puts</span>(<span class="string">&#x27;1:&#x27;</span>+reason);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;error-1&#x27;</span>;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>)&#123;</span><br><span class="line">        util.<span class="title function_">puts</span>(<span class="string">&#x27;resolve 2:&#x27;</span>+result);</span><br><span class="line">    &#125;, <span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">        util.<span class="title function_">puts</span>(<span class="string">&#x27;reject 2:&#x27;</span>+reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deferred = <span class="title function_">defer</span>();</span><br><span class="line">deferred.<span class="title function_">reject</span>(<span class="string">&#x27;error-0&#x27;</span>);</span><br><span class="line"><span class="title function_">printFirstAndLast</span>(deferred);</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line"><span class="number">1</span>: error-<span class="number">0</span></span><br><span class="line">resolve <span class="number">2</span>:error-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>从输出看，如果reject function不返回reject promise，而只是<code>error-1</code>这样的值，那么调用then方法，执行的还是resolve方法。</p>
<p>从Promise&#x2F;A+参考描述可证明上述</p>
<blockquote>
<p>promise2 &#x3D; promise1.then(onFulfilled, onRejected);</p>
<p>If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</p>
<p>If x is a thenable, it attempts to make promise adopt the state of x, under the assumption that x behaves at least somewhat like a promise. Otherwise, it fulfills promise with the value x.</p>
</blockquote>
<h4 id="3-Then的Resolver-Function返回的是对象，而且包含then方法"><a href="#3-Then的Resolver-Function返回的是对象，而且包含then方法" class="headerlink" title="3. Then的Resolver Function返回的是对象，而且包含then方法"></a>3. Then的Resolver Function返回的是对象，而且包含then方法</h4><hr>
<figure class="highlight javascript"><figcaption><span>obj_then.js</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolver, reject</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">resolver</span>(<span class="string">&#x27;i am an obj.&#x27;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printFirstAndLast</span>(<span class="params">itemsDeferred</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> itemDeferred.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;, <span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">        util.<span class="title function_">puts</span>(<span class="string">&#x27;1:&#x27;</span>+reason);</span><br><span class="line">        <span class="keyword">return</span> obj; 						<span class="comment">//=&gt; 1</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>)&#123;</span><br><span class="line">        util.<span class="title function_">puts</span>(<span class="string">&#x27;resolve 2:&#x27;</span>+result);</span><br><span class="line">    &#125;, <span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">        util.<span class="title function_">puts</span>(<span class="string">&#x27;reject 2:&#x27;</span>+reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deferred = <span class="title function_">defer</span>();</span><br><span class="line">deferred.<span class="title function_">reject</span>(<span class="string">&#x27;error-0&#x27;</span>);</span><br><span class="line"><span class="title function_">printFirstAndLast</span>(deferred);</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line"><span class="number">1</span>: error-<span class="number">0</span></span><br><span class="line">resolve <span class="number">2</span>:i am  an obj</span><br></pre></td></tr></table></figure>
<p>从结果看，obj这个含有then方法的对象，在1处被调用了then，同时将<code>resolver(&#39;i am an obj.&#39;)</code>作为Promise返回。</p>
<p>从Promise&#x2F;A+可知</p>
<blockquote>
<p>If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where:</p>
<p>If&#x2F;when resolvePromise is called with a value y, run [[Resolve]](promise, y)</p>
<p>If&#x2F;when rejectPromise is called with a reason r, reject promise with r</p>
</blockquote>
<p>那么如果是以下这些对象</p>
<ul>
<li>{then: ‘something’}</li>
<li>{then: function(){}}</li>
<li>{A: ‘A’}</li>
<li>{then: function(resolver, rejector){return rejector(“error”);}}</li>
</ul>
<p>结果会是</p>
<ul>
<li>resolve 2:[Object Object]</li>
<li>忽略</li>
<li>resolve 2:[Object Object]</li>
<li>reject 2: error</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript Reference</title>
    <url>/2015/01/28/Javascript-Reference/</url>
    <content><![CDATA[<p>Javascript的赋值操作就是引用修改，举个例子：</p>
<figure class="highlight javascript"><figcaption><span>reference.js</span><a href="https://github.com/heldr/grunt-properties">grunt-properties</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">splitKeys</span>(<span class="params">obj, splitter</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> keys, value, parent, result = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">          keys = key.<span class="title function_">split</span>(splitter);</span><br><span class="line">          value = obj[key].<span class="title function_">replace</span>(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;\\&quot;&#x27;</span>);</span><br><span class="line">          parent = result;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; keys.<span class="property">length</span>-<span class="number">1</span>; j++) &#123;</span><br><span class="line">              parent = parent[keys[j]] = parent[keys[j]] || &#123;&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          parent[keys[keys.<span class="property">length</span>-<span class="number">1</span>]] = value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(result, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码将Java程序中的常见的Properties文件中的键值映射成了嵌套的JSON对象:</p>
<figure class="highlight javascript"><figcaption><span>test.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;country.province.city&quot;</span>: <span class="string">&quot;Chengdu&quot;</span>&#125;;</span><br><span class="line"><span class="title function_">splitKeys</span>(obj, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">-&gt; <span class="string">&quot;&#123;</span></span><br><span class="line"><span class="string">  &quot;</span>country<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;</span>province<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;</span>city<span class="string">&quot;: &quot;</span><span class="title class_">Chengdu</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们从实现代码的这行开始看起<code>parent = result;</code>，很简单地把<code>parent</code>指向<code>result</code>这个空对象。</p>
<p>再看接下来的代码，也是最巧妙的地方：</p>
<figure class="highlight javascript"><figcaption><span>parts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; keys.<span class="property">length</span>-<span class="number">1</span>; j++) &#123;</span><br><span class="line">     parent = parent[keys[j]] = parent[keys[j]] || &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次循环：<br>parent开始是空对象，<code>parent = parent[&#39;country&#39;] = parent[&#39;country&#39;] || &#123;&#125;;</code>，将会生成一个parent的country属性，该属性的值还是一个空对象。于此同时，parent会指向新生成的、也即它的country属性。</p>
<p>第二次循环：<br>parent指向了country，<code>parent = parent[&#39;province&#39;] = parent[&#39;province&#39;] || &#123;&#125;;</code>也即<code>parent = country[&#39;province&#39;] = country[&#39;province&#39;] || &#123;&#125;;</code>，此时，将会生成一个country的province属性，该属性的值还是一个空对象，而parent则指向了province对象。</p>
<p>所以<code> parent[keys[keys.length-1]] = value;</code>等价为<code>province[&#39;city&#39;] = &quot;Chengdu&quot;;</code></p>
<p>最后，<code>return JSON.stringify(result, null, 2);</code>，这最后的result就是具有嵌套效果的JSON对象了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java陷阱和缺陷</title>
    <url>/2015/03/11/pit-and-trap-in-Java/</url>
    <content><![CDATA[<h4 id="String-valueOf"><a href="#String-valueOf" class="headerlink" title="String.valueOf"></a>String.valueOf</h4><hr>
<figure class="highlight java"><figcaption><span>example.java</span></figcaption><table><tr><td class="code"><pre><span class="line">String.valueOf(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">java.lang.NullPointerException</span><br></pre></td></tr></table></figure>
<p>why does it cause excepation? Java call the wrong method because type match!</p>
<figure class="highlight java"><figcaption><span>String.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> data[])</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = Arrays.copyOf(value, value.length); <span class="comment">//=&gt; cause exception.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>how to correct?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf((Object)<span class="literal">null</span>)</span><br><span class="line">-&gt;</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h4 id="Varargs-bug"><a href="#Varargs-bug" class="headerlink" title="Varargs bug"></a>Varargs bug</h4><hr>
<p>Changes in Most Specific Varargs Method Selection<br>Description: The overload resolution algorithm in the javac compiler has been fixed in how it selects the most specific varargs method when more than one method is applicable to a given call-site (see the JLS, Java SE 7 Edition, section 15.12.2.5). Because of a bug, both JDK 5.0 and JDK 6 compilers reject the following legal code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    void foo(int... i) &#123;&#125;</span><br><span class="line">    void foo(double... d) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void test() &#123;</span><br><span class="line">       foo(1,2,3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the above example, both methods are applicable (because you can pass an int where a double is expected). Since both methods are applicable, the compiler must select the so-called most-specific method, that is, the best candidate among the two. This is done by looking at the signatures of both methods; in this case, since one method (foo(double…)) is accepting an argument that is more general than the other (foo(int…)), the answer is straightforward: the most specific method is foo(int…).<br>While the javac compiler accepts more code than it did prior to JDK 7, this fix also results in a slight source incompatibility in the following case:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    void foo(int... i) &#123;&#125;</span><br><span class="line">    void foo(Object... o) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void test() &#123;</span><br><span class="line">       foo(1,2,3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code compiles in JDK 6 (the most specific method is foo(int…)). This code does not compile under JDK 7. As per 15.12.2.5, it is not possible to choose between foo(int…) and foo(Object…) as neither int is a subtype of Object, nor Object is a subtype of int. This program should be disallowed (in fact, it should never have been allowed in the first place).</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Mistakes I Hav Made</tag>
      </tags>
  </entry>
  <entry>
    <title>你说</title>
    <url>/2015/06/21/you-said/</url>
    <content><![CDATA[<p>你说，昨天。</p>
<p>有一片天地，</p>
<p>在氤氲的叹息里，</p>
<p>幻做纸张，</p>
<p>将我和你写入了泛黄。</p>
<p>你说，今天。</p>
<p>我只是一支尾音，</p>
<p>很小心地，</p>
<p>从你的心底淌出。</p>
<p>然后，</p>
<p>躲在雨水里——变轻。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>poetry</tag>
      </tags>
  </entry>
  <entry>
    <title>ThoughtWorks training</title>
    <url>/2015/07/18/ThoughtWorks-training/</url>
    <content><![CDATA[<h2 id="ThoughtWorks培训"><a href="#ThoughtWorks培训" class="headerlink" title="ThoughtWorks培训"></a>ThoughtWorks培训</h2><p>在过去的几年里，为了进一步提升ThoughtWorks在业界的影响力，扩张无疑是最为有效的策略。但是，以提供知识流程外包（KPO）作为主要业务的ThoughtWorks，人员的成长变成了业务增长的主要瓶颈。构建“学习型组织”，减少从0(新人)到1(能够提供专业服务)经历的时间变得迫在眉睫。</p>
<h3 id="现状和思考"><a href="#现状和思考" class="headerlink" title="现状和思考"></a>现状和思考</h3><p>对于培训，公司投入了大量的人力物力，我们仍然在思考和摸索什么是最有效的培训方式。如何快速培养一名合格的TWer？在当前招聘策略下，这是一个严峻的问题。由什么来指导我们做“正确“的培训，培训什么、怎么培训以及能不能达到我们的预期这些都尚未可知。</p>
<p>培训是需要反馈周期的，假设首次教学目的(收集受众能力metrics，得出初步结论)，导入教学形式(是讲理论，做实践还是改变习惯)并对当前的产出做出量化评估(学员能力分级)。形成教学目的&gt;教学形式&gt;量化评估&gt;修改当前教学目的&#x2F;下次教学目的的闭环，逐步提高培训的质量和效率。</p>
<p>以学前班的郑大夜校为例，我们已经实践了很多期。不否认地，很多毕业生从中获益颇丰，入了ThoughtWorks的门坎。但是，我们也不得不正视每期结束后褒贬不一的反馈。我们不妨试着剖析反馈背后的问题，从一个个点切入，顺藤摸瓜，反观教学的形式、目的和整个郑大夜校编排的合理性。</p>
<p>首先我们回顾一下本期郑大夜校的阶段安排</p>
<blockquote>
<p>阶段一（毕业到年前）：<br>静态语言阶段</p>
</blockquote>
<blockquote>
<p>阶段二（年后到入职前）：<br>动态语言阶段</p>
</blockquote>
<blockquote>
<p>阶段三（入职后一个月内）：<br>工程实践阶段</p>
</blockquote>
<p>第一阶段主要囊括了Java语言，面向对象编程，设计原则和模式等内容，采取了讲师讲解，学生提问交流和练习的方式；</p>
<p>第二阶段预计采用Javascript语言，应用动态语言的特性重新实现第一阶段的练习。但是事实上，由于培训人员变动等原因，该阶段没有遵循预期计划，而是直接进入了阶段三。</p>
<p>第三阶段，毕业生应用我们平时工作的流程和使用的工具，参与实现一个公司内部的固定资产管理系统，用XR的话来说就是将思想上的东西应用落地。</p>
<p>经过两期的培训，通过毕业生自己的在retro上的反馈以及各位mentor的观察，大体上可以看出毕业生对于第一阶段的培训内容和形式还是很认可的。比较有趣的是培训中就已经有人明确告诉我他自己越来越不会写代码了，这并不是说他能力不行，反而恰恰说明他正在提升，也证实我们培训的目的达到了——对于整个软件行业以及自身能力有清晰的认识。但是必须承认这个例子不是普遍现象，思想上的东西不是一蹴而就的，而且也不能轻松量化以待检验，至少基于当前的教学形式还做不到。</p>
<p>对于第二阶段的培训，学生普通反映引入的工具和框架过多，再加上课程安排松散，每个迭代的目的不甚明确，严重拖延了项目的进度，结果距离完成的目标尚远。而从mentor的角度，理论到实践的落地过程预估得还是过于乐观，不过这个罅隙在和senior dev的结对过程中得到了有效的弥合。</p>
<p>那么问题是我们现在的问题是什么？</p>
<p>在回答这个问题之前，我们先问自己一个问题：</p>
<h4 id="公司想要把毕业生培养成什么人？"><a href="#公司想要把毕业生培养成什么人？" class="headerlink" title="公司想要把毕业生培养成什么人？"></a>公司想要把毕业生培养成什么人？</h4><p>如果答案是一群高级技工。那么我觉得郑大夜校可以不存在，直接找一群senior dev和这些新人pair，手把手教授过程和工具，模仿着码代码。因为基于我们的培训结果，这样的效果是最快最直接的。</p>
<p>若答案是对技术有兴趣、有想法和自主学习的geek。我们就要真的从毕业生角度出发，明确他们缺少什么能力以及如何弥补这些短板。</p>
<p>那么我就以答案二为假设，结合本期培训，展开问题的论述：</p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><hr>
<p>验证理解是否到位最好的方式是做练习。问题是一些学生没能完成课上的配套练习，课后也未必补上。这点与课程设置缺少检验环节必然相关，但归根结底是学生缺乏主动性。那什么叫做有主动性？同样是布置POS机的作业，有学生在每一次培训后都会持续改进自己的程序，将新的知识点实现一遍。没人强制这么做，但他做了就是主动。</p>
<p>问题一来了，学生缺乏主动性。该如何解决这一问题？</p>
<blockquote>
<p>第一，我不认为学生缺少学习的动力，那么可能的原因是没有明确的期望和目标。期望和目标应当来自于未来的雇主。<a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">这里</a>有详细的论述，我就不再赘述。</p>
<p>第二，组内职责轮换。基于本期分组教学的模式，我们已经尝试分派一些职责，效果良好。职责轮换可以让学生因感受到压力而成长。</p>
<p>第三，建立惩罚制度。对于mentor而言，我们并没有有力的手段给予学生压力，我们至多会告诫说若表现不好，会影响其过试用期，但是，这样的压力距离太远。所以建议提前建立因技能等评估维度（后面会详细讨论）严重不足而拒绝offer的制度。</p>
</blockquote>
<p>以上解决问题的建议是基于现有的教学形式提出的。经过和DW的讨论，这一问题或许反映了原有的教学形式本身就存在漏洞。</p>
<blockquote>
<p>我们依旧遵循大学的填鸭式教学模式。要知道没有哪个行业像IT行业这样特殊：没有什么东西不能够（应该）在互联网上学到的。我们何妨换个思路，将以前的课上讲授，课后练习，下次课上检验的方式改变成提前提供课题和所用教学资源，课前学生自己学习，课上解惑的模式。这样可以最大化调动学生自主学习能力，而且学生带着问题上课的效率也远高于直接教学。</p>
</blockquote>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><hr>
<blockquote>
<p>问题二：我们第二阶段的初衷其实是将第一阶段的思想方面的东西落地。但是大量的工具和框架，这些干扰因素严重分散了学生的注意力，原本检验学生设计和创造能力的时间被极大地缩短了。</p>
<p>问题三：课程安排松散，迭代的目的不清则更为严重。这反映了郑大夜校本身就是不规范的，集中体现在讲师变动频繁、能力良莠不齐，授课内容临时起意，内部的目标不清不楚等。</p>
</blockquote>
<p>针对问题二，我们首先再次明确公司需要的是对技术有兴趣、有想法和自主学习的geek。所以建议不强制学生学习使用工具和框架，尽量选用简单的技术栈，重点检验设计能力。</p>
<p>问题三，这样的现象一直存在，而且涉及的问题有点多，我们慢慢剖析。</p>
<blockquote>
<p>第一，讲师变动频繁、能力良莠本身不应该是个问题，这点可以参考TWU的办学模式。关键还是如何标准化。</p>
<p>第二，授课内容不固定，典型反映在临时找的session上，涉及Agile演化、scrum workshop、业务、QA和Dev技能等各个方面。考虑时间限制和学生的接受能力，对于学前班的郑大夜校而言，这样的scope未免过于庞大。或许需要重新定义郑大夜校的scope，例如：将培养卓越的软件能力提到首位，而将P1和P3的侧重弱化，延迟到TWU和On Board Training上。</p>
<p>第三，相较于TWU，郑大夜校缺少了一个P2P feedback的环节，我们也不知道经过培训什么样的人就满足公司的期望。这就引出了量化指标，可想而知，量化指标不是绝对量，它应该是相对于以前能力模型的增长量。举个例子：从70分上升到80分和从10分上升到60分体现得是后者成长空间更大。量化指标需要根据夜校的scope，划分出能力象限，因为我们能考察的不应该越界。</p>
</blockquote>
<p>孔子曰：温故而知新，可以为师矣。我们做个recap。</p>
<h3 id="教学目的"><a href="#教学目的" class="headerlink" title="教学目的"></a>教学目的</h3><hr>
<ul>
<li>拓宽毕业生的软件开发的视野，明确自身能力</li>
<li>帮助公司尽早筛选可用之才</li>
</ul>
<h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><hr>
<ul>
<li>颠覆填鸭式教学，自学为主，解惑为辅</li>
<li>分组，轮换职责</li>
<li>入职前惩罚制度</li>
<li>制定标准的教学流程</li>
<li>限定夜校教学范围</li>
<li>制定量化指标</li>
</ul>
<h3 id="量化评估"><a href="#量化评估" class="headerlink" title="量化评估"></a>量化评估</h3><hr>
<ul>
<li>有待确定能力象限。</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>聚合，组合与IoC</title>
    <url>/2015/07/26/aggregation-composition-IoC/</url>
    <content><![CDATA[<h4 id="为什么我们说多用组合，少用继承？"><a href="#为什么我们说多用组合，少用继承？" class="headerlink" title="为什么我们说多用组合，少用继承？"></a>为什么我们说多用组合，少用继承？</h4><hr>
<p>继承具有强耦合(strog coupling)特点。根据里氏替换原则(Liskov Substitution Principle LSP)，基类出现的地方，子类一定能透明地替代。本质上来讲，LSP的这种特性致使基类具有很强的病毒蔓延性(invasive)，因为如何基类设计的不好，会侵蚀所有的子类。举个例子，基类是鸟，同时具有<code>fly</code>这样的方法，子类中如果有鸵鸟或企鹅，就必须继承<code>fly</code>方法，然而这显然是没有意义的。</p>
<p>继承因为强耦合，所以不好测试。举个例子，有一个<code>RemoteXMLFile&lt;Res&gt;</code>基类，它内部有个<code>Res to()</code>方法，旨在把远程的XML文件转换成具体的Response。在我们准备测试<code>to</code>方法的转换逻辑的时候，每个对应子类的测试类里都不得不准备丑陋冗余的<code>XML</code>字面值字符串，尤其是在Java里。之所以这样，是因为无法隔离出一个专门读取<code>XML</code>的抽象屏障，然后使用Mock隔离这层抽象。</p>
<p>组合的好处自然是松耦合(loose coupling)。如果严格遵循依赖倒置原则(Dependency Inversion Principle),那么类本身一定是高能聚，类之间是松耦合的。除此之外，测试起来，各层之间的逻辑清晰明了，易于隔离开来做单元测试(Unit test)。</p>
<h4 id="谈谈聚合和组合的区别"><a href="#谈谈聚合和组合的区别" class="headerlink" title="谈谈聚合和组合的区别"></a>谈谈聚合和组合的区别</h4><hr>
<p>UML里有很多表示关联的线段，有两个关系十分相近，它们是聚合(aggregation)和组合(composition)</p>
<blockquote>
<p>聚合：表示两个对象之间是整体和部分的弱（弱拥有）关系，部分的生命周期可以超越整体。如电脑和鼠标。</p>
</blockquote>
<blockquote>
<p>组合：表示两个对象之间是整体和部分的强（强拥有）关系，部分的生命周期不能超越整体，或者说不能脱离整体而存在。组合关系的“部分”，是不能在整体之间进行共享的。</p>
</blockquote>
<p>以上是网络上的标准解释，应该是没错。但是实践中依然让人困惑不已。汽车和引擎，这个还比较好理解，汽车报废了，引擎还是可以换给别的汽车用的嘛。这就实现了整体之间的共享——聚合无疑。但是值得注意的一点是：从未说过部分的生命周期小于整体，也就是一定是大于或者等于整体的生命周期的。所以千万别和别人争论，引擎报废了，汽车就没用了，因为在程序中一定是某个第三方供应商维护引擎的生命周期，所以引擎和汽车没有相互维持对方生命周期的联系。</p>
<p>但是比较困惑就是这个生命周期理论！IoC容器提供给我们使用的注入方法无非3种，接口注入、构造函数注入、setter方法注入。每一种无不是聚合，因为产生和管理对象的控制权移交到IoC容器了。那我们口口声声的说组合优于继承其实一直都是聚合优于继承。</p>
<p>那是不是说，有了IoC之后，组合就应该消失呢，当然不是的。例如，某个场景里，一个类确实需要分离出一部分职责交给另外一个类，比如Builder，这部分构建实例的职责就可以通过<code>new Builder()</code>的方式组合应用起来。</p>
<figure class="highlight java"><figcaption><span>Builder_Pattern</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Builder</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Builder &#123;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">withName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.name = name;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">withAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> Person <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">			person.name = name;</span><br><span class="line">			person.age = age;</span><br><span class="line">			<span class="keyword">return</span> person;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> Person.builder().withName(<span class="string">&#x27;Ryan&#x27;</span>).withAge(<span class="number">18</span>).build();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><hr>
<ul>
<li>组合优于继承</li>
<li>因为IoC的存在，上句话得改成聚合优于继承</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>Transaction</title>
    <url>/2015/07/18/transaction/</url>
    <content><![CDATA[<h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><hr>
<h2 id="事务是一组不可分割的SQL-query语句，或者说是一个最小的工作单元。-事务与锁的关系"><a href="#事务是一组不可分割的SQL-query语句，或者说是一个最小的工作单元。-事务与锁的关系" class="headerlink" title="事务是一组不可分割的SQL query语句，或者说是一个最小的工作单元。### 事务与锁的关系"></a>事务是一组不可分割的SQL query语句，或者说是<strong>一个最小的工作单元</strong>。<br>### 事务与锁的关系</h2><h4 id="为什么提出这个问题"><a href="#为什么提出这个问题" class="headerlink" title="为什么提出这个问题"></a>为什么提出这个问题</h4><p>在阅读《Java虚拟机并发编程》(Programming Concurrency on the JVM - Materning Synchronization, STM and Actors)中STM(Software Transaction Memory)时，我看到transaction特征在concurrency中的神奇应用场景：</p>
<ul>
<li>原子性：涉及一组操作，这组操作具有原子特征，比如存款和取款的组合操作。这组操作内部的所有更改要么全部成功，要么全部失败。</li>
<li>一致性：所有并行的事务所造成的变更，从外部来看，都是一个接一个发生的。比如：存款，取款这两个独立事务。如果存款的过程中间，取款操作接入，那么取款读取的数据是旧的。待存款恢复并执行完毕，取款想要写回的数据必然无效。取款事务需要重做！所以外观来看这是存款到取款的序列，反之亦然。其实本质上，就是可见性的问题。</li>
<li>不需要显式地运用锁，不论是读锁还是写锁。这样就为程序员提供了比较好的抽象屏障(abstract barrier)。</li>
<li>隔离性：事务在未提交之前，所做的任何更改都不能被其他事务看到。</li>
</ul>
<p>我看到了很多STM的好处，但是看到处理写偏斜异常(Handling Write Skew Anomaly)（可以简单理解为两个事务修改的变量不是同一个，但是两个变量之间又有约束关系）一章时，作者使用<code>ensure</code>函数给约束变量加了读锁。加读锁的意义在于本事务之外，其他事务无法获得该变量的写锁，自然无法修改它的值。但是这里显式地使用了锁，所以可以明确事务不是锁无关的，而且这让我联想到了数据库事务隔离级别中的可重复读(REPEATABLE_READ)。可重复读也是使用在特定记录行上使用读锁，来防止外部事务修改了该条记录行。</p>
<h4 id="微妙的关系"><a href="#微妙的关系" class="headerlink" title="微妙的关系"></a>微妙的关系</h4><p>有趣的事情来了，事务原子性能确保数据的完整性，而事务的一致性和隔离性则侧重于数据的可见性。可见性的保证在并发当中绝对和锁相关。我刚说了，事务给锁提供了抽象屏障，而且事务的隔离级别依旧仰仗锁的粒度，所以不要将事务看做银弹，以为有了事务，锁就不值一提。</p>
<h3 id="数据库事务的隔离级别"><a href="#数据库事务的隔离级别" class="headerlink" title="数据库事务的隔离级别"></a>数据库事务的隔离级别</h3><hr>
<h4 id="为什么提出这个问题-1"><a href="#为什么提出这个问题-1" class="headerlink" title="为什么提出这个问题"></a>为什么提出这个问题</h4><p>一直被《高性能MySQL》里的解释弄得稀里糊涂，纠结于脏读、不可重复读和幻读之间的关系。而且某些解释看似合理，但完全没有指导价值。比如：阐述隔离级别，却没法从中得出我们如何结合应用场景选择合适的隔离级别。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul>
<li><p>Uncommited Read<br>一个事务未提交，另一个事务却能读到该事务所做的更改。因为有可能读到未提交到数据库里的脏数据，这一级别会导致脏读。适用于只读场景下。</p>
</li>
<li><p>Commited Read<br>未提交之前，事务之间是不可见的，所以可以阻止脏读。<br>但是会导致不可重复读问题，也就是在本事务内，读取一条记录，另一个事务修改了此条记录并提交，本事务再读取同一条记录时，发现得到记录和前一条不一致的场景。这一级别也被称为不可重复读级别。<br><strong>但上述场景没有半点指导意义！</strong><br>如果你的应用场景是这样的——你想查询的变量是通过本事务里只读但是对于外部事务可写的变量作为条件查询出来的，那么这个只读变量很可能不可重复读，导致这个事务会失效。举个例子：如果你的查询语句是这样的<code>SELECT USER.age into age FROM USERS name=&#39;YOU&#39;;</code><br>这时候外部事务修改了名字<code>UPDATE SET name=&#39;ME&#39; WHERE name=&#39;YOU&#39;;</code>并提交。那么这时候，<code>age</code>是无效的状态，你再拿来用就有问题了。这一级别适合于读多写少且写偏斜不存在的场景。</p>
</li>
<li><p>Repeatable Read （MySQL的默认隔离级别）<br>可重复读，可以理解给只读的记录行加了读锁。这样，外部事务无法获得写锁，本事务内部这条记录始终有效，待事务结束即可解锁。反之，外部事务先得写锁，那么本事务无法获取记录行的读锁，导致重试发生。显然，如果你的应用场景里，读多写少且读写操作同一条记录的可能性很大的时候适合。</p>
</li>
<li><p>幻读<br>可重复读级别无法防止幻读。幻读是这样一种场景，本事务读取一个<strong>范围内，范围内，范围内（重要的事情写三遍）</strong>的数据集，但是另一事务又向这个范围内插入一条记录，导致数据集发生变化了，像是出现了幻觉，所以称为幻读（我很痛恨一些奇葩的科学家起的不合理的名字，这就是其一。按着这种逻辑，不可重复读不也可以说是出现幻觉吗？）。那么为什么会出现这种情况，原因是新插入的记录以前不存在于数据库中，所以你没法为它加锁。而且可重复读只是为每行记录加锁，没有用到Range Lock，这一幻影插入操作总能成功。<br>不过MySQL中InnoDB存储引擎提供了MVCC（多版本并发控制）技术，为每条记录设置一个递增的事务编号，大于本次事务编号的记录，不准插入记录。<br>可重复读+MVCC即可解决并发中的大部分问题。</p>
</li>
<li><p>Serializable Read<br>顾名思义，串行读，事务之间是串行的，同步的。换言之，并发性剧减。</p>
</li>
</ul>
<h3 id="STM的隔离级别"><a href="#STM的隔离级别" class="headerlink" title="STM的隔离级别"></a>STM的隔离级别</h3><hr>
<ul>
<li>隔离级别处于提交读。</li>
</ul>
<h3 id="事务的级别"><a href="#事务的级别" class="headerlink" title="事务的级别"></a>事务的级别</h3><hr>
<p>描述的是事务本身的属性</p>
<ul>
<li>ReadOnly：所有的操作都是读取操作，不涉及任何产生副作用的操作。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>Concurrency in action</title>
    <url>/2015/07/16/concurrency-in-action/</url>
    <content><![CDATA[<h3 id="什么是竞态条件？"><a href="#什么是竞态条件？" class="headerlink" title="什么是竞态条件？"></a>什么是竞态条件？</h3><hr>
<blockquote>
<p><strong>tips</strong>: The situation where two threads compete for the same resource, where the sequence in which the resource is accessed is significant, is called race conditions. A code section that leads to race conditions is called a critical section. In the below example the method add() is a critical section, leading to race conditions. Race conditions can be avoided by proper thread synchronization in critical sections.<br>两个线程竞争同一个资源，而该资源的访问顺序十分重要的情况就被称为竞态条件。导致竞态条件的代码区就被称为临界区。下面的例子中的add()方法就是一个导致竞态条件的临界区。临界区上合适的线程同步能避免竞态条件。<br>Race conditions arise in software when an application depends on the sequence or timing of processes or threads for it to operate properly.<br>race conditions often happen when the processes or threads depend on some shared state.<br>软件里的竞态条件发生在一个应用程序依赖进程或者线程的执行顺序和时间以确保该程序执行正确的时候。竞态条件总是发生在进程或线程依赖某些共享资源的时候。</p>
</blockquote>
<h4 id="一个临界区的例子："><a href="#一个临界区的例子：" class="headerlink" title="一个临界区的例子："></a>一个临界区的例子：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    protected long count = 0;</span><br><span class="line"></span><br><span class="line">    public void add(long value)&#123;</span><br><span class="line">        this.count = this.count + value;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h3><hr>
<blockquote>
<p><strong>tips</strong>: Code that is safe to call by multiple threads simultanously is called thread safe. If a piece of code is thread safe, then it contains no race conditions.<br>能被多个线程同时安全地调用的代码就是线程安全。如果一段代码是安全的，那么它就不存在竞态条件。</p>
</blockquote>
<ul>
<li>Thread safe: Implementation is guaranteed to be free of race conditions when accessed by multiple threads simultaneously.</li>
<li>Conditionally safe: Different threads can access different objects simultaneously, and access to shared data is protected from race conditions.</li>
<li>Not thread safe: Code should not be accessed simultaneously by different threads.<blockquote>
</blockquote>
</li>
<li>线程安全：实现以保证多个线程同时访问不存在竞态条件</li>
<li>条件安全：不同的线程可以同时访问不同的对象，且在访问共享资源时保护以免于竞态条件</li>
<li>非线程安全：代码不能被多个线程同时访问</li>
</ul>
<h3 id="可见性和竞态条件的关系？"><a href="#可见性和竞态条件的关系？" class="headerlink" title="可见性和竞态条件的关系？"></a>可见性和竞态条件的关系？</h3><hr>
<blockquote>
<p>如果存在竞态条件，那么就必须保证变量的可见性</p>
</blockquote>
<h3 id="可见性和线程安全的关系？"><a href="#可见性和线程安全的关系？" class="headerlink" title="可见性和线程安全的关系？"></a>可见性和线程安全的关系？</h3><hr>
<blockquote>
<p>严格意义上，线程安全其实是相对于非线程安全的，即包含了线程安全和条件安全两部分。</p>
</blockquote>
<p>Below we discuss two approaches for avoiding race conditions to achieve thread safety.</p>
<blockquote>
</blockquote>
<p>The first class of approaches focuses on avoiding shared state, and includes:<br>也就是纯粹的线程安全。</p>
<blockquote>
</blockquote>
<ul>
<li>Re-entrancy<br>  Writing code in such a way that it can be partially executed by a thread, reexecuted by the same thread or simultaneously executed by another thread and still correctly complete the original execution. This requires the saving of state information in variables local to each execution, usually on a stack, instead of in static or global variables or other non-local state. All non-local state must be accessed through atomic operations and the data-structures must also be reentrant.</li>
<li>Thread-local storage<br>  Variables are localized so that each thread has its own private copy. These variables retain their values across subroutine and other code boundaries, and are thread-safe since they are local to each thread, even though the code which accesses them might be executed simultaneously by another thread.<blockquote>
</blockquote>
The second class of approaches are synchronization-related, and are used in situations where shared state cannot be avoided:<br>也就是条件安全部分。<blockquote>
</blockquote>
</li>
<li>Mutual exclusion<br>  Access to shared data is serialized using mechanisms that ensure only one thread reads or writes to the shared data at any time. Incorporation of mutual exclusion needs to be well thought out, since improper usage can lead to side-effects like deadlocks, livelocks and resource starvation.</li>
<li>Atomic operations<br>  Shared data are accessed by using atomic operations which cannot be interrupted by other threads. This usually requires using special machine language instructions, which might be available in a runtime library. Since the operations are atomic, the shared data are always kept in a valid state, no matter how other threads access it. Atomic operations form the basis of many thread locking mechanisms, and are used to implement mutual exclusion primitives.</li>
<li>Immutable objects<br>  The state of an object cannot be changed after construction. This implies both that only read-only data is shared and that inherent thread safety is attained. Mutable (non-const) operations can then be implemented in such a way that they create new objects instead of modifying existing ones. This approach is used by the string implementations in Java, C# and Python.<blockquote>
<p>所以可见性只是针对于条件安全部分而言的。</p>
</blockquote>
</li>
</ul>
<h3 id="竞态条件和线程安全的关系？"><a href="#竞态条件和线程安全的关系？" class="headerlink" title="竞态条件和线程安全的关系？"></a>竞态条件和线程安全的关系？</h3><hr>
<blockquote>
<p>避免竞态条件以获得线程安全。换句话说，避免竞态条件是线程安全的充要条件。</p>
</blockquote>
<h3 id="为什么说跨越内存栅栏（可见性）和避免竞态条件是同步相关的两大主要问题？"><a href="#为什么说跨越内存栅栏（可见性）和避免竞态条件是同步相关的两大主要问题？" class="headerlink" title="为什么说跨越内存栅栏（可见性）和避免竞态条件是同步相关的两大主要问题？"></a>为什么说跨越内存栅栏（可见性）和避免竞态条件是同步相关的两大主要问题？</h3><hr>
<blockquote>
<p>跨越内存栅栏（可见性）是应对竞态条件的一种方式，出现竞态条件必须确保可见性。举个例子：一个写线程写完之后，要保证所做更改对其它线程可见，否则会让其它线程读到脏数据。<br>避免竞态条件的方式有很多种，包括上述的线程安全的各种手段。</p>
</blockquote>
<h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><hr>
<blockquote>
<ol>
<li>livelock（活锁）：请求一个锁的时候不断失败。</li>
<li>starvation（饿死）：无法定期访问共享资源来执行，发生在某个线程长期霸占共享资源的时候。</li>
</ol>
<ul>
<li>Starvation<br>Starvation describes a situation where a thread is unable to gain regular access to shared resources and is unable to make progress. This happens when shared resources are made unavailable for long periods by “greedy” threads. For example, suppose an object provides a synchronized method that often takes a long time to return. If one thread invokes this method frequently, other threads that also need frequent synchronized access to the same object will often be blocked.</li>
</ul>
</blockquote>
<ul>
<li>Livelock<br>A thread often acts in response to the action of another thread. If the other thread’s action is also a response to the action of another thread, then livelock may result. As with deadlock, livelocked threads are unable to make further progress. However, the threads are not blocked — they are simply too busy responding to each other to resume work. This is comparable to two people attempting to pass each other in a corridor: Alphonse moves to his left to let Gaston pass, while Gaston moves to his right to let Alphonse pass. Seeing that they are still blocking each other, Alphone moves to his right, while Gaston moves to his left. They’re still blocking each other, so…</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Monad</title>
    <url>/2015/08/04/Monad/</url>
    <content><![CDATA[<blockquote>
<p>Monad不就是个自函子范畴上的幺半群，这有什么难理解的(A monad is just a monoid in the category of endofunctors)<br>—— Phillip Wadler</p>
</blockquote>
<h2 id="自函子-Endofunctor"><a href="#自函子-Endofunctor" class="headerlink" title="自函子(Endofunctor)"></a>自函子(Endofunctor)</h2><p>什么是函数（Function）？<br>函数表达的映射关系在类型上体现在特定类型（proper type）之间的映射。</p>
<p>什么是自函数（Endofunction）？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">identity :: Number -&gt; Number</span><br></pre></td></tr></table></figure>
<p>自函数就是把<strong>类型映射到自身类型</strong>。函数identity是一个自函数的特例，它接收什么参数就返回什么参数，所以入参和返回值不仅类型一致，而且值也相同。</p>
<p>接下来，回答什么是自函子（Endofunctor）之前，我们先弄清什么是函子（Functor）？</p>
<p>函子有别于函数，函数描述的是特定类型（proper type）之间的映射，而函子描述的是<strong>范畴（category）</strong>之间的映射。</p>
<p>那什么是范畴（category）？</p>
<p>我们把范畴看做一组类型及其关系态射（morphism）的集合。包括特定类型及其态射，比如<code>Int、String、Int -&gt; String</code>；高阶类型及其态射，比如<code>List[Int]、List[String]、List[Int] -&gt; List[String]</code>。</p>
<p>接下来看看函子是如何映射两个范畴的，见下图：<br><img src="http://upload-images.jianshu.io/upload_images/217988-81dc30327d901c40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="范畴"></p>
<p>图中范畴C1和范畴C2之间有映射关系，C1中Int映射到C2中的List[Int]，C1中String映射到C2中的List[String]。除此之外，C1中的关系态射<code>Int -&gt; String</code>也映射到C2中的关系<code>List[Int] -&gt; List[String]</code>态射上。</p>
<blockquote>
<p>换句话说，如果一个范畴内部的所有元素可以映射为另一个范畴的元素，且元素间的关系也可以映射为另一个范畴元素间关系，则认为这两个范畴之间存在映射。所谓函子就是表示两个范畴的映射。</p>
</blockquote>
<p>澄清了函子的含义，那么如何在程序中表达它？</p>
<p>在Haskell中，函子是在其上可以<em>map over</em>的东西。稍微有一点函数式编程经验，一定会想到数组（Array)或者列表（List），确实如此。不过，在我们的例子中，List并不是一个具体的类型，而是一个类型构造子。举个例子，构造List[Int]，也就是把Int提升到List[Int]，记作<code>Int -&gt; List[Int]</code>。这表达了<em>一个范畴的元素可以映射为另一个范畴的元素。</em></p>
<p>List具有map方法，不妨看看map的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f :: A -&gt; B</span><br><span class="line">map :: f -&gt; List[A] -&gt; List[B]</span><br></pre></td></tr></table></figure>
<p>具体到我们的例子当中，就有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f :: Int -&gt; String</span><br><span class="line">map :: f -&gt; List[Int] -&gt; List[String]</span><br></pre></td></tr></table></figure>
<p>展开来看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map :: Int -&gt; String -&gt; List[Int] -&gt; List[String]</span><br></pre></td></tr></table></figure>
<p>map的定义清晰地告诉我们：<code>Int -&gt; String</code>这种关系可以映射为<code>List[Int] -&gt; List[String]</code>这种关系。这就表达了<em>元素间的关系也可以映射为另一个范畴元素间关系。</em></p>
<p>所以类型构造器List[T]就是一个函子。</p>
<p>理解了函子的概念，接着继续探究什么是自函子。我们已经知道<em>自函数就是把类型映射到自身类型</em>，那么自函子就是把范畴映射到自身范畴。</p>
<p>自函子是如何映射范畴的，见下图：<br><img src="http://upload-images.jianshu.io/upload_images/217988-7d3053ee4f51a15e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Identity自函子范畴"></p>
<p>图中表示的是一个将范畴映射到自身的自函子，而且还是一个特殊的Identity自函子。为什么这么说？从函子的定义出发，我们考察这个自函子，始终有<code>List[Int] -&gt; List[Int]</code>以及<code>List[Int] -&gt; List[String] -&gt; List[Int] -&gt; List[String]</code>这两种映射。<br>我们表述成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类型List[Int]映射到自己</span><br><span class="line">态射f :: List[Int] -&gt; List[String]映射到自己</span><br></pre></td></tr></table></figure>
<p>我们记作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(List[Int]) = List[Int]</span><br><span class="line">F(f) = f</span><br><span class="line">其中，F是Functor.</span><br></pre></td></tr></table></figure>

<p>除了Identity的自函子，还有其它的自函子，见下图：<br><img src="http://upload-images.jianshu.io/upload_images/217988-5143675acb7bab44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自函子范畴"></p>
<p>图中的省略号代表这些范畴可以无限地延伸下去。我们在这个大范畴所做的所有映射操作都是同一范畴内的映射，自然这样的范畴就是一个自函子的范畴。</p>
<p>我们记作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List[Int] -&gt; List[List[Int]]</span><br><span class="line">List[Int] -&gt; List[String] -&gt; List[List[Int]] -&gt; List[List[String]]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>所以<code>List[Int]、List[List[Int]]、...、List[List[List[...]]]</code>及其之间的态射是一个自函子的范畴。</p>
<hr>
<h2 id="幺半群"><a href="#幺半群" class="headerlink" title="幺半群"></a>幺半群</h2><blockquote>
<p>[幺半群][1]是一个带有二元运算 <em>: M × M → M 的集合 M ，其符合下列公理：<br>结合律：对任何在 M 内的a、b、c， (a</em>b)<em>c &#x3D; a</em>(b<em>c) 。<br>单位元：存在一在 M 内的元素e，使得任一于 M 内的 a 都会符合 a</em>e &#x3D; e*a &#x3D; a 。</p>
</blockquote>
<p>接着我们看看在自函子的范畴上，怎么结合幺半群的定义得出Monad的。</p>
<p>假设我们有个cube函数，它的功能就是计算每个数的3次方，函数签名如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cube :: <span class="title class_">Number</span> -&gt; <span class="title class_">Number</span></span><br></pre></td></tr></table></figure>
<p>现在我们想在其返回值上添加一些调试信息，所以返回一个元组（Tuple），第二个元素代表调试信息。函数签名如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f :: Number -&gt; (Number,String)</span><br></pre></td></tr></table></figure>
<p>结合前面所讲，我们很容易知道元组构造子(Number,String)是一个自函子。Number所在的范畴并不同于元组(Number,String)所在的范畴。换句话说，f的入参和返回值属于两个范畴。那么这会产生什么影响？我们看看幺半群的定义中规定的结合律。对于函数而言，结合律就是将函数以各种结合方式嵌套起来调用。我们将常用的compose函数看作此处的二元运算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> compose = <span class="keyword">function</span>(<span class="params">f, g</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>(<span class="title function_">g</span>(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">compose</span>(f, f)</span><br></pre></td></tr></table></figure>
<p>从函数签名可以很容易看出，右边的f运算的结果是元组，而左侧的f却是接收一个Number类型的函数，它们是彼此不兼容的。</p>
<p>有什么好办法能消除这种不兼容性？假如输入和输出都是元组，结果会如何呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">F :: (<span class="title class_">Number</span>,<span class="title class_">String</span>) -&gt; (<span class="title class_">Number</span>,<span class="title class_">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">compose</span>(F, F)                 </span><br></pre></td></tr></table></figure>
<p>这样是可行的！在验证满足结合律之前，我们引入一个bind函数来辅助将f提升成F.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f :: <span class="title class_">Number</span> -&gt; <span class="function">(<span class="params"><span class="built_in">Number</span>,<span class="built_in">String</span></span>) =&gt;</span> F :: (<span class="title class_">Number</span>,<span class="title class_">String</span>) -&gt; (<span class="title class_">Number</span>,<span class="title class_">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bind = <span class="keyword">function</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params">tuple</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x  = tuple[<span class="number">0</span>],</span><br><span class="line">        s  = tuple[<span class="number">1</span>],</span><br><span class="line">        fx = <span class="title function_">f</span>(x),</span><br><span class="line">        y  = fx[<span class="number">0</span>],</span><br><span class="line">        t  = fx[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [y, s + t];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们来实现元组自函子范畴上的结合律：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cube = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x * x * x, <span class="string">&#x27;cube was called.&#x27;</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sine = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="title class_">Math</span>.<span class="title function_">sin</span>(x), <span class="string">&#x27;sine was called.&#x27;</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">compose</span>(<span class="title function_">compose</span>(<span class="title function_">bind</span>(sine), <span class="title function_">bind</span>(cube)), <span class="title function_">bind</span>(cube));</span><br><span class="line"><span class="title function_">f</span>([<span class="number">3</span>, <span class="string">&#x27;&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="title function_">compose</span>(<span class="title function_">bind</span>(sine), <span class="title function_">compose</span>(<span class="title function_">bind</span>(cube), <span class="title function_">bind</span>(cube)));</span><br><span class="line"><span class="title function_">f1</span>([<span class="number">3</span>,<span class="string">&#x27;&#x27;</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">0.956</span>, <span class="string">&#x27;cube was called.cube was called.sine was called.&#x27;</span>]</span><br><span class="line">[<span class="number">0.956</span>, <span class="string">&#x27;cube was called.cube was called.sine was called.&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>这里<code>f和f1</code>代表的调用顺序产生同样的结果，说明元组自函子范畴满足结合律。</p>
<p>那如何找到这样一个<code>e</code>，使得<code>a*e=e*a=a</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unit :: Number -&gt; (Number,String)</span></span><br><span class="line"><span class="keyword">var</span> unit = <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> [x, <span class="string">&#x27;&#x27;</span>] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">compose</span>(<span class="title function_">bind</span>(sine), <span class="title function_">bind</span>(cube));</span><br><span class="line"></span><br><span class="line"><span class="title function_">compose</span>(f, <span class="title function_">bind</span>(unit)) = <span class="title function_">compose</span>(<span class="title function_">bind</span>(unit), f) = f</span><br></pre></td></tr></table></figure>
<p>这里的<code>bind(unit)</code>就是<code>e</code>了。</p>
<p><em>Monads for functional programming</em>一书中介绍说<em>monad</em>是一个三元组<code>(M, unit, *)</code>，对应此处就是<code>(Tuple, unit, bind)</code>.</p>
<p>参考链接：</p>
<ol>
<li><a href="https://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/">Translation from Haskell to JavaScript of selected portions of the best introduction to monads I’ve ever read</a></li>
<li><a href="http://hongjiang.info/understand-monad-5-what-is-endofunctor/">我所理解的monad</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Monads for functional programming</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>language</tag>
        <tag>FP</tag>
      </tags>
  </entry>
  <entry>
    <title>Why we are learning Clojure</title>
    <url>/2015/11/26/Why-are-we-learning-Clojure/</url>
    <content><![CDATA[<p>在Gaslight，我们广泛地在工作中使用Ruby和Rails，也充分地经历了从JQuery到Ember再到AngularJS及其他所有关于JavaScript的一切。不过有时候我们为了学习和成长，需要脱离舒适区。我们如何赶上未来的趋势和机会呢？</p>
<p>那就是绝不停止学习。在过去的几个星期里，我们的开发团队决定作为一个小组去掌握Clojure语言。我们尝试构建了关于这门技术的主要知识点，所以当我们在一个客户项目中采用Clojure的时候，对自己技术的深度和熟悉程度很有自信。</p>
<p>为什么我们会选择Clojure呢？</p>
<h2 id="填补了Ruby和Rail没有顾及的空白"><a href="#填补了Ruby和Rail没有顾及的空白" class="headerlink" title="填补了Ruby和Rail没有顾及的空白"></a>填补了Ruby和Rail没有顾及的空白</h2><blockquote>
<p>我知道我们不可能永远用Ruby编程。另一个语言和环境一定会到来并取代它。我只是希望它真的比我们现在所拥用的更好。 —— Doug Alcorn</p>
</blockquote>
<p>我们依然热爱Ruby，依然认为Rails通常是构建web应用的最佳方案。但是，它和其他工具一样，有长处，也有短处。</p>
<ol>
<li>Ruby的并发并不健壮。是的，你可以使用JRuby和Celluloid，但是可变性在根本上妨碍它走向并发。同时，很多你想要使用的库都不是线程安全的。</li>
<li>Ruby和Rails几乎总是足够快的。几乎总是，但不尽然。</li>
<li>对象关系映射（ORM）不总是正确的。</li>
<li>面向对象的语言也不总是最佳的解决方案。</li>
</ol>
<h2 id="函数式编程是一种不同的思考方式"><a href="#函数式编程是一种不同的思考方式" class="headerlink" title="函数式编程是一种不同的思考方式"></a>函数式编程是一种不同的思考方式</h2><blockquote>
<p>函数式编程是一种编程范式，一种构建计算机程序的结构和元素，它把计算看做数学函数的求值，同时禁止改变状态和可变的数据。——Wikipedia</p>
</blockquote>
<p>函数式编程语言是一种有别于我们平常在Ruby和JavaScript中编程的编程范式。学习这一范式使得我们能学习崭新且不同的技术来解决问题。这些技术可能不太容易去学习，如果我们沉浸在自己舒适的命令式和面向对象的语言范式当中。</p>
<h2 id="Clojure运行在服务器端"><a href="#Clojure运行在服务器端" class="headerlink" title="Clojure运行在服务器端"></a>Clojure运行在服务器端</h2><blockquote>
<p>Clojure实现它的目标，通过：拥抱一个行业标准的开放平台——Java虚拟机；现代化一门古老的语言——Lisp；树立带有不可变持久化数据结构的函数式编程；同时通过软件事务内存以及异步代理提供内建的并发支持。这一结果是健壮的，顺手的和快速的。—— Clojure.org</p>
</blockquote>
<p>Clojure运行在Java虚拟机（JVM）上并且利用了其提供的优势：高质量的垃圾回收，高性能的本地线程以及可扩展的移植。Clojure又在其上增加了高效的不可变持久化数据结构。Clojure带来了有趣的并发模型Core.Async。另外，这里还有很多其他有趣的库供开发，逻辑编程，模式匹配，optional typing和好多我们想要尝试并理解的东西。</p>
<h2 id="Clojure运行在浏览器端"><a href="#Clojure运行在浏览器端" class="headerlink" title="Clojure运行在浏览器端"></a>Clojure运行在浏览器端</h2><blockquote>
<p>一个具有扩展，移植和多供应商支持的开发平台，一场在各个新设备上实现精巧工具的优化军备竞赛以及一个对更丰富且更精巧应用的呐喊。开发者们还有什么想要的呢？一个不同的语言，这就是了。—— ClojureScript Wiki</p>
</blockquote>
<p>ClojureScript编译成JavaScript运行于浏览器。它提供了一种全新的方式去思考编写客户端应用程序。JavaScript并不是开发者社区里广泛青睐的语言。但是Clojure是设计良好，精密且具有很好异步支持的成熟的Lisp。它也可以和其他的JavaScript类库交互。所有这些都为我们提供了一个在客户端和服务端使用相同的语言却不需要做任何妥协的机会。</p>
<p>管理本来就具有状态的客户端应用是件尴尬的事，不过像React和Ember这些JavaScript框架正在着手解决这个问题，我们开始猜想如果一种更加基本的改变方式值得深入研究，那么是否可能有一种更好的语言和这其中的任一已经存在的框架配合来为我们提供一种途径使得可以更好地控制复杂性呢？Clojure允许我们朝着这个问题寻找答案。</p>
<p>我们不相信银弹，但是我们真的喜欢这样的事实，Clojure包含了客户端的需求。</p>
<h2 id="朝冰球要去的地方滑"><a href="#朝冰球要去的地方滑" class="headerlink" title="朝冰球要去的地方滑"></a>朝冰球要去的地方滑</h2><blockquote>
<p>我追逐冰球要去的地方，而不是它所在的地方。—— Wayne Gretzky</p>
</blockquote>
<p>Clojure会帮助我们填补创建特定类型的应用程序的沟壑。那些需要响应或者处理大规模数据的程序。我们已经身处多核CPU的纪元，但是传统的语言还未追赶上这些计算机的架构。函数式编程提供了一种新的编程范式允许我们更简单地使用这种架构写程序。Clojure提供允许我们高效地处理大规模数据的工具。它使得传递和转换数据接近实时。这些特性会使我们比从前更高效地解决问题。</p>
<h2 id="不过不是Bleeding-Edge"><a href="#不过不是Bleeding-Edge" class="headerlink" title="不过不是Bleeding Edge"></a>不过不是Bleeding Edge</h2><blockquote>
<p>“什么会被认为是bleeding-edge的技术，”sez Lucas。 “没被证实的用法，高风险，只有早期采用成瘾者才感到舒服的东西”—— Thomas Pynchon, Bleeding Edge</p>
</blockquote>
<p>此时，Clojure被发布超过5年之久并且似乎在开发者社区里获得了不错的想法分享。在新锐技术上掉坑的采纳曲线上这不算太早了。Clojure利用了已存在的技术如已经被开发超过15以上年头的java虚拟机（JVM）。它也可以利用很多已经存在的高质量的Java类库。</p>
<h2 id="一些新东西让我们保持兴奋"><a href="#一些新东西让我们保持兴奋" class="headerlink" title="一些新东西让我们保持兴奋"></a>一些新东西让我们保持兴奋</h2><blockquote>
<p>自从学Ruby以来，还没有学习一门新技术让我如此激动！ —— Michael Guterl</p>
</blockquote>
<p>在Gaslight，我们想在行业中吸引和保留最好的技术。为了做到这一点，我们需要给大家提供学习和提高其技能的机会。Clojure帮助我们提供了这样的机会。它是一个带有一系列工具的崭新范式。不过最重要的是，它允许我们处理新的且有趣的问题。还没有什么能比解决有意思的问题更让我们高兴的呢。</p>
]]></content>
      <categories>
        <category>Clojure</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>真正的热情</title>
    <url>/2016/01/01/the-real-enthusiasm/</url>
    <content><![CDATA[<blockquote>
<p>究竟要怎么做，才能热衷于某件事呢？才能打心底认定非此不可，并在这条路上勇往直前呢？ —— 三浦紫苑《编舟记》</p>
</blockquote>
<p>西冈想不明白，我也是。但有些人没去想便做了，小说主角马缔就是其中一个。</p>
<p>做过报刊的编辑工作，我深知其对词汇认知敏锐度和付梓校对细致程度的要求之高，何况是小说中编纂“浩瀚的词汇海洋”般的辞典。假如书中描述是主角依着敏锐的词汇嗅觉和认真的态度不屈不挠地编纂出一部《大渡海》，这顶多被我归入成功学之列。所幸不是，推荐语“究竟要燃烧什么，才能激发出真正的热情？”是驱使我购书的诱因，也是心中一直郁结的谜团，在这种状态下，这本书激发了我思考的动机。</p>
<p>为什么能如此全身心地投入一件事？</p>
<p>这个问题放到马缔身上，可以归结成两点原因：适材适所和背负责任。除了对词汇有着敏锐认知度之外，马缔算是一无是处，如果没有被辞典编辑部发掘，估计只能碌碌无为，虚度一生。在辞典编辑部，他个人的才华连同缺点一起大放异彩，很快跻身成为中流砥柱。若说才华得以施展是他内在的驱动力，那么前辈对其的全权托付则是这外在的鞭策。一个人将毕生的事业全权托付给另一个人，这里头的分量非同小可，马缔背负这样的责任是一种幸运。这两点在我看来就是他热情的源头。</p>
<p>小说是一种艺术，艺术源于生活而高于生活。生活是复杂的，人也是。而我习惯囿于一种怀揣真理以正向视角去解读任何人的方式，自认为应该如此。倘若热情果真如此言简意赅，为何我心中的郁结未减半分。又或者真应了那句台词：我们听过无数的道理，却仍旧过不好这一生？</p>
<p>暂时抛开人生哲理不谈，本书倒是有一个实用的指导意义——辞典中每个词都是被编辑认真释义，力求正确全面的。如此不妨模仿书中的行文方式，查查辞典中对热情这个词的描述。</p>
<blockquote>
<p>【热情】指人参与活动或对待别人所表现出来的热烈，积极，主动，友好的情感或态度。热情的反义词是冷漠。如：冷漠的人干活无精打彩，热情的人工作起来象个小老虎。冷漠的人待人爱理不理，热情的人主动关心，主动帮忙，如火温暖。热情是与人生观，价值观有关联的，是一个人态度、兴趣的表现。与激情相比，热情更平稳稳定一些。激情是一种强烈的情感表现形式。往往发生在强烈刺激或突如其来的变化之后。具有迅猛、激烈、难以抑制等特点。人在激情的支配下，常能调动身心的巨大潜力。</p>
</blockquote>
<p>马缔编辞典的热情，固然是他性格所致、兴趣所在。但是如何解释逾十五年，几乎独力完成编纂整部辞典这一事实呢？一件事失去了新鲜感，兴趣总归是减损的，这是客观事实。工作如此，尤其是以高薪技术标榜，极客达人自居的程序员一族，视快速学习新技术为本职，这也决定我辈好奇骛新的特点，追技术也似赶潮流，热情不过三分，把玩一番就浅尝辄止，如此反复，连猎奇的心情也冷却了，凡事都提不起劲儿，以懒自居，浑浑噩噩，陷入迷惘。可见兴趣并非热情之源，一定有别种更深刻的东西在持续地，稳定地释放着热情，如源头活水才是。</p>
<p>我崇拜的一位我司的前辈说过：“迷惘是因为你离目标太近”。看到这句话正是我入职满一年的时候。头一年里，从职场新人转变成老人，逐渐进入舒适区。等回过神，忽然发现每天过着朝九晚六的生活，年纪轻轻，人生就这么决定了，心有不甘，又无可奈何。究其原因，大概是大学之后，再无目标。犹记得当年毕业找到工作后，写就的一篇关于《信仰》的文章，文中探讨了信仰对于一个人面临人生选择时的重要作用，同时佐引了德国大哲学家康德说过一句话：“我们信仰，是因为我们需要信仰”。那时想法单纯，对这句话也只是断章取义，不乏嘲讽。现在看来，信仰的本身就是生活的需要，如同光和水一样必不可少。很多时候，我们所认为荒谬的道理其实并不一定如此荒谬，我们过得生活会在某处经历中告诉我们：事实如此。</p>
<p>可是究竟要信仰什么？</p>
<p>在世纪的转折点上，尼采大呼“上帝死了”，人们发现自己生活在一个毫不仁慈、无法救赎的世界中。这时，叔本华用一种消极的口吻告诉人们：生命本无意义，生命本质上是悲剧性质的，人生而痛苦，个人应当自觉否定生命意志快步走向灭寂。但是尼采爱人类，他肯定了生命的悲剧性质，却不屈服否定生命意志的消极面，毕竟哲学原初的目的就是让人幸福。所以他提出“面对痛苦、险境和未知的事物，精神愈加欢欣鼓舞”的酒神精神以及不断自我超越、支配的求强力的意志。所谓求强力的意志就是生命要不断奋力向上，从高于自己的东西那里寻找自身的意义和目的；其本身就是强力，其本质上就是求强力的过程。我认可这样的生命意志，我愿意用自己蓬勃兴旺的生命力去战胜苦难，像英雄一样在残酷的悲剧中自我肯定，坚强到足以把苦难当作快乐来感受，我要把它奉为我的信仰！</p>
<p>回头再细细评味“我们信仰，是因为我们需要信仰”这句话，我确实埋头驻足不知所措了好长一段时间，现在抬头了，瞭望久远的未来，选择了自己的信仰——我迫切地需要一条明路。至于马缔的信仰是什么我不得而知，不过我敢肯定他至少拥有健康的生命本能和严肃的精神追求，人物本身虽然属于小说虚构，但是他活得太真实了，生命和精神必须是兼具的，不然一个人活得不会真切。此间热情的源头想必存在生命意志当中吧，于马缔而言，是生命本能和某种精神追求的合力；于我而言，是信仰。</p>
<p>我很早就意识到人生中的三大幸事：有事做，有人爱，有所期待。</p>
<p>马缔十五年如一日地编辑辞典，这是有事可做；马缔背负着前辈的托付——尽早付梓出版《大渡海》这部辞典，渴望前辈和消费者的认可，这算是有所期待；那么马缔有人爱吗？必须有，而且小说中安排了一位“辉夜公主”给他。可是视编辑辞典为生命，生活又乱糟糟的无趣之人凭什么得到人家姑娘的爱？这种不合理的展开难道是作者个人的意淫么？如是想着，模仿马缔的笨拙，自然以笨拙收场，我自嘲。我探讨不来这种话题，却由衷欣赏他们两人之间的默契，都有自己热衷的事业并沉浸其中追求极致，所以才能互相理解，互相慰藉。这是两个独立人格之间自由的结合，谁也不会为谁放弃自我，这种体现自由又能体现人格的关系不是爱情还能是什么？这三个条件满足了，在我看来，马缔就是幸福的，此生不会再迷惘和孤独。</p>
<p>“人的内心，有时候对自己都是一个谜”。我想活得明白点，仅此而已。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-8f37e08b02fdb2c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="尼采 在世纪的转折点上"><br><img src="http://upload-images.jianshu.io/upload_images/217988-d57d72f9644a099a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编舟记"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js on Windows</title>
    <url>/2016/03/22/Node-js-On-Windows/</url>
    <content><![CDATA[<h2 id="搭建-Node-js-开发环境"><a href="#搭建-Node-js-开发环境" class="headerlink" title="搭建 Node.js 开发环境"></a>搭建 Node.js 开发环境</h2><h3 id="NVM安装"><a href="#NVM安装" class="headerlink" title="NVM安装"></a>NVM安装</h3><p>1. <a href="https://github.com/coreybutler/nvm/releases">Download nvm-noinstall.zip</a><br>2. Update the system environment variables:<br><em>NVM_HOME</em>, <em>NVM_SYMLINK</em> (C:\Users\Program Files\nodejs <strong>This directory should not exist in previously.</strong>)<br>3. Create <em>settings.txt</em> file</p>
<blockquote>
<p>root: C:\Users\qinayan\bin\nvm<br>path: C:\Program Files\nodejs<br>arch: 64<br>proxy: none</p>
</blockquote>
<p>详情请参考 <a href="https://github.com/coreybutler/nvm-windows/wiki#manual-installation">如何安装nvm-windows</a><br>另外别忘了在<em>NVM_HOME</em>目录中运行<em>install</em>命令</p>
<h3 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装特定版本的nodejs</span><br><span class="line">&gt; nvm install 0.12.10</span><br><span class="line">安装最新版本的nodejs</span><br><span class="line">&gt; nvm install latest</span><br><span class="line">查看本地安装了哪些nodejs</span><br><span class="line">&gt; nvm ls</span><br><span class="line"> * 5.7.1 (Currently using 64-bit executable)</span><br><span class="line">   0.12.10</span><br><span class="line">验证安装完成   </span><br><span class="line">&gt; node -v</span><br><span class="line">  v5.7.1</span><br><span class="line">&gt; node</span><br><span class="line">...&gt; console.log(&quot;hello world&quot;);</span><br><span class="line">  hello world</span><br></pre></td></tr></table></figure>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>每个文件就是一个模块，文件的路径名就是模块的名字</p>
<h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p>类似于Java中的<code>import</code>关键字，导入不同的包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br></pre></td></tr></table></figure>
<h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><p>导出模块的公有方法和属性。可以理解为Java中的<code>public</code>方法和属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// util.js</span><br><span class="line">exports.greeting = function(name) &#123;</span><br><span class="line">   return &quot;hello, &quot; + name;   </span><br><span class="line">&#125;</span><br><span class="line">// index.js</span><br><span class="line">var greeting = require(&#x27;./util&#x27;).greeting;</span><br><span class="line">console.log(greeting(&quot;lambeta&quot;))</span><br><span class="line">&gt;  hello, lambeta</span><br></pre></td></tr></table></figure>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>包含当前模块的一些信息，常用的做法是替换当前模块的导出对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// util.js</span><br><span class="line">console.log(module)</span><br><span class="line">&gt;&gt;</span><br><span class="line">Module &#123;</span><br><span class="line">  id: &#x27;.&#x27;,</span><br><span class="line">  exports: &#123; greeting: [Function] &#125;,</span><br><span class="line">  parent: null,</span><br><span class="line">  filename: &#x27;C:\\Users\\qianyan\\Projects\\lesson2\\util.js&#x27;,</span><br><span class="line">  loaded: false,</span><br><span class="line">  children: [],</span><br><span class="line">  paths:</span><br><span class="line">   [ &#x27;C:\\Users\\qianyan\\Projects\\lesson2\\node_modules&#x27;,</span><br><span class="line">     &#x27;C:\\Users\\qianyan\\Projects\\node_modules&#x27;,</span><br><span class="line">     &#x27;C:\\Users\\qianyan\\node_modules&#x27;,</span><br><span class="line">     &#x27;C:\\Users\\node_modules&#x27;,</span><br><span class="line">     &#x27;C:\\node_modules&#x27; ] &#125;</span><br><span class="line"></span><br><span class="line">// replace with obj</span><br><span class="line">module.exports = &#123;greeting: &#123;&#125;&#125;;</span><br><span class="line">&gt;&gt;</span><br><span class="line">Module &#123;</span><br><span class="line">  id: &#x27;.&#x27;,</span><br><span class="line">  exports: &#123; greeting: &#123;&#125; &#125;,</span><br><span class="line">  parent: null,</span><br><span class="line">  filename: &#x27;C:\\Users\\qianyan\\Projects\\lesson2\\util.js&#x27;,</span><br><span class="line">  loaded: false,</span><br><span class="line">  children: [],</span><br><span class="line">  paths:</span><br><span class="line">   [ &#x27;C:\\Users\\qianyan\\Projects\\lesson2\\node_modules&#x27;,</span><br><span class="line">     &#x27;C:\\Users\\qianyan\\Projects\\node_modules&#x27;,</span><br><span class="line">     &#x27;C:\\Users\\qianyan\\node_modules&#x27;,</span><br><span class="line">     &#x27;C:\\Users\\node_modules&#x27;,</span><br><span class="line">     &#x27;C:\\node_modules&#x27; ] &#125;</span><br></pre></td></tr></table></figure>
<h3 id="module-initialize发生的时机"><a href="#module-initialize发生的时机" class="headerlink" title="module initialize发生的时机"></a>module initialize发生的时机</h3><p>模块中的代码只会在首次被使用的时候才会执行一次，同时初始化该模块的导出对象，之后导出对象会被缓存到内存当中，供任意使用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>NVM是Node Version Manager，管理node的版本的工具。使用NVM，可以保证同一个操作系统下，多个不同版本的node得以共存。</li>
<li>node作为javascript的解析器，可以在终端下进入交互式模式(repl read-eval-print-loop)，很方便快速地反馈我们程序的结果。</li>
<li>nodeJS的模块系统实现了CMD标准，即<a href="http://wiki.commonjs.org/">CommonJS Module Definition</a>标准；而对于运行在浏览器上的javascript的模块化，因为需要异步加载js文件，所以由require.js实现了AMD (Asynchronous Module Definition)标准</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD</span><br><span class="line">require(&#x27;express&#x27;)</span><br><span class="line"></span><br><span class="line">AMD</span><br><span class="line">define(&quot;alpha&quot;, [&quot;require&quot;, &quot;exports&quot;, &quot;beta&quot;],</span><br><span class="line">function (require, exports, beta) &#123;</span><br><span class="line">       exports.verb = function() &#123;</span><br><span class="line">           return beta.verb();</span><br><span class="line">           //Or:</span><br><span class="line">           return require(&quot;beta&quot;).verb();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>是否可以使用<code>require(&#39;./data.json&#39;</code>)将json文件引入到我们的程序当中呢？</li>
<li>有两个js文件同时引入了<code>data.json</code>，先执行a.js，后执行b.js。下面的程序会输出什么？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//data.json</span><br><span class="line">&#123;&quot;hello&quot;: &quot;world&quot;&#125;</span><br><span class="line"></span><br><span class="line">//a.js</span><br><span class="line">var data = require(&#x27;./data.json&#x27;);</span><br><span class="line">data = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//b.js</span><br><span class="line">var data = require(&#x27;./data.json&#x27;);</span><br><span class="line">console.log(data)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><h3 id="模块解析路径"><a href="#模块解析路径" class="headerlink" title="模块解析路径"></a>模块解析路径</h3><h4 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h4><p>不想直接require文件路径名，因为这样一旦所依赖的文件路径发生变化，牵扯的文件会很多。所以我们需要一个约定的根目录。这个根目录就是<code>node_modules</code><br>以这个文件的路径为例：<code>C:\\Users\\qianyan\\Projects\\lesson2\\util.js</code>，node搜索的路径如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paths:</span><br><span class="line">  [ &#x27;C:\\Users\\qianyan\\Projects\\lesson2\\node_modules&#x27;,</span><br><span class="line">    &#x27;C:\\Users\\qianyan\\Projects\\node_modules&#x27;,</span><br><span class="line">    &#x27;C:\\Users\\qianyan\\node_modules&#x27;,</span><br><span class="line">    &#x27;C:\\Users\\node_modules&#x27;,</span><br><span class="line">    &#x27;C:\\node_modules&#x27; ]</span><br></pre></td></tr></table></figure>
<h4 id="NODE-PATH"><a href="#NODE-PATH" class="headerlink" title="NODE_PATH"></a>NODE_PATH</h4><p>我们知道java中依赖包的搜索路径是通过classpath这个JVM的参数控制的。其实node也有这样的变量提供支持。这个变量就是<code>NODE_PATH</code><br>windows下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd</span><br><span class="line">set NODE_PATH=&quot;your_path&quot;</span><br><span class="line">powershell</span><br><span class="line">env:NODE_PATH=&quot;your_path&quot;</span><br></pre></td></tr></table></figure>
<p>NODE_PATH中的路径被遍历是发生在从项目的根位置递归搜寻 node_modules 目录，直到文件系统根目录的node_modules，如果还没有查找到指定模块的话，就会去 NODE_PATH中注册的路径中查找。</p>
<h4 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h4><p>如<code>fs</code>, <code>http</code>等，不做路径解析就直接使用其导出对象<code>require(&#39;fs&#39;)</code>, <code>require(&#39;http&#39;)</code></p>
<h3 id="Package（包）"><a href="#Package（包）" class="headerlink" title="Package（包）"></a>Package（包）</h3><p>包就是封装多个子模块，同时提供入口的大模块。这个大模块的功能是内聚的。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\USERS\QIANYAN\PROJECTS\LESSON2</span><br><span class="line">└───plane</span><br><span class="line">        body.js</span><br><span class="line">        engine.js</span><br><span class="line">        main.js</span><br><span class="line">        wing.js</span><br></pre></td></tr></table></figure>
<p>其中plane目录定义了一个包，其中包含了4个子模块。<code>main.js</code>作为入口模块，如下：</p>
<figure class="highlight javascript"><figcaption><span>main.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> engine = <span class="built_in">require</span>(<span class="string">&#x27;./engine&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> wing = <span class="built_in">require</span>(<span class="string">&#x27;./wing&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">require</span>(<span class="string">&#x27;./body&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">plane</span> = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;747&quot;</span>,</span><br><span class="line">    <span class="attr">engine</span>: engine,</span><br><span class="line">    <span class="attr">wing</span>: wing,</span><br><span class="line">    <span class="attr">body</span>: body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他模块需要使用plane这个包时，得使用<code>require(&#39;./plane/main&#39;)</code>才行。不过，这里有两种方法可以省去写文件名<code>main</code>。</p>
<h4 id="1-index-js"><a href="#1-index-js" class="headerlink" title="1. index.js"></a>1. index.js</h4><p>这里有个约定，如果将main.js重命名成index.js，那么就不需要写出文件名字，直接<code>require(&#39;./plane&#39;)</code>就可以了。</p>
<p>这样模块显得更内聚，和Clojure中的<code>(use namespace)</code>的用法类似。以下两条语句等价。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./plane/main&#x27;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./plane&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-package-json"><a href="#2-package-json" class="headerlink" title="2. package.json"></a>2. package.json</h4><p>如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个package.json文件，并在其中指定入口模块的路径。上例中的模块可以重构如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\USERS\QIANYAN\PROJECTS\LESSON2\PLANE</span><br><span class="line">│   package.json //包描述文件</span><br><span class="line">│</span><br><span class="line">├───doc //文档</span><br><span class="line">├───lib //API文件</span><br><span class="line">│       body.js</span><br><span class="line">│       engine.js</span><br><span class="line">│       main.js</span><br><span class="line">│       wing.js</span><br><span class="line">│</span><br><span class="line">└───tests //测试文件</span><br></pre></td></tr></table></figure>
<p>其中package.json内容如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;plane&quot;</span>,</span><br><span class="line">    <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./lib/main.js&quot;</span> <span class="comment">//这里入口文件的名字可以按自己的喜好更改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此一来，就同样可以使用require(‘.&#x2F;lib&#x2F;plane’)的方式加载模块。NodeJS会根据包目录下的package.json找到入口模块所在位置。</p>
<hr>
<h3 id="命令行程序"><a href="#命令行程序" class="headerlink" title="命令行程序"></a>命令行程序</h3><p>node.js的程序是跑在命令行之中的，命令行程序长得类似<code>cmd --name=value</code>这样的形式。</p>
<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>在windows下创建一个<code>greeting</code>程序的目录，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\USERS\QIANYAN\PROJECTS\LESSON2\GREETING</span><br><span class="line">│   package.json</span><br><span class="line">│   README.md</span><br><span class="line">│</span><br><span class="line">├───bin</span><br><span class="line">│       greeting.cmd</span><br><span class="line">│</span><br><span class="line">├───doc</span><br><span class="line">├───lib</span><br><span class="line">│       index.js</span><br><span class="line">│</span><br><span class="line">├───node_modules</span><br><span class="line">└───tests</span><br></pre></td></tr></table></figure>
<p>package.json的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;greeting&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;say hi to everyone&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;lib/index.js&quot;,</span><br><span class="line">  &quot;directories&quot;: &#123;</span><br><span class="line">    &quot;doc&quot;: &quot;doc&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;tests&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;bin&quot;: &#123;</span><br><span class="line">    &quot;greeting&quot;: &quot;bin/greeting.cmd&quot;  </span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;node test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;lambeta&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在windows下，如果我们想要实现<em>cmd –name&#x3D;value</em>的效果，就必须使用cmd后缀的文件，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//greeting.cmd</span><br><span class="line">@node &quot;lib/index.js&quot; %*</span><br></pre></td></tr></table></figure>
<p>我们实现一个接受人的名字作为参数的命令行程序<em>lib&#x2F;index.js</em>，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello,&#x27;</span>, process.<span class="property">argv</span>[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>到这里，可以直接这样运行<code>./bin/greeting.cmd lambeta</code>，输出<code>hello, lambeta</code>。不过，还是没有预期的样子。</p>
<h4 id="npm-link"><a href="#npm-link" class="headerlink" title="npm link"></a>npm link</h4><p>我们再运行一条npm的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; npm link</span><br><span class="line">C:\Program Files\nodejs\greeting -&gt; C:\Program Files\nodejs\node_modules\greeting\bin\greeting.cmd</span><br><span class="line">C:\Program Files\nodejs\node_modules\greeting -&gt; C:\Users\qianyan\Projects\lesson2\greeting</span><br></pre></td></tr></table></figure>
<p>这条命令帮助我们设置两个软链接。第一个链接使得我们可以直接运行<em>greeting lambeta</em>；第二个则在全局范围内，其他的模块得以引入greeting这个包。<br>此时，我们可以直接使用<em>greeting lambeta</em>来运行程序了</p>
<h4 id="依赖第三方库"><a href="#依赖第三方库" class="headerlink" title="依赖第三方库"></a>依赖第三方库</h4><p>为了实现真正的<em>cmd –name&#x3D;value</em>，我们使用一个第三方库<code>yargs</code>。</p>
<ol>
<li>安装yargs: <em>npm install yargs –save</em></li>
<li>修改index.js文件如下<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">&#x27;yargs&#x27;</span>).<span class="property">argv</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello,&#x27;</span>, argv.<span class="property">name</span>);</span><br></pre></td></tr></table></figure></li>
<li>运行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; greeting --name=lambeta</span><br><span class="line">  hello, lambeta</span><br></pre></td></tr></table></figure></li>
</ol>
<p>最后再来看看一个完整的node.js的整体结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\USERS\QIANYAN\PROJECTS\LESSON2\GREETING</span><br><span class="line">│   package.json //包描述文件</span><br><span class="line">│   README.md    //说明文件</span><br><span class="line">│</span><br><span class="line">├───bin</span><br><span class="line">│       greeting.cmd //命令行相关代码</span><br><span class="line">│</span><br><span class="line">├───doc   //文档</span><br><span class="line">├───lib   //API代码</span><br><span class="line">│       index.js</span><br><span class="line">│</span><br><span class="line">├───node_modules //第三方依赖</span><br><span class="line">└───tests //测试</span><br></pre></td></tr></table></figure>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>按照标准目录结构</li>
<li>分模块管理项目</li>
<li>使用NPM管理第三方模块和命令行程序</li>
<li>使用package.json描述项目信息和依赖</li>
</ul>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><ul>
<li>下载一个第三方命令行程序到本地<code>npm install es-checker</code>，不要使用<code>-g</code>参数，如何运行起来这个程序？</li>
<li>了解一下<a href="https://docs.npmjs.com/misc/scripts">npm scripts</a>，在上题的基础上，添加包含下面的内容的package.json，运行<code>npm test</code>。思考这样做是否可行？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//package.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;test&quot;: &quot;es-checker&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>前置条件：<a href="https://zealdocs.org/">安装Windows上的离线文档工具</a></p>
<h3 id="文件操作相关的API"><a href="#文件操作相关的API" class="headerlink" title="文件操作相关的API"></a>文件操作相关的API</h3><h4 id="buffer对象（数据块）"><a href="#buffer对象（数据块）" class="headerlink" title="buffer对象（数据块）"></a>buffer对象（数据块）</h4><p>Javascript语言本身只支持字符串操作，没有提供针对二进制数据流的操作。NodeJS提供了一个与<code>String</code>对等的全局对象<code>Buffer</code>. Buffer和整数的数组很类似，但是它是固定长度，一旦创建就不能修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var bin = new Buffer(&#x27;hello&#x27;, &#x27;utf8&#x27;);// &lt;Buffer 68 65 6c 6c 6f&gt;</span><br><span class="line">bin.toString(); //&#x27;hello&#x27;</span><br><span class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</span><br><span class="line">bin.toString(); //&#x27;hello&#x27;</span><br><span class="line"></span><br><span class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</span><br><span class="line">var dump = new Buffer(bin.length);</span><br><span class="line">bin.copy(dump);</span><br></pre></td></tr></table></figure>
<h4 id="stream模块（数据流）"><a href="#stream模块（数据流）" class="headerlink" title="stream模块（数据流）"></a>stream模块（数据流）</h4><p>Stream是一个抽象的接口，所有的stream都是EventEmitter的实例。<br>当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种Stream来提供对数据流的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;);</span><br><span class="line">var readStream = fs.createReadStream(&#x27;README.md&#x27;); //readStream是EventEmitter的实例。</span><br><span class="line"></span><br><span class="line">readStream.on(&#x27;data&#x27;, function(chunk) &#123;</span><br><span class="line">   console.log(chunk.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readStream.on(&#x27;end&#x27;, function() &#123;</span><br><span class="line">   console.log(&#x27;end.&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h4><p>NodeJS通过<code>fs</code>内置模块提供对文件的操作。<code>fs</code>模块提供的API基本可以分为以下三类：</p>
<ul>
<li><p>文件属性读写。<br>其中常用的有fs.stat、fs.chmod、fs.chown等等。</p>
</li>
<li><p>文件内容读写。<br>其中常用的有fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等。</p>
</li>
<li><p>底层文件操作。<br>其中常用的有fs.open、fs.read、fs.write、fs.close等等。</p>
</li>
</ul>
<p>我们可以通过<code>require(&#39;fs&#39;)</code>来引用这个模块，而且该模块下的每个方法都有同步和异步的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// read sync</span><br><span class="line">var file = fs.readFileSync(process.cwd() + &#x27;/README.md&#x27;, &#x27;utf8&#x27;);</span><br><span class="line">console.log(file);</span><br><span class="line"></span><br><span class="line">// read async</span><br><span class="line">fs.readFile(process.cwd() + &#x27;/README.md&#x27;, &#x27;utf8&#x27;, function (err, data) &#123;</span><br><span class="line">    if(err) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一段遍历当前目录的程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;);</span><br><span class="line">var p = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">function recursiveRead(path) &#123;</span><br><span class="line">    if(fs.statSync(path).isFile()) &#123;</span><br><span class="line">        console.log(&quot;File:&quot;, path);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fs.readdir(path, function(err, files) &#123;</span><br><span class="line">            if(err) &#123;</span><br><span class="line">                console.log(err);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            files.forEach(function(file) &#123;</span><br><span class="line">                var absPath = p.join(path, file);</span><br><span class="line">                if(fs.statSync(absPath).isFile()) &#123;</span><br><span class="line">                    console.log(&quot;File:&quot;, absPath);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    console.log(&quot;Directory:&quot;, absPath);</span><br><span class="line">                    recursiveRead(absPath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">recursiveRead(__dirname); //全局的对象__dirname，当前脚本执行的目录。</span><br></pre></td></tr></table></figure>

<h4 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h4><p>和<code>java</code>类似，NodeJS提供path来简化对文件路径的操作。</p>
<ul>
<li>path.normalize<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var path = require(&#x27;path&#x27;);</span><br><span class="line">path.normalize(&#x27;foo/bar/..&#x27;); // &#x27;foo&#x27;</span><br></pre></td></tr></table></figure></li>
<li>path.join &amp; path.sep<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path.join(&#x27;foo&#x27;, &#x27;/bar/&#x27;, &#x27;/baz&#x27;, &#x27;par/&#x27;) // &#x27;foo\\bar\\baz\\par\\&#x27;</span><br><span class="line">path.sep // &#x27;\\&#x27;</span><br></pre></td></tr></table></figure></li>
<li>path.extname<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path.extname(&#x27;node.js&#x27;) //&#x27;.js&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>Buffer</code>提供了NodeJS操作二进制的机制；</li>
<li><code>Stream</code>是一个抽象的接口，每种stream都是EventEmitter的实例。当我们在读取大文件时，可以使用数据流一边读取，一边处理；</li>
<li><code>fs</code>提供了文件属性读写，内容读写以及底层文件操作。</li>
<li>不要使用字符串拼接，使用<code>path</code>简化操作</li>
</ul>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><ul>
<li>使用<code>fs</code>的API创建一个copy的函数；</li>
<li>NodeJS对文本编码的处理；</li>
<li>使用第三方包<code>findit</code>重写遍历当前目录的程序。</li>
</ul>
<hr>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><h3 id="简单的HTTP服务器"><a href="#简单的HTTP服务器" class="headerlink" title="简单的HTTP服务器"></a>简单的HTTP服务器</h3><p>使用<code>http</code>实现一个简单的HTTP服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">http.createServer(function(req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123;&#x27;Content-type&#x27;: &#x27;text/plain&#x27;&#125;);</span><br><span class="line">    res.end(&#x27;Hello Node.js&#x27;);</span><br><span class="line">&#125;).listen(12306);</span><br></pre></td></tr></table></figure>
<h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><p>http模块提供两种使用方式：</p>
<ul>
<li>作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应；</li>
<li>作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。</li>
</ul>
<p>先创建一个HTTP服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//http-server.js</span><br><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line"></span><br><span class="line">http.createServer(function(req, res) &#123;</span><br><span class="line">   var body = [];</span><br><span class="line">   res.writeHead(200, &#123;&#x27;Content-type&#x27;: &#x27;text/plain&#x27;&#125;);</span><br><span class="line"></span><br><span class="line">   req.on(&#x27;data&#x27;, function(chunk) &#123;</span><br><span class="line">      res.write(chunk);</span><br><span class="line">      body.push(chunk);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   req.on(&#x27;end&#x27;, function() &#123;</span><br><span class="line">      body = Buffer.concat(body);</span><br><span class="line">      console.log(body.toString());</span><br><span class="line">      res.end();</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;).listen(12306);</span><br></pre></td></tr></table></figure>
<p>再创建一个HTTP客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//http-client.js</span><br><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">var options = &#123;hostname: &#x27;localhost&#x27;,</span><br><span class="line">    port: 12306,</span><br><span class="line">    method: &#x27;POST&#x27;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &#x27;Content-type&#x27;: &#x27;text/plain&#x27;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">var req = http.request(options, function(res) &#123;</span><br><span class="line">    res.on(&#x27;data&#x27;, function(chunk) &#123;</span><br><span class="line">       console.log(&#x27;res:&#x27;, chunk.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.write(&#x27;hello world&#x27;);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
<h3 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h3><ul>
<li>parse<br>使用url解析成URL对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; url.parse(&#x27;http://user:pass@host.com:8080/p/a/t/h?query=string#hash</span><br><span class="line">Url &#123;</span><br><span class="line">  protocol: &#x27;http:&#x27;,</span><br><span class="line">  slashes: true,</span><br><span class="line">  auth: &#x27;user:pass&#x27;,</span><br><span class="line">  host: &#x27;host.com:8080&#x27;,</span><br><span class="line">  port: &#x27;8080&#x27;,</span><br><span class="line">  hostname: &#x27;host.com&#x27;,</span><br><span class="line">  hash: &#x27;#hash&#x27;,</span><br><span class="line">  search: &#x27;?query=string&#x27;,</span><br><span class="line">  query: &#x27;query=string&#x27;,</span><br><span class="line">  pathname: &#x27;/p/a/t/h&#x27;,</span><br><span class="line">  path: &#x27;/p/a/t/h?query=string&#x27;,</span><br><span class="line">  href: &#x27;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&#x27; &#125;</span><br></pre></td></tr></table></figure></li>
<li>format<br>format方法允许将一个URL对象转换为URL字符串<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; url.format(&#123;</span><br><span class="line">     protocol: &#x27;http:&#x27;,</span><br><span class="line">     host: &#x27;www.example.com&#x27;,</span><br><span class="line">     pathname: &#x27;/p/a/t/h&#x27;,</span><br><span class="line">     search: &#x27;query=string&#x27;</span><br><span class="line"> &#125;);</span><br><span class="line">//&#x27;http://www.example.com/p/a/t/h?query=string&#x27;</span><br></pre></td></tr></table></figure></li>
<li>resolve<br>resolve方法拼接两个URL<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; url.resolve(&#x27;http://www.baid.com/path&#x27;, &#x27;../www.google.com&#x27;)</span><br><span class="line">&#x27;http://www.baid.com/www.google.com&#x27;</span><br><span class="line">&gt; url.resolve(&#x27;http://example.com/one&#x27;, &#x27;/two&#x27;)</span><br><span class="line">&#x27;http://example.com/two&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; querystring.parse(&#x27;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&#x27;);</span><br><span class="line">&#123; foo: &#x27;bar&#x27;, baz: [ &#x27;qux&#x27;, &#x27;quux&#x27; ], corge: &#x27;&#x27; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><ul>
<li>http模块支持服务端模式和客户端模式两种使用方式；</li>
<li>request和response对象除了用于读写头数据外，可以当作数据流来操作；</li>
<li>url.parse方法加上request.url属性是处理HTTP请求时的固定搭配。</li>
</ul>
<h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h2><ul>
<li>http模块和https模块的区别？</li>
<li>如何创建一个https服务器？</li>
</ul>
<hr>
<h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><h3 id="API一览"><a href="#API一览" class="headerlink" title="API一览"></a>API一览</h3><h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p><code>process</code>是一个全局的对象，可以在node环境中随处访问。并且它是EventEmitter的实例。<br>一个进程对象里头到底包含些什么属性？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pid</span><br><span class="line">stdio</span><br><span class="line">argv</span><br><span class="line">env</span><br></pre></td></tr></table></figure>
<p>只在POSIX平台支持的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getuid</span><br><span class="line">getgid</span><br><span class="line">geteuid</span><br><span class="line">getegid</span><br></pre></td></tr></table></figure>
<p>进程ID、标准输入输出以及错误流、启动进程的参数、运行环境、运行时权限。</p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li><p>获取命令行参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line">console.log(process.argv);</span><br><span class="line"></span><br><span class="line">&gt; node index.js hello</span><br><span class="line">[ &#x27;C:\\Program Files\\nodejs\\node.exe&#x27;, //node的执行路径</span><br><span class="line">  &#x27;C:\\Users\\qianyan\\Projects\\lesson5\\index.js&#x27;, //文件路径</span><br><span class="line">  &#x27;hello&#x27; ] //参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一般获取参数的写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process.argv.splice(2)</span><br></pre></td></tr></table></figure></li>
<li><p>退出程序<br>类似Java中的<code>System.exit(1)</code>，当我们捕获一个异常，同时觉得程序需要立即停止时，就执行<code>process.exit(1)</code>来表示非正常退出。</p>
</li>
<li><p>控制输入和输出<br><code>stdin</code>是只读流，而<code>stdout</code>和<code>stderr</code>都是只写流。<code>console.log</code>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log = (msg) =&gt; &#123;</span><br><span class="line">  process.stdout.write(`$&#123;msg&#125;\n`);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Child-Process"><a href="#Child-Process" class="headerlink" title="Child Process"></a>Child Process</h4><p><code>child_process</code>是一个内置模块，可以创建和控制子进程。该模块的主要功能都是<code>child_process.spawn()</code>函数提供的。其余诸如<code>exec</code>, <code>fork</code>, <code>execFile</code>等都是对<code>spawn()</code>进行的封装。</p>
<h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li>创建子进程</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(command[, args][, options])</span></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">spawn</span>;</span><br><span class="line"><span class="keyword">const</span> echo = <span class="title function_">spawn</span>(<span class="string">&#x27;cmd&#x27;</span>, [<span class="string">&#x27;/c&#x27;</span>, <span class="string">&#x27;env&#x27;</span>], &#123;<span class="attr">env</span>: process.<span class="property">env</span>&#125;);<span class="comment">//尝试设置&#123;env: &#123;&#125;&#125;，观察结果。</span></span><br><span class="line"></span><br><span class="line">echo.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`stdout: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第一参数是可执行文件的路径，第二参数是数组对应可执行文件接收的参数，第三参数用于配置子进程运行的环境和行为。</p>
<ul>
<li>进程间通信<br>如果父子进程都是Node.js的进程，那么就可以通过IPC通道通信。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parent.js</span></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">spawn</span>;</span><br><span class="line"><span class="keyword">const</span> child = <span class="title function_">spawn</span>(<span class="string">&#x27;node&#x27;</span>, [<span class="string">&#x27;child.js&#x27;</span>], &#123;</span><br><span class="line">    <span class="attr">stdio</span>: [process.<span class="property">stdin</span>, process.<span class="property">stdout</span>, process.<span class="property">stderr</span>, <span class="string">&#x27;ipc&#x27;</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;parent:&#x27;</span>, msg);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.<span class="title function_">send</span>(&#123;<span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//child.js</span></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child:&#x27;</span>, msg);</span><br><span class="line">    msg.<span class="property">hello</span> = msg.<span class="property">hello</span>.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    process.<span class="title function_">send</span>(msg);</span><br><span class="line">&#125;)</span><br><span class="line">=&gt;</span><br><span class="line"><span class="attr">child</span>: &#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span> &#125;</span><br><span class="line"><span class="attr">parent</span>: &#123; <span class="attr">hello</span>: <span class="string">&#x27;WORLD&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>父进程在创建子进程的时候，使用了<code>options.stdio</code>的<code>ipc</code>额外开辟了一条通道，之后开始监听子进程的<code>message</code>事件来接收子进程的消息，同时通过<code>send</code>方法给子进程发送消息。子进程则通过<code>process</code>对象监听来自父进程的消息，并通过<code>process.send</code>方法向父进程发送消息。</p>
<h4 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h4><p>单个实例的Node.js运行在单独的进程当中。但是我们有时候可能需要利用多核处理器的优势，在每个单独的核上跑一个Node.js的进程。<br><code>Cluster</code>就是创造出来简化多进程服务程序开发的，让每一个核上面运行一个工作进程，并统一通过主进程监听端口和分发请求。</p>
<h5 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).<span class="title function_">cpus</span>().<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.<span class="property">isMaster</span>) &#123;</span><br><span class="line">  <span class="comment">// Fork workers.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.<span class="title function_">fork</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">worker, code, signal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> died`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Workers can share any TCP connection</span></span><br><span class="line">  <span class="comment">// In this case it is an HTTP server</span></span><br><span class="line">  http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>);</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;hello world\n&#x27;</span>);</span><br><span class="line">  &#125;).<span class="title function_">listen</span>(<span class="number">8000</span>);</span><br><span class="line">&#125;</span><br><span class="line">=&gt;</span><br><span class="line"><span class="variable constant_">NODE_DEBUG</span>=cluster node server.<span class="property">js</span></span><br><span class="line">isMaster</span><br><span class="line">worker</span><br><span class="line">worker</span><br><span class="line">worker</span><br><span class="line">worker</span><br><span class="line">worker</span><br><span class="line">worker</span><br><span class="line">worker</span><br><span class="line">worker</span><br></pre></td></tr></table></figure>
<p>该模块很简单地创建多个共享一个服务端口的子进程，而这些子进程是通过IPC和Master，也即父进程进行信息交互的，可应用于负载均衡。</p>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><ul>
<li>使用<code>process</code>对象管理进程</li>
<li>使用<code>child_process</code>对象管理子进程，其最主要的方法就是<code>spawn</code></li>
</ul>
<h2 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h2><hr>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>NodeJS最大的卖点——事件机制和异步IO，开发者需要按照异步的方式去组织代码。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>异步编程的直接体现就是回调函数，但是不是有回调函数，就是异步编程呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">arr, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum = sum + arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">callback</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line">=&gt;</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>显然，这个<code>callback</code>还是顺序（同步）执行的。我们知道，JS本身是单线程的，所以不具备多线程并发执行的特点，那么异步从何体现呢？<br>我们再看一段程序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">=&gt;</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p>上面的例子先打印出“hello”，然后打印出“world”。看上去好像是<code>setTimeout()</code>另外启动了一个“平行线程”，等待了1秒钟之后，调用回调函数打印“world”。<br>JS中提供了两大类异步函数，一种是计时函数，如：<code>setTimeout</code>和<code>setInterval</code>。另外一类是I&#x2F;O异步函数，如：<code>fs.readFile</code>。</p>
<p>但是JS是单线程的。也就是说如果“主”线程一直处于忙碌状态，即使“平行”线程完成工作，通知“主”线程调用它的回调函数，也会等到“主”线程空闲了才能真正去调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;waiting time: &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>() - t);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">new</span> <span class="title class_">Date</span>() - start &lt; <span class="number">1000</span>);</span><br><span class="line">=&gt;</span><br><span class="line">waiting <span class="attr">time</span>: <span class="number">1094</span> <span class="comment">//大于我们设置的1000毫秒</span></span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>我们分别使用同步和异步实现一个函数，判断当前目录下的文件是否都是File，最终程序返回一个布尔值的数组，如：<code>[true, false]</code><br>当前目录文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|_async.js</span><br><span class="line">|_sync.js</span><br><span class="line">|_ dir/</span><br></pre></td></tr></table></figure>
<h4 id="比较中学习"><a href="#比较中学习" class="headerlink" title="比较中学习"></a>比较中学习</h4><ul>
<li>同步方式下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dirs = fs.<span class="title function_">readdirSync</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> areFiles = dirs.<span class="title function_">map</span>(<span class="function">(<span class="params">dirName</span>) =&gt;</span> &#123;    </span><br><span class="line">    <span class="keyword">return</span> fs.<span class="title function_">statSync</span>(path.<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>, dirName)).<span class="title function_">isFile</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(areFiles);</span><br><span class="line">=&gt; [<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>异步方式下<br><em>失败的尝试</em></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;.&#x27;</span>, <span class="function">(<span class="params">err, dirs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> areFiles = [];</span><br><span class="line"></span><br><span class="line">    dirs.<span class="title function_">forEach</span>(<span class="function">(<span class="params">dirName</span>) =&gt;</span> &#123;  </span><br><span class="line">        fs.<span class="title function_">stat</span>(path.<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>, dirName), <span class="function">(<span class="params">err, stat</span>) =&gt;</span> &#123;</span><br><span class="line">            areFiles.<span class="title function_">push</span>(stat.<span class="title function_">isFile</span>());</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(areFiles);</span><br><span class="line">&#125;);</span><br><span class="line">=&gt; [] <span class="comment">//思考为何是空数组？</span></span><br></pre></td></tr></table></figure>
<p><em>成功的尝试</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;.&#x27;</span>, <span class="function">(<span class="params">err, dirs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> areFiles = [];</span><br><span class="line"></span><br><span class="line">    dirs.<span class="title function_">forEach</span>(<span class="function">(<span class="params">dirName</span>) =&gt;</span> &#123;  </span><br><span class="line">        fs.<span class="title function_">stat</span>(path.<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>, dirName), <span class="function">(<span class="params">err, stat</span>) =&gt;</span> &#123;</span><br><span class="line">            areFiles.<span class="title function_">push</span>(stat.<span class="title function_">isFile</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(areFiles.<span class="property">length</span> == dirs.<span class="property">length</span>) &#123; <span class="comment">//使用标志来位判断所有的回调都已经调用完毕</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(areFiles);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">=&gt;[ <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span> ] or [<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>同步方法顺序取返回值，而异步方法总是在回调函数的取返回值</li>
<li>循环遍历中调用同步方法很容易，但是同样地在异步方法中，需要使用<strong>标志位</strong>来判断是否所有回调函数都已经调用完毕</li>
<li>异步函数的执行回调是无序的</li>
</ol>
<h3 id="数组的串行处理"><a href="#数组的串行处理" class="headerlink" title="数组的串行处理"></a>数组的串行处理</h3><p>我们看到上个例子里的异步的写法，最后的返回结果其实是无序的。使用标志位只能保证数组中的所有数据对应的回调函数都得以执行，但不能保证哪个回调函数先返回。要想顺序执行，那么必须是一个回调函数中包含另一个回调函数。拿上面的例子尝试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;.&#x27;</span>, <span class="function">(<span class="params">err, dirs</span>) =&gt;</span> &#123;</span><br><span class="line">    (<span class="keyword">function</span> <span class="title function_">iterate</span>(<span class="params">index, areFiles, callback</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; dirs.<span class="property">length</span>) &#123;</span><br><span class="line">            fs.<span class="title function_">stat</span>(path.<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>, dirs[index]), <span class="function">(<span class="params">err, stat</span>) =&gt;</span> &#123;</span><br><span class="line">                areFiles.<span class="title function_">push</span>(stat.<span class="title function_">isFile</span>());</span><br><span class="line">                <span class="title function_">iterate</span>(index + <span class="number">1</span>, areFiles, callback);</span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="title function_">callback</span>(areFiles);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(<span class="number">0</span>, [], <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="在场景中学习"><a href="#在场景中学习" class="headerlink" title="在场景中学习"></a>在场景中学习</h4><p>假如我们有这样一个场景：有一系列的HTTP请求的URL构成的数组和一个初始值。这些HTTP请求是有依赖的，后一个的执行必须依赖前一个HTTP请求的响应。如果只是两个请求，我们可以很轻松地写出这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> urls = [<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;www.baidu.com&#x27;</span>]; <span class="comment">//多个urls的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = http.<span class="title function_">request</span>(<span class="title function_">optionsWithHostname</span>(urls[<span class="number">0</span>]), <span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="comment">//第一次请求</span></span><br><span class="line">    res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> req2 = http.<span class="title function_">request</span>(<span class="title function_">optionsWithHostname</span>(urls[<span class="number">1</span>]), <span class="function">(<span class="params">res2</span>) =&gt;</span> &#123;  <span class="comment">//第二次请求</span></span><br><span class="line">            res2.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk2</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//dosometing here...</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        req2.<span class="title function_">write</span>(chunk.<span class="title function_">toString</span>() + <span class="string">&#x27;agian&#x27;</span>);</span><br><span class="line">        req2.<span class="title function_">end</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.<span class="title function_">write</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">req.<span class="title function_">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">optionsWithHostname</span>(<span class="params">hostname</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">hostname</span>: hostname,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">12306</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span></span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果是十个或者更多，这样的写法就不好使了。</p>
<p>我们知道异步函数必须在回调中才能使用其返回值，这样会很容易写出类似于<code>&gt;</code>形状的回调套回调的写法。而递归的写法也正好符合这样的形状，所以尝试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> urls = [<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;www.baidu.com&#x27;</span>]; <span class="comment">//多个urls的数组</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">i, len, initValue, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">    <span class="comment">// 将http请求过程简化成了async</span></span><br><span class="line">        <span class="title function_">async</span>(urls[i], <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">            <span class="title function_">next</span>(i + <span class="number">1</span>, len, value, callback);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="number">0</span>, urls.<span class="property">length</span>, <span class="string">&#x27;hello world&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//dosomething here...</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>在异步函数想要保证执行的顺序，就必须一个回调套一个回调</li>
<li>可以利用递归的写法，在保证执行顺序的同时，处理系列或者不定长度的数据</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="在比较中学习"><a href="#在比较中学习" class="headerlink" title="在比较中学习"></a>在比较中学习</h4><ul>
<li>同步方式下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//try ... catch ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    x.<span class="title function_">func</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I catch you &quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">=&gt; I <span class="keyword">catch</span> you  [<span class="title class_">ReferenceError</span>: x is not defined]</span><br></pre></td></tr></table></figure>

<ul>
<li>异步方式下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        x.<span class="title function_">func</span>();</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I catch you &quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">=&gt; <span class="attr">C</span>:\<span class="title class_">Users</span>\qianyan\<span class="title class_">Projects</span>\lesson6\exception\<span class="keyword">async</span>.<span class="property">js</span>:<span class="number">5</span></span><br><span class="line">        x.<span class="title function_">func</span>();</span><br><span class="line">        ^</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReferenceError</span>: x is not defined</span><br><span class="line">    at <span class="literal">null</span>.<span class="property">_onTimeout</span> (<span class="attr">C</span>:\<span class="title class_">Users</span>\qianyan\<span class="title class_">Projects</span>\lesson6\exception\<span class="keyword">async</span>.<span class="property">js</span>:<span class="number">5</span>:<span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，同步方式下异常会沿着代码执行路径一直冒泡，直到遇到第一个try语句时被捕获住。但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到try语句，就作为一个全局异常抛出。</p>
<p>解决方式就是在异常被作为全局异常抛出之前，try-catch住，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        x.<span class="title function_">func</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I catch you &quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">=&gt; I <span class="keyword">catch</span> you  [<span class="title class_">ReferenceError</span>: x is not defined]</span><br></pre></td></tr></table></figure>
<p>这样异常又被捕获了。不妨，对<code>setTimetout</code>做一次封装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wrapSetTimeout</span>(<span class="params">fn, callback</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title function_">callback</span>(<span class="literal">null</span>, <span class="title function_">fn</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="title function_">callback</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">wrapSetTimeout</span>(<span class="function">() =&gt;</span> &#123;x.<span class="title function_">func</span>()&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I catch you again&quot;</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line">=&gt;I <span class="keyword">catch</span> you again [<span class="title class_">ReferenceError</span>: x is not defined</span><br></pre></td></tr></table></figure>
<p>Node.js的整个异步函数的异常设计都是如此，callback的首个参数都是err。</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li><em>try-catch</em>在同步方式下很有效，但在异步方式下做不到</li>
<li><em>callback</em>首个参数是err，是因为大多数API都遵循了一致的风格</li>
</ul>
<h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><ul>
<li>不掌握异步编程就不算学会NodeJS</li>
<li>异步编程依托于回调来实现，而使用回调不一定就是异步编程</li>
<li>异步编程下的函数间数据传递、数组遍历和异常处理与同步编程有很大差别</li>
</ul>
<hr>
<p>参考链接<br>[1] <a href="https://nqdeng.github.io/7-days-nodejs/">七天学会NodeJS</a><br>[2] <a href="http://es6.ruanyifeng.com/">ECMAScript 6入门 - 阮一峰</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>字符集和字符编码</title>
    <url>/2015/12/21/Character-set-and-encoding/</url>
    <content><![CDATA[<h2 id="什么是字符集"><a href="#什么是字符集" class="headerlink" title="什么是字符集"></a>什么是字符集</h2><h3 id="ASCII-American-Standard-Code-for-Information-Interchange"><a href="#ASCII-American-Standard-Code-for-Information-Interchange" class="headerlink" title="ASCII(American Standard Code for Information Interchange)"></a>ASCII(American Standard Code for Information Interchange)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man ascii</span><br><span class="line">0 ~ 2^7 = 128</span><br></pre></td></tr></table></figure>
<h3 id="欧洲语系-ISO8859"><a href="#欧洲语系-ISO8859" class="headerlink" title="欧洲语系 ISO8859"></a>欧洲语系 ISO8859</h3><ul>
<li>ISO8859-1英语、法语、德语；ISO8859-5 俄语</li>
</ul>
<h3 id="中国的GB2312和GBK，以及中国台湾的Big5"><a href="#中国的GB2312和GBK，以及中国台湾的Big5" class="headerlink" title="中国的GB2312和GBK，以及中国台湾的Big5"></a>中国的GB2312和GBK，以及中国台湾的Big5</h3><h3 id="多语系-Unicode"><a href="#多语系-Unicode" class="headerlink" title="多语系 Unicode"></a>多语系 Unicode</h3><ul>
<li>最初的目的是把世界各地的语言都映射到16位空间</li>
<li>8位转换为16位，称为UCS-2 (2 byte Universal Character Set), 也叫做Basic Multilingual Plane (BMP)</li>
<li>16位到21位，有效编码区间0 ~ 0x10ffff<blockquote>
<p>The Unicode standard describes how characters are represented by code point</p>
</blockquote>
</li>
</ul>
<h2 id="什么是编码方式"><a href="#什么是编码方式" class="headerlink" title="什么是编码方式"></a>什么是编码方式</h2><h3 id="取“鄢”这个字的Unicode编码"><a href="#取“鄢”这个字的Unicode编码" class="headerlink" title="取“鄢”这个字的Unicode编码"></a>取“鄢”这个字的Unicode编码</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;鄢&quot; | native2ascii -encoding utf8</span><br><span class="line">;; \u9122 这个是 code point</span><br></pre></td></tr></table></figure>
<h3 id="一段查看汉字编码的Java代码"><a href="#一段查看汉字编码的Java代码" class="headerlink" title="一段查看汉字编码的Java代码"></a>一段查看汉字编码的Java代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      unicode(<span class="string">&quot;鄢&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">      <span class="comment">// How many bytes: 3 What are they: [-23, -124, -94]</span></span><br><span class="line"></span><br><span class="line">      unicode(<span class="string">&quot;鄢&quot;</span>, <span class="string">&quot;utf16&quot;</span>);</span><br><span class="line">      <span class="comment">// How many bytes: 4 What are they: [-2, -1, -111, 34]</span></span><br><span class="line"></span><br><span class="line">      unicode(<span class="string">&quot;鄢&quot;</span>, <span class="string">&quot;utf-16BE&quot;</span>);</span><br><span class="line">      <span class="comment">// How many bytes: 2 What are they: [-111, 34]</span></span><br><span class="line"></span><br><span class="line">      unicode(<span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;utf-16BE&quot;</span>);</span><br><span class="line">      <span class="comment">// How many bytes: 4 What are they: [-40, 61, -36, 54]</span></span><br><span class="line"></span><br><span class="line">      p(<span class="string">&quot;🐶&quot;</span>.length());</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unicode</span><span class="params">(String s, String encoding)</span>&#123;</span><br><span class="line">		p(<span class="string">&quot;How many bytes: &quot;</span> + s.getBytes(Charset.forName(encoding)).length);</span><br><span class="line">		p(<span class="string">&quot;What are they: &quot;</span> + Arrays.toString(s.getBytes(Charset.forName(encoding))));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">p</span><span class="params">(Object s)</span> &#123;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UTF-8变长编码方式"><a href="#UTF-8变长编码方式" class="headerlink" title="UTF-8变长编码方式"></a>UTF-8变长编码方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\u9122</span><br><span class="line">1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line"></span><br><span class="line">9 -&gt; 1001</span><br><span class="line">1 -&gt; 0001</span><br><span class="line">2 -&gt; 0010</span><br><span class="line">2 -&gt; 0010</span><br><span class="line"></span><br><span class="line">10010001 00100010</span><br><span class="line"></span><br><span class="line">原码</span><br><span class="line">11101001 10000100  10100010</span><br><span class="line"></span><br><span class="line">取反</span><br><span class="line">10010110 11111011 11011101</span><br><span class="line"></span><br><span class="line">补码</span><br><span class="line">10010111 11111100 11011110</span><br><span class="line">16+4+2+1=23 127-3=124 64+16+8+4+2=94</span><br><span class="line">[-23, -124, -94]</span><br></pre></td></tr></table></figure>
<ul>
<li>从程序运行的结果来看，<code>UTF-8</code>中，“鄢”占据了3个字节，且在计算机中的补码表示分别为<code>-23, -124, -94</code>；</li>
<li><code>\u9122</code>占据2个字节，但是带入<code>UTF-8</code>编码提供的<code>1110xxxx 10xxxxxx 10xxxxxx</code>模板中就变成了3个字节，我们是从低位带入模板的，<code>x</code>的个数刚好是16位、2个字节；</li>
<li><code>UTF-8</code>编码除了和ASCII码兼容部分(以0开头，<code>0xxxxxxx</code>)，其余都遵循一个简单的标准：<ul>
<li>其模板遵循<code>110xxxxx 10xxxxxx</code>，高位1的个数即是总的字节数，这里<code>110xxxxx</code>中11表示总共有两个字节；</li>
<li>低位的<code>10xxxxxx</code>始终以10开头；</li>
<li>这样的编码方式，使得程序清楚知道那个地方是字符开始的地方，所以才说<code>UTF-8</code>的单字节的编码方式。</li>
</ul>
</li>
</ul>
<p>但是UTF-8也有自己的缺点</p>
<ul>
<li>浪费内存，几乎所有的汉字都占三个字节</li>
<li>随机访问，同字符串的长度成正比</li>
</ul>
<p><strong>Tips</strong>:</p>
<blockquote>
<p>正数的补码就是其本身<br>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1</p>
</blockquote>
<h2 id="大端字节序和小端字节序-网络字节序和主机字节序"><a href="#大端字节序和小端字节序-网络字节序和主机字节序" class="headerlink" title="大端字节序和小端字节序(网络字节序和主机字节序)"></a>大端字节序和小端字节序(网络字节序和主机字节序)</h2><p>我们知道<code>UTF-16</code>的目的和Unicode本来的目的是一致的 —— “把世界各地的语言都映射到16位空间”。<br>以<code>\u9122</code>为例，我们运行程序的结果应该是2个字节，但是事实上是4个字节（*How many bytes: 4 What are they: [-2, -1, -111, 34]*），这多出来的2个字节是怎么回事？<br>这里就是<a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html">字节序</a>在作祟。在内存存储时，如果最低有效位在最高有效位的前面，则称小端序；反之则称大端序。大端字节序又称网络字节序。<br>举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\u9122 ;;;-&gt;鄢</span><br><span class="line">91是最高有效位</span><br><span class="line">22是最低有效位</span><br></pre></td></tr></table></figure>
<p>我们观察一下返回的4个字节中的前两个字节<code>-2, -1</code>，它们其实不是字符“鄢”的一部分，它们是Unicode中的大端字节序的标识BOM(Bytes Order Marks)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xfeff</span><br><span class="line">11111110 11111111</span><br><span class="line">反码</span><br><span class="line">10000001 10000000</span><br><span class="line">补码</span><br><span class="line">10000010 10000001</span><br><span class="line">-2 -1</span><br></pre></td></tr></table></figure>
<p>Unicode在对待字节序时，采取了大端和小端序共存的方式。<code>0xfeff</code>这个编码在对调字节序后得到的<code>0xfffe</code>在Unicode不存在，Unicode借助这个特点来判断读入的字符到底是大端序还是小端序。<br>另外，从程序中可知，Java会默认将读入的字符串当做大端序处理；所以当我们明确指定<code>UTF-16BE</code>后，程序就会返回2个字节的结果了。</p>
<h2 id="UTF-16不足以表示世界所有的字符"><a href="#UTF-16不足以表示世界所有的字符" class="headerlink" title="UTF-16不足以表示世界所有的字符"></a>UTF-16不足以表示世界所有的字符</h2><p>正如前面提及的UCS-2 (2 byte Universal Character Set)不足以表示世界上所有的字符，比如“🐶”这种emoji的字符需要4个字节才能表示，两个字节的<code>UTF-16</code>就无能为力了。<br>Java默认采用了<code>UTF-16</code>编码，结果导致<code>&quot;🐶&quot;.length()</code>不是返回1，而是2。不得已，Java引入了codePoint这种处理方式，有点无奈。</p>
<h2 id="UCS和CSI"><a href="#UCS和CSI" class="headerlink" title="UCS和CSI"></a>UCS和CSI</h2><p>我们计算机的程序会采用两种方式来处理不同的字符集</p>
<ul>
<li><p>UCS：（Universal Character Set，泛用字符集）程序输入输出的时候，需要将文本数据变成UCS，统一处理。</p>
</li>
<li><p>CSI：（Character Set Independent 字符集独立），不对文字集做变换，直接处理。</p>
</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>积极采用UTF-8。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类的异常处理</title>
    <url>/2016/04/26/Java-Inner-Class-Exception-Handler/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近遇到一个问题，使用Java写某个DSL标记语言X的<em>parser（解析器）Maven</em>插件的时候，对外暴露一个名为<code>Callback</code>的接口和一个待实现的方法*getHTML()*——基于调用处传入的文件名<code>srcX</code>构造出HTML文件的输出路径（其实此处的<code>Callback</code>就是一个闭包，文件名是一个自由变量）。大致代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parser.parse(srcX, <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileWriter <span class="title function_">getHTML</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(outputPath(suffix(srcX, <span class="string">&quot;html&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">suffix</span><span class="params">(String filename, String suffix)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Joiner.on(<span class="string">&quot;.&quot;</span>).join(filename, suffix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里假设输入和输出根路径地址已知</span></span><br><span class="line"><span class="keyword">private</span> File <span class="title function_">outputPath</span><span class="params">(String file)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>(</span><br><span class="line">	           file.replace(srcDir.getAbsolutePath(), <span class="comment">//srcDir: File</span></span><br><span class="line">	             outputDir.getAbsolutePath())); <span class="comment">//outputDir: File</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目前为止还没有任何问题。但若是运行时，这段程序很可能抛出异常<em>java.io.FileNotFoundException: your-file-name (No such file or directory)<em>。原因在于</em>file</em>的路径当中可能存在多级父级目录，例如：<em>outputDir&#x2F;p1&#x2F;p2&#x2F;srcX.html</em>，那么当<em>FileWriter</em>尝试创建<em>srcX.html</em>就会失败。此时最简单的方法就是提前创建好所有的父级目录，于是*outputPath()*方法会变成下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> File <span class="title function_">outputPath</span><span class="params">(String file)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">outputFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(</span><br><span class="line">            file.replace(srcDir.getAbsolutePath(),</span><br><span class="line">                    outputDir.getAbsolutePath()));</span><br><span class="line">    outputFile.getParentFile().mkdirs(); <span class="comment">//创建可能不存在的父级目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outputFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>似乎这段程序可以正常工作了，但是创建文件夹这样的操作是可能失败的。所以我们需要关注是否创建成功，若失败，则写入Log文件当中。修改程序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> File <span class="title function_">outputPath</span><span class="params">(String file)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">outputFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(</span><br><span class="line">            file.replace(srcDir.getAbsolutePath(),</span><br><span class="line">                    outputDir.getAbsolutePath()));</span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">parentDirs</span> <span class="operator">=</span> outputFile.getParentFile();</span><br><span class="line">    <span class="keyword">if</span> (!parentDirs.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parentDirs.mkdirs()) &#123;<span class="comment">//创建可能不存在的父级目录</span></span><br><span class="line">            getLog().error(<span class="string">&quot;Cannot create parent dirs for &#123;&#125;&quot;</span>, outputFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outputFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong><br>这里我们需要先判断父级目录是否存在，即<em>parentDirs.exists()？</em>可是*parentDirs.mkdirs()<em>不是直接返回boolean值来表示是否创建成功吗？是这样么？这儿有</em>mkdirs()*方法的说明：</p>
<blockquote>
<p>public boolean mkdirs()<br>Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories. Note that if this operation fails it may have succeeded in creating some of the necessary parent directories.<br>Returns:<br>true if and only if the directory was created, along with all necessary parent directories; false otherwise</p>
</blockquote>
<p>也就是说只有当这个目录及其所有的父级目录都被创建时，才返回true，反之返回false。照这个推论，如果所有目录事先已经存在了，这个方法应该也会返回true，毕竟都被创建过了嘛。但是只要稍微看一眼源码，你就会发现事实并非如此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mkdirs源码</span></span><br><span class="line"><span class="keyword">if</span> (exists()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里需要特别强调<strong>was created</strong>是一种操作，如果没有进行这个操作，那就不能算这个方法成功。</p>
<p>前面已经提到过，我需要写一个maven的插件，所以最好在这种导致程序崩溃的地方抛出一个maven中通用的异常<em>MojoExecutionException</em>。这样，更改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> File <span class="title function_">outputPath</span><span class="params">(String file)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">outputFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(</span><br><span class="line">            file.replace(srcDir.getAbsolutePath(),</span><br><span class="line">                    outputDir.getAbsolutePath()));</span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">parentDirs</span> <span class="operator">=</span> outputFile.getParentFile();</span><br><span class="line">    <span class="keyword">if</span> (!parentDirs.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parentDirs.mkdirs()) &#123;<span class="comment">//创建可能不存在的父级目录</span></span><br><span class="line">            getLog().error(<span class="string">&quot;Cannot create parent dirs for &#123;&#125;&quot;</span>, outputFile);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MojoExecutionException</span>(<span class="string">&quot;Cannot create parent dirs&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outputFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，问题才显出端倪——异常<em>MojoExecutionException</em>是一个受检的异常(checked Exception)，它间接继承自<em>java.lang.Exception</em>。可是我们的<em>getHTML()<em>方法并没有在签名中抛出任何异常，编译无法通过。那唯一的办法就是</em>try…catch</em>了，但是我不应该捕获自己<strong>刚刚</strong>抛出来的异常，否则抛出受检异常的意义何在？</p>
<p>这时，自然而然会想到，将方法签名改成<em>getHTML() throws MojoExecutionException</em>。确实可行，但是并不合适，因为<em>MojoExecutionException</em>只是Maven插件规定的异常，而getHTML()则是一个对外暴露的API，不应该依赖于某个具体的异常。所以我将异常扩大化：<em>getHTML() throws Exception</em>，这样做的好处很明显，坏处也很显眼。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li>牢记《Unix编程艺术》中的“宽收严发”原则。即子类实现父类、接口的方法，入参可以扩大，出参可以缩小。举个例子：父类、接口有个方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">something</span><span class="params">(HashMap map)</span> <span class="keyword">throws</span> Exception</span><br></pre></td></tr></table></figure>
<p>那么子类实现这个方法可以这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">something</span><span class="params">(Map map)</span></span><br><span class="line">                  <span class="keyword">throws</span> ExecutionException, NoSuchMethodException</span><br></pre></td></tr></table></figure>
<p>这里，入参是HashMap，出参是Object和Exception。入参扩大，所以子类出现了Map；出参缩小，所以子类出现了String和ExecutionException和NoSuchMethodException。同理，此处<em>getHTML() throws Exception</em>由子类实现的形式可以是<em>getHTML() throws MojoExecutionException</em>。</p>
<h3 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h3><ol>
<li>不管getHTML()是否需要抛出异常，你都得在实现代码中抛出异常；</li>
<li>由于对外表现的是抛出较宽泛的Exception，所以丧失了对于具体受检 (checked exception)异常进行检查的好处。</li>
</ol>
<p>这里有个JDK中比较类似的例子，就是关于<code>Runnable</code>和<code>Callable</code>接口的设计问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它们就是两个极端，<code>Runnable</code>必须将受检的异常转换成非受检(unchecked exception)或者发明一种方式来将异常暴露给调用者；<code>Callable</code>就是无论如何都得抛出异常，而且迫使用户去捕获一个较宽泛的异常。</p>
<h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>这个时候，泛型就派上用场了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Exception</span>&gt; &#123;</span><br><span class="line">    FileWriter <span class="title function_">getHTML</span><span class="params">()</span> <span class="keyword">throws</span> E;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//interface parser</span></span><br><span class="line"><span class="keyword">public</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Exception</span>&gt; <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(String srcX, Callback&lt;E&gt; cb)</span> <span class="keyword">throws</span> E;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，我们可以捕获具体的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    parser.parse(srcX, <span class="keyword">new</span> <span class="title class_">Callback</span>&lt;MojoExecutionException&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileWriter <span class="title function_">getHTML</span><span class="params">()</span> <span class="keyword">throws</span> MojoExecutionException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(outputPath(suffix(srcX, <span class="string">&quot;html&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (MojoExecutionException e) &#123;</span><br><span class="line">    getLog().error(<span class="string">&quot;Failed to execute. &#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用lambda表达式可以简化成下面的模样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    parser.parse(srcX, (Callback&lt;MojoExecutionException&gt;) () -&gt; <span class="keyword">new</span> <span class="title class_">FileWriter</span>(outputPath(suffix(srcX, <span class="string">&quot;html&quot;</span>))));</span><br><span class="line">&#125; <span class="keyword">catch</span> (MojoExecutionException e) &#123;</span><br><span class="line">    getLog().error(<span class="string">&quot;Failed to execute. &#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们解决了<em>迫使用户去捕获一个较宽泛的异常</em>的问题，但是<em>无论如何都得抛出异常这个问题</em>还是没有得到解决。或许我们需要一个像是<em>throws Nothing</em>一样的语法，表示什么也没有抛出来。我们知道RuntimeException是非受检的异常(unchecked exception)，所以<em>throws RuntimeException</em>就表明这个异常跟没有抛出异常一样，不需要捕获。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parser.parse(srcX, <span class="keyword">new</span> <span class="title class_">Callback</span>&lt;Nothing&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileWriter <span class="title function_">getHTML</span><span class="params">()</span> <span class="keyword">throws</span> Nothing &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(outputPath(suffix(srcX, <span class="string">&quot;html&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Nothing</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>走到这一步，我们算是较为完全地解决了匿名内部类的异常处理问题。</p>
<h2 id="异常透明化"><a href="#异常透明化" class="headerlink" title="异常透明化"></a>异常透明化</h2><blockquote>
<p>With the throws type parameter on the Block interface, we can now accurately generify over the set of exceptions thrown by the Block; with the generic forEach method, we can mirror the exception behavior of the block in forEach(). This is called exception transparency because now the exception behavior of forEach can match the exception behavior of its block argument. Exception transparency simplifies the construction of library classes that implement idioms like internal iteration of data structures, because it is common that methods that accept function-valued arguments will invoke those functions, meaning that the library method will throw a superset of the exceptions thrown by its function-valued arguments.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Block</span>&lt;T, <span class="keyword">throws</span> E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(T element)</span> <span class="keyword">throws</span> E;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NewCollection</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>&lt;<span class="keyword">throws</span> E&gt; forEach(Block&lt;T, <span class="keyword">throws</span> E&gt; block) <span class="keyword">throws</span> E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常透明化，简单来讲，就是调用者的签名中的异常完全由它的函数值(function-valued)的参数决定，所有这些调用者最终的异常都会是该函数值所注异常的超集。</p>
<p>异常透明化就是用来解决我们常用的通过内部类模拟闭包调用时异常处理的手法了。</p>
<hr>
<p><strong>闭包的定义</strong><br>一个包含了自由变量的开发表达式，和该自由变量的约束环境组合之后，产生了一种封闭的状态。</p>
<hr>
<p>参考链接<br>[1] <a href="https://blogs.oracle.com/briangoetz/entry/exception_transparency_in_java">Exception Transparency</a><br>[2] <a href="http://stackoverflow.com/questions/8101575/throwing-checked-exceptions-from-anonymous-inner-classes">Throwing Checked Exceptions from Anonymous Inner Classes</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Mistakes I Hav Made</tag>
      </tags>
  </entry>
  <entry>
    <title>高编译低运行错误(ConcurrentHashMap.keySet)</title>
    <url>/2016/05/24/Using-Java1.8-to-Target-Older-JVMs/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>本地使用maven编译和运行时一切都正常，但是通过ci的方式，编译、打包、发布到部署环境，运行时抛出了一条一眼便知是关于JDK版本的错误。</p>
<p>错误是这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet() </span><br><span class="line">Ljava/util/concurrent/ConcurrentHashMap$KeySetView;</span><br></pre></td></tr></table></figure>

<p>报的是的NoSuchMethodError的错误，且是关于java.util.concurrent.ConcurrentHashMap的。所以不难排查出原因是ci使用了JDK 8来进行编译，导致生成的字节码包含了JDK 8更改的新方法keySet——ConcurrentHashMap$KeySetView这个新增内部类作为其返回值的类型。</p>
<p>为了进一步验证部署服务器上的class文件都是JDK 8编译的，我使用javap这个JDK自带的工具做了如下的验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javap -v a.class |grep major</span><br></pre></td></tr></table></figure>
<p>返回的结果是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">major version: 51</span><br></pre></td></tr></table></figure>
<p>问题初露端倪，51对应的JDK版本号应该是1.7（或者7），52才是JDK 8的major版本。这里出现了两个疑惑：</p>
<ul>
<li>为什么ci使用JDK 8编译的class会是JDK 7的编译结果？</li>
<li>既然是JDK 7编译的class文件，那为何会出现JDK 8才有的内部类？</li>
</ul>
<p>先看第一个疑惑。之前说到ci也是通过maven compiler plugin进行编译的，pom.xml中可以配置language level如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这实际对应于javac的-source和-target参数，那么这两个参数具体代表什么呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac -<span class="built_in">help</span></span></span><br><span class="line">-source &lt;release&gt;          Provide source compatibility with specified release</span><br><span class="line">-target &lt;release&gt;          Generate class files for specific VM version</span><br></pre></td></tr></table></figure>
<p>source参数指的是源代码级别的语法兼容，而target参数指的是生成release版本的兼容性的class文件，不过<strong>只确保目标VM能够加载class文件，却无法保证运行时的正确性</strong>。接下来，我们尝试使用javac加上这些参数来编译源码。</p>
<p>首先我们写一段程序，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.java</span></span><br><span class="line"><span class="keyword">package</span> com.lambeta;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcurrentHashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line">        map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我本机的java版本是1.8，直接使用javac来编译App.java，结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac App.java</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javap -v App.class |grep major</span></span><br><span class="line"> major version: 52</span><br></pre></td></tr></table></figure>
<p>如果指定source和target参数，再用javac编译App.java</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -version</span></span><br><span class="line">java version &quot;1.8.0_45&quot;</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac -<span class="built_in">source</span> 7 -target 7 App.java</span></span><br><span class="line">warning: [options] bootstrap class path not set in conjunction with -source 1.7</span><br><span class="line">1 warning</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">App.class App.java</span><br></pre></td></tr></table></figure>
<p>这里有个警告，我们暂时不看。先使用javap反编译App.class，观察major version以及keySet()这个方法的返回值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javap -v App.class</span></span><br><span class="line">...</span><br><span class="line">major version: 51</span><br><span class="line">...</span><br><span class="line">9: invokevirtual #4                  </span><br><span class="line">// Method java/util/concurrent/ConcurrentHashMap.keySet:()</span><br><span class="line"><span class="meta prompt_">Ljava/util/concurrent/ConcurrentHashMap$</span><span class="language-bash">KeySetView;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样，第二个疑惑也解开了。可以初步得出一个结论。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在javac指定了这些参数，降低版本号来编译，会导致生成class文件被标识为较低版本以供指定的JVM加载。<strong>但是</strong>，基于JDK 8的bootstrap class编译而成的keySet()方法，其返回值依旧是JDK 8中ConcurrentHashMap$KeySetView这个新增内部类。运行时，1.7的JVM尝试加载这个class文件，一定找不到KeySetView作为返回值的keySet()方法，出错。</p>
<h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>既然知道错在那里，就比较容易寻找到解决方案了。</p>
<ul>
<li>编译期间，替换掉bootstrap class</li>
<li>使用父类&#x2F;接口替换子类，即ConcurrentMap替换ConcurrentHashMap声明</li>
</ul>
<h3 id="编译期间，替换掉bootstrap-clas"><a href="#编译期间，替换掉bootstrap-clas" class="headerlink" title="编译期间，替换掉bootstrap clas"></a>编译期间，替换掉bootstrap clas</h3><p>javac编译时，可以指定bootclasspath，来替换默认的加载路径，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac -bootclasspath /Library/Java/JavaVirtualMachines/jdk1.7.0_60.jdk/Contents/Home/jre/lib/rt.jar \</span><br><span class="line">-source 7 -target 7 App.java</span><br><span class="line">// or</span><br><span class="line">javac -Xbootclasspath:/Library/Java/JavaVirtualMachines/jdk1.7.0_60.jdk/Contents/Home/jre/lib/rt.jar \</span><br><span class="line">-source 7 -target 7 App.java</span><br></pre></td></tr></table></figure>
<p>这时候，再去看看反编译的结果，就会是这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">major version: 51</span><br><span class="line">...</span><br><span class="line">9: invokevirtual #4                  </span><br><span class="line">// Method java/util/concurrent/ConcurrentHashMap.keySet:()Ljava/util/Set;</span><br></pre></td></tr></table></figure>
<p>此时major是51(JDK 7），而keySet()的返回值也是JDK 7中的java.util.Set类型了。</p>
<h3 id="使用父类-接口替换子类，即ConcurrentMap替换ConcurrentHashMap声明"><a href="#使用父类-接口替换子类，即ConcurrentMap替换ConcurrentHashMap声明" class="headerlink" title="使用父类&#x2F;接口替换子类，即ConcurrentMap替换ConcurrentHashMap声明"></a>使用父类&#x2F;接口替换子类，即ConcurrentMap替换ConcurrentHashMap声明</h3><p>上一种方案虽然可行，但是却不实用——因为不能要求ci服务器上有两个不同版本的JDK，也不能要求在maven构建时传递与安装路径如此紧耦合的值作为bootclasspath的参数值。所以可以采取将具体实现类的声明替换成为其接口的方式，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lambeta;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcurrentMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line">        map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样编译好的字节码中就不会有ConcurrentHashMap$KeySetView这样的返回值类型了。在JDK 7上运行时，JVM动态调用的一定是ConcurrentHashMap的keySet():java.util.Set方法了。</p>
<hr>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>保证编译、打包环境和最终部署环境JDK版本的一致性</li>
<li>如果无法保证，就尽量面向接口编程，尤其是JDK中提供的类。原因是接口不易改变，而实现类遵循“宽收严发”原则，方法的入参和出参都是易变的。</li>
</ul>
<hr>
<p>参考链接<br>[1] <a href="http://vanillajava.blogspot.jp/2012/02/using-java-7-to-target-much-older-jvms.html">Using Java 7 to target much older JVMs</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Mistakes I Hav Made</tag>
      </tags>
  </entry>
  <entry>
    <title>SonarQube Plugin Step by Step</title>
    <url>/2016/06/24/SonarQube-Plugin-Step-by-Step/</url>
    <content><![CDATA[<h2 id="插件不好写？！"><a href="#插件不好写？！" class="headerlink" title="插件不好写？！"></a>插件不好写？！</h2><p>插件确实不好写，因为插件是插入庞大的系统当中工作的，那也就意味着写插件需要具备一定的领域知识，包括系统架构、扩展点、业务共性及差异、API及其业务模型对应、安装和测试。而对于开发者而言，学习这些知识的代价绝对是昂贵的。<br>在《函数式编程思想》一书中，作者Neal Ford提到开发过程当中的两种抽象方式——composable and contextual abstract. 谈及contextual抽象的时候，他把插件系统列为这一抽象中最经典的例子。</p>
<blockquote>
<p>Plugin-based architectures are excellent examples of the contextual abstraction. The plug-in API provides a plethora of data structures and other useful context that developers inherit from or summon via already existing methods. But to use the API, a developer must understand what that context provides, and that understanding is sometimes expensive. </p>
</blockquote>
<p>大意是开发者能够借助已存在的方法来使用Plugin API中提供的大量数据结构和有用的上下文信息。但是，理解起这些上下文信息有时是很昂贵的。</p>
<p>基于一个共识：开发者的时间都是宝贵的。知道插件难写之后，我的这篇文章才有价值。</p>
<h2 id="理解领域模型"><a href="#理解领域模型" class="headerlink" title="理解领域模型"></a>理解领域模型</h2><p>一说写插件，估计大家都会上官网寻找开发指南或者google大量博客来快速完成开发任务。这里不是说这种方式不好，其实一开始我也是这么做的，但是着手开发以后，很快就遭遇处处掣肘。比如：开发sonar plugin，会用到<em>Profile、Rule、Language</em>和<em>Repository</em>等概念。单从代码层面上看，我们很难理清这些概念所代表的模型和它们之间的<strong>关系</strong>。所以需要从用户的视角来<strong>感受</strong>这些领域知识。</p>
<p>而用户视角大部分情况下就是UI界面。</p>
<h3 id="规则（Rules）"><a href="#规则（Rules）" class="headerlink" title="规则（Rules）"></a>规则（Rules）</h3><p>我们先看看<em>Rules</em>导航栏，左边的单选框是这些规则的过滤条件。<br>说明规则包含或者被包含这些属性之下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-a6ad47ad581e7fc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rules"></p>
<ul>
<li>Language：规则对应的某种编程语言。</li>
<li>Type：规则的类型，比如：缺陷（Bug）、代码坏味道（Code Smell）、易受攻击（Vulnerability）。</li>
<li>Tag：规则设置的标签，易于检索。</li>
<li>Repository：承载特定语言下各种规则的容器；通过它可以通过规则的键值（ruleKey）检索。</li>
<li>Default Severity：触犯规则的严重程度。<ul>
<li>Blocker：最高等级，阻碍的</li>
<li>Critical：高等级，极为严重的</li>
<li>Major：较高等级，主要的；默认级别。</li>
<li>Minor：较低等级</li>
<li>Info：低等级</li>
</ul>
</li>
<li>Status：规则现在的状态，可用、废弃还是实验版（Beta）。</li>
<li>Avaiable Since：什么时候开始可用。</li>
<li>Template：规则模板：比如某些参数可以运行时传入。</li>
<li>Quality Profile：挑选特定语言下各种规则组成的配置；其中可以启用或禁用一部分规则。</li>
</ul>
<h3 id="质量Profile（Quality-Profile）"><a href="#质量Profile（Quality-Profile）" class="headerlink" title="质量Profile（Quality Profile）"></a>质量Profile（Quality Profile）</h3><p>再看看<em>Quality Profiles</em>导航栏，左侧栏显示的是某种语言包含的所有Profiles.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-7b8bbbf54b9462dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Profiles"></p>
<p>从关系型数据库的角度，Language和Profile是1对多（one-to-many）关系，但是从领域建模的角度，Profile其实和Language是1对1的关系。所以可以是Profile包含Language属性。利用领域建模的思考方式，可以联想到Repository和Rules是1对多的关系，所以Repository包含一个Rules的集合。Repository和Language是1对1的关系，Repository包含Language属性。那么Rules和Profiles的对应关系呢？多对多。但是我们更关心Profile到Rules这一层的关系，所以选择Profile包含一个Rules的集合。</p>
<p>我整理出这样一份对应关系图：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">profile</span><br><span class="line">    - language</span><br><span class="line">    - [rules]</span><br><span class="line">respository</span><br><span class="line">    - lanuage</span><br><span class="line">    - [rules]</span><br></pre></td></tr></table></figure>
<p>现在，缺少Profile和Repository的关系。不过既然有了Rule这一层联系，那么就可以这样考虑，Rule和Repository是1对1的关系（为什么呢？因为每个Rule显然只能存在于一个特定的Repository当中）。所以原图可以修改为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">profile</span><br><span class="line">    - language</span><br><span class="line">    - [rules]</span><br><span class="line">      - rule</span><br><span class="line">        - respository</span><br><span class="line">respository</span><br><span class="line">    - language</span><br><span class="line">    - [rules]</span><br></pre></td></tr></table></figure>
<p>好了。梳理完这些领域知识，我们可以开始依照官方的教程<a href="http://docs.sonarqube.org/display/DEV/Developing+a+Plugin">Developing a Plugin</a>.</p>
<h2 id="扫描特定领域语言（DSL）的SonarQube插件"><a href="#扫描特定领域语言（DSL）的SonarQube插件" class="headerlink" title="扫描特定领域语言（DSL）的SonarQube插件"></a>扫描特定领域语言（DSL）的SonarQube插件</h2><p>SonarQube 5.6现在只支持Java 8、Maven 3.1以上。当然也支持Gradle。</p>
<h3 id="第一步-创建一个Maven工程"><a href="#第一步-创建一个Maven工程" class="headerlink" title="第一步 创建一个Maven工程"></a>第一步 创建一个Maven工程</h3><p>这里有两种方式。第一种方式就是从头开始写起，包括创建工程；另一种就是拷贝官方的<a href="https://github.com/SonarSource/sonar-examples">样例程序</a>。我自然是推荐第二种做法，不过这里我从零开始开发。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mvn archetype:create -DgroupId=com.lambeta -DartifactId=sonar-lambeta -DarchetypeArtifactId=maven-archetype-quickstart</span></span><br></pre></td></tr></table></figure>
<p>依照官方文档将pom.xml修改如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lambeta<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sonar-custom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>sonar-plugin<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>sonar-custom<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://www.lambeta.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonarsource.sonarqube<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sonar-plugin-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- minimal version of SonarQube to support. Note that the groupId was &quot;org.codehaus.sonar&quot; before version 5.2 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- mandatory scope --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.pmd<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pmd-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonarsource.sonar-packaging-maven-plugin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sonar-packaging-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pluginClass</span>&gt;</span>com.lambeta.CustomPlugin<span class="tag">&lt;/<span class="name">pluginClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pluginDescription</span>&gt;</span>how to write sonar plugin<span class="tag">&lt;/<span class="name">pluginDescription</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> pmd-xml、dom4j会在后面的编程当中使用到。</p>
</blockquote>
<p>依据标准的代码结构，新建<em>CustomPlugin.java</em>文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   └── com</span><br><span class="line">│   │   │       └── lambeta</span><br><span class="line">│   │   │           ├── CustomPlugin.java</span><br></pre></td></tr></table></figure>
<h3 id="第二步-识别扩展点"><a href="#第二步-识别扩展点" class="headerlink" title="第二步 识别扩展点"></a>第二步 识别扩展点</h3><p>此时，该去查看<a href="http://docs.sonarqube.org/display/DEV/API+Basics">API Basics</a>了。不过在写代码之前，还得先了解所谓的扩展点（Extension Points）。</p>
<blockquote>
<p>Scanner, which runs the source code analysis<br>Compute Engine, which consolidates the output of scanners, for example by<br>computing 2nd-level measures such as ratings<br>aggregating measures (for example number of lines of code of project &#x3D; sum of lines of code of all files)<br>assigning new issues to developers<br>persisting everything in data stores<br>Web application</p>
</blockquote>
<p>翻译如下</p>
<ul>
<li>扫描器：分析源代码</li>
<li>计算引擎：聚合扫描器的输出。举例：计算第二轮measures，如打分；聚合measures（举例：工程中所有代码的行数 &#x3D; 所有文件的代码行的综合）；给开发者安排新的问题；持久化。</li>
<li>Web应用程序。<br>翻译还不如不翻译！一言不合，去看例子程序…的<a href="https://github.com/SonarSource/sonar-examples/blob/master/plugins/sonar-example-plugin/src/main/java/org/sonarsource/plugins/example/ExamplePlugin.java">注释</a></li>
</ul>
<p>这三个扩展点，其实对应于API中的三个接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">扫描器 -&gt; Sensor</span><br><span class="line">计算引擎 -&gt; MeasureComputer</span><br><span class="line">Web应用程序 -&gt; Widget</span><br></pre></td></tr></table></figure>

<h3 id="第三步-定义Sensor（Scanner"><a href="#第三步-定义Sensor（Scanner" class="headerlink" title="第三步 定义Sensor（Scanner)"></a>第三步 定义Sensor（Scanner)</h3><p>基于扫描DSL源码的需求，我们需要扩展Sensor这个接口。新建<em>CustomSensor.java</em>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomSensor</span> <span class="keyword">implements</span> <span class="title class_">Sensor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">describe</span><span class="params">(SensorDescriptor descriptor)</span> </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(SensorContext context)</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要定义这门DSL语言的某些属性，以便于识别以及扫描时过滤相关的源文件（通过文件的后缀）。</p>
<h3 id="第四步-定义语言（Language）"><a href="#第四步-定义语言（Language）" class="headerlink" title="第四步 定义语言（Language）"></a>第四步 定义语言（Language）</h3><p>新建<em>CustomLanguage</em>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lambeta;</span><br><span class="line"><span class="keyword">import</span> org.sonar.api.resources.AbstractLanguage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomLanguage</span> <span class="keyword">extends</span> <span class="title class_">AbstractLanguage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;custom-key&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;custom-name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomLanguage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(KEY, NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getFileSuffixes() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;csm.xml&quot;</span>&#125;; <span class="comment">//custom这门基于xml的内部DSL的文件后缀</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我定义了一门基于xml语法的内部DSL，其文件的后缀是<em>csm.xml</em>。比如：<em>right-syntax.csm.xml</em></p>
<p>Language定义出来了，我们还得定义rule、profile和repository. 回到上文提及的language、rule、profile以及repository的关系图：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">profile</span><br><span class="line">    - language</span><br><span class="line">    - [rules]</span><br><span class="line">      - rule</span><br><span class="line">        - respository</span><br><span class="line">respository</span><br><span class="line">    - language</span><br><span class="line">    - [rules]</span><br></pre></td></tr></table></figure>
<h3 id="第五步-定义规则（Rule）"><a href="#第五步-定义规则（Rule）" class="headerlink" title="第五步 定义规则（Rule）"></a>第五步 定义规则（Rule）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">respository</span><br><span class="line">    - language</span><br><span class="line">    - [rules]</span><br></pre></td></tr></table></figure>
<p>我们需要实现接口<em>RulesDefinition</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lambeta;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.Charsets;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.sonar.api.server.rule.RulesDefinition;</span><br><span class="line"><span class="keyword">import</span> org.sonar.api.server.rule.RulesDefinitionXmlLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRulesDefinition</span> <span class="keyword">implements</span> <span class="title class_">RulesDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REPOSITORY_KEY</span> <span class="operator">=</span> <span class="string">&quot;custom-repo&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RulesDefinitionXmlLoader xmlLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomRulesDefinition</span><span class="params">(RulesDefinitionXmlLoader xmlLoader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.xmlLoader = xmlLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">define</span><span class="params">(Context context)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> getClass().getResourceAsStream(<span class="string">&quot;/rules.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">NewRepository</span> <span class="variable">repository</span> <span class="operator">=</span> context.createRepository(REPOSITORY_KEY, CustomLanguage.KEY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stream != <span class="literal">null</span>) &#123;</span><br><span class="line">                xmlLoader.load(repository, stream, Charsets.UTF_8);</span><br><span class="line">            &#125;</span><br><span class="line">            repository.done();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(stream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过context新建出一个repository。respository需要一个唯一key作为其标识（可以通过setName方法设置名称）以及一个language key来关联（从UI上可以看出来）。然后，通过DI进来的<em>RulesDefinitionXmlLoader</em>将<em>rules.xml</em>中定义的rules加载进repository中。最后，调用*reposiotory.done()*宣告加载完成。</p>
<p>定义的<em>rules.xml</em>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>ComponentsMustNotBeFollowedByComponentsRule<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Components标签后不能跟随Components标签规则<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">            &lt;![CDATA[</span><br><span class="line">                Components标签后不能跟随Components标签</span><br><span class="line">            ]]&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">severity</span>&gt;</span>MINOR<span class="tag">&lt;/<span class="name">severity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cardinality</span>&gt;</span>SINGLE<span class="tag">&lt;/<span class="name">cardinality</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">status</span>&gt;</span>READY<span class="tag">&lt;/<span class="name">status</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span>&gt;</span>custom<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">example</span>&gt;</span></span><br><span class="line">            &lt;![CDATA[</span><br><span class="line">                &lt;components&gt;</span><br><span class="line">                &lt;!-- Error, components must be here! --&gt;</span><br><span class="line">                    &lt;components/&gt;</span><br><span class="line">                &lt;/components&gt;</span><br><span class="line">            ]]&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">example</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>包含了rule的key和其他相关的属性。它们最终显示在UI上，会是这样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-91243613d40090e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rule"></p>
<h3 id="第六步-定义Profile"><a href="#第六步-定义Profile" class="headerlink" title="第六步 定义Profile"></a>第六步 定义Profile</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">profile</span><br><span class="line">    - language</span><br><span class="line">    - [rules]</span><br><span class="line">      - rule</span><br><span class="line">        - respository</span><br></pre></td></tr></table></figure>
<p>我们需要实现接口<em>ProfileDefinition</em>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lambeta;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.sonar.api.profiles.ProfileDefinition;</span><br><span class="line"><span class="keyword">import</span> org.sonar.api.profiles.RulesProfile;</span><br><span class="line"><span class="keyword">import</span> org.sonar.api.profiles.XMLProfileParser;</span><br><span class="line"><span class="keyword">import</span> org.sonar.api.utils.ValidationMessages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomProfileDefinition</span> <span class="keyword">extends</span> <span class="title class_">ProfileDefinition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XMLProfileParser xmlProfileParser;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomProfileDefinition</span><span class="params">(XMLProfileParser xmlProfileParser)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.xmlProfileParser = xmlProfileParser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RulesProfile <span class="title function_">createProfile</span><span class="params">(ValidationMessages validation)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(getClass().getResourceAsStream(<span class="string">&quot;/profile.xml&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> xmlProfileParser.parse(reader, validation);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(reader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用DI注入的XMLProfileParser解析<em>profile.xml</em>文件，并生成RulesProfile对象。我们来看看<em>profile.xml</em>的内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">language</span>&gt;</span>custom-key<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Custom Quality<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositoryKey</span>&gt;</span>custom-repo<span class="tag">&lt;/<span class="name">repositoryKey</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>ComponentsMustNotBeFollowedByComponentsRule<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">priority</span>&gt;</span>MAJOR<span class="tag">&lt;/<span class="name">priority</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里定义一个名为<em>Custom Quality</em>的profile，它关联CustomLanguage的键值：custom-key. 同时包含了多条rules，每条rule拥有自己的标识key以及其所在的repository（事实上，profile会在repository中通过ruleKey来查找rule）。</p>
<p>写到这里，一个DSL的SonarQube Plugin已经几近完善。但是，我们还缺少至关重要的一环——<strong>规则的执行！</strong></p>
<h3 id="第七步-运行PMD扫描代码"><a href="#第七步-运行PMD扫描代码" class="headerlink" title="第七步 运行PMD扫描代码"></a>第七步 运行PMD扫描代码</h3><h4 id="PMD简介"><a href="#PMD简介" class="headerlink" title="PMD简介"></a>PMD简介</h4><p>我们需要一个静态扫描工具来扫描源代码，发现这些代码存在的缺陷和坏味道。PMD就是这么一款好用的工具。</p>
<blockquote>
<p>PMD is a source code analyzer. It finds common programming flaws like unused variables, empty catch blocks, unnecessary object creation, and so forth. It supports Java, JavaScript, PLSQL, Apache Velocity, XML, XSL.</p>
</blockquote>
<p>翻译：<br>PMD是一款源码分析工具。它会发现编程中的普遍缺陷，如未使用的变量、空的catch块、不必要的对象创建等等。它支持分析Java、Javascript、PLSQL、Apache Velocity、XML、XSL语言。</p>
<p>前面提到我定义的是一门基于XML的DSL，那么理所当然，可以借助PMD，扩展XML的扫描规则来满足自己的需求。</p>
<p>PMD在命令行中执行的方式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pmd -d src/ -f xml -R myrule.xml -r dest/report.xml</span><br></pre></td></tr></table></figure>
<ul>
<li>-d 代表要扫描的源码目录</li>
<li>-f 代表报告输出的格式</li>
<li>-R 代表采用哪些规则来扫描源代码</li>
<li>-r 代表报告的输出路径</li>
</ul>
<blockquote>
<p><strong>注意：</strong>这里PMD的规则和SonarQube中的规则其实没有太大关系，属于两种事物。不过，为方便后续提取PMD输出的报告，需要将PMD规则的名字和Sonar规则的键值保持一致。</p>
</blockquote>
<p>我们定义PMD需要使用到的规则集<em>custom-pmd-rules.xml</em>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ruleset</span> <span class="attr">name</span>=<span class="string">&quot;ExamplePmdRuleset&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://pmd.sourceforge.net/ruleset/2.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">        Example set of configured PMD rules</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span> <span class="attr">name</span>=<span class="string">&quot;ComponentsMustNotBeFollowedByComponentsRule&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">message</span>=<span class="string">&quot;Components tags followed by components tag found!&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">language</span>=<span class="string">&quot;xml&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;net.sourceforge.pmd.lang.rule.XPathRule&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">            Tag components must not be followed by components tag.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">priority</span>&gt;</span>1<span class="tag">&lt;/<span class="name">priority</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xpath&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>//components/components<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">example</span>&gt;</span></span><br><span class="line">            &lt;![CDATA[</span><br><span class="line">                &lt;components&gt;</span><br><span class="line">                    &lt;components&gt;</span><br><span class="line">                &lt;/components&gt;</span><br><span class="line">            ]]&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">example</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的类<em>net.sourceforge.pmd.lang.rule.XPathRule</em>来自于我们先前在pom.xml中声明的pmd-xml这个依赖包。它可以让我们通过设置<em>xpath</em>这一属性的值来构建各种不同规则。扫描中XML文件一旦匹配这些xpath规则，就会输出错误报告。</p>
<p>以<em>ComponentsMustNotBeFollowedByComponentsRule</em>这个自定义的规则为例。顾名思义，Components元素下不能再跟着Components元素。它在PMD扫描过程中如果被匹配上，会输出这样的报告：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pmd</span> <span class="attr">version</span>=<span class="string">&quot;5.4.2&quot;</span> <span class="attr">timestamp</span>=<span class="string">&quot;2016-06-23T23:06:04.120&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span> <span class="attr">name</span>=<span class="string">&quot;/Users/qianyan/github/sonar/sonar-custom/src/test/resources/wrong-syntax-but-not-csm.xml&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">violation</span> <span class="attr">beginline</span>=<span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">endline</span>=<span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">begincolumn</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">endcolumn</span>=<span class="string">&quot;17&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">rule</span>=<span class="string">&quot;ComponentsMustNotBeFollowedByComponentsRule&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ruleset</span>=<span class="string">&quot;ExamplePmdRuleset&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">priority</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            Components tags followed by components tag found!</span><br><span class="line">        <span class="tag">&lt;/<span class="name">violation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span> <span class="attr">name</span>=<span class="string">&quot;/Users/qianyan/github/sonar/sonar-custom/src/test/resources/wrong-syntax.csm.xml&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">violation</span> <span class="attr">beginline</span>=<span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">endline</span>=<span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">begincolumn</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">endcolumn</span>=<span class="string">&quot;17&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">rule</span>=<span class="string">&quot;ComponentsMustNotBeFollowedByComponentsRule&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ruleset</span>=<span class="string">&quot;ExamplePmdRuleset&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">priority</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            Components tags followed by components tag found!</span><br><span class="line">        <span class="tag">&lt;/<span class="name">violation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pmd</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="PMD报告转化为Sonar的Issue"><a href="#PMD报告转化为Sonar的Issue" class="headerlink" title="PMD报告转化为Sonar的Issue"></a>PMD报告转化为Sonar的Issue</h4><p>由于PMD是由Java编写的，所以我们可以在代码中调用PMD这个类<em>net.sourceforge.pmd.PMD</em>根据我们写好的PMD规则，来扫描Sonar指定的目录及其文件。最后，将PMD输出的XML格式的报告转化成Sonar能够理解的Issue。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(SensorContext context)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">reportFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(context.fileSystem().workDir(), <span class="string">&quot;report.xml&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">        runPMD(context, reportFile); <span class="comment">// 2</span></span><br><span class="line">        convertToIssues(context, doc(reportFile)); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>指定PMD输出文件的路径；</li>
<li>运行PMD，输出XML格式的报告到1指定的文件当中；</li>
<li>解析报告，并转化为Issue。</li>
</ol>
<p>下面我们一步步来解释对应的代码：</p>
<ul>
<li>runPMD<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runPMD</span><span class="params">(SensorContext context, File reportFile)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dir</span> <span class="operator">=</span> context.settings().getString(<span class="string">&quot;sonar.sources&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir);</span><br><span class="line">    String[] pmdArgs = &#123;</span><br><span class="line">            <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;xml&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-R&quot;</span>, <span class="string">&quot;custom-pmd-rules.xml&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-d&quot;</span>, dir,</span><br><span class="line">            <span class="string">&quot;-r&quot;</span>, reportFile.getAbsolutePath(),</span><br><span class="line">            <span class="string">&quot;-e&quot;</span>, context.settings().getString(<span class="string">&quot;sonar.sourceEncoding&quot;</span>),</span><br><span class="line">            <span class="string">&quot;-language&quot;</span>, <span class="string">&quot;xml&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-version&quot;</span>, <span class="string">&quot;1.0&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(getClass().getClassLoader());</span><br><span class="line">        PMD.run(pmdArgs);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们通过PMD这个类运行pmdArgs。这里值得注意的是自SonarQube 5.6之后，我们可以通过context.settings()来获取工程的配置了，而不像以前那样依赖注入Settings对象了。</li>
</ul>
<p>至于<code> Thread.currentThread().setContextClassLoader(getClass().getClassLoader());</code>这步操作和Sonar使用独立的classLoader加载自己的类有关。</p>
<ul>
<li>convertToIssues<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">convertToIssues</span><span class="params">(SensorContext context, Document doc)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getRootElement();</span><br><span class="line">    <span class="keyword">final</span> List&lt;Element&gt; files = root.elements(<span class="string">&quot;file&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Element file : files) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;Element&gt; violations = file.elements(<span class="string">&quot;violation&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> file.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">FileSystem</span> <span class="variable">fs</span> <span class="operator">=</span> context.fileSystem();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InputFile</span> <span class="variable">inputFile</span> <span class="operator">=</span> fs.inputFile(fs.predicates().hasAbsolutePath(filePath));</span><br><span class="line">        <span class="keyword">if</span> (inputFile == <span class="literal">null</span>) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;fs predicates that there is no &#123;&#125;&quot;</span>, filePath);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Element violation : violations) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">rule</span> <span class="operator">=</span> violation.attributeValue(<span class="string">&quot;rule&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">beginLine</span> <span class="operator">=</span> Integer.parseInt(violation.attributeValue(<span class="string">&quot;beginline&quot;</span>));</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">endLine</span> <span class="operator">=</span> Integer.parseInt(violation.attributeValue(<span class="string">&quot;endline&quot;</span>));</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">beginColumn</span> <span class="operator">=</span> Integer.parseInt(violation.attributeValue(<span class="string">&quot;begincolumn&quot;</span>));</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">endColumn</span> <span class="operator">=</span> Integer.parseInt(violation.attributeValue(<span class="string">&quot;endcolumn&quot;</span>));</span><br><span class="line">            <span class="keyword">final</span> <span class="type">NewIssue</span> <span class="variable">newIssue</span> <span class="operator">=</span> context.newIssue()</span><br><span class="line">                    .forRule(RuleKey.of(CustomRulesDefinition.REPOSITORY_KEY, rule));</span><br><span class="line">            <span class="keyword">final</span> <span class="type">NewIssueLocation</span> <span class="variable">newIssueLocation</span> <span class="operator">=</span> newIssue</span><br><span class="line">                    .newLocation()</span><br><span class="line">                    .on(inputFile)</span><br><span class="line">                    .at(inputFile.newRange(beginLine, beginColumn, endLine, endColumn))</span><br><span class="line">                    .message(violation.getText());</span><br><span class="line">            newIssue.at(newIssueLocation).save();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里主要是对PMD生成XML报告的解析和转换。比较需要关注是这块代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">InputFile</span> <span class="variable">inputFile</span> <span class="operator">=</span> fs.inputFile(fs.predicates().hasAbsolutePath(filePath));</span><br><span class="line"><span class="keyword">if</span> (inputFile == <span class="literal">null</span>) &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;fs predicates that there is no &#123;&#125;&quot;</span>, filePath);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
InputFile这是Sonar定义的合法的待扫描文件。举个例子：我们定义了一门基于XML的DSL，其文件的后缀是<em>csm.xml</em>，那么合法的待扫描文件就只能是这个后缀的文件了。像上述PMD输出的那份报告中出现的<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">file</span> <span class="attr">name</span>=<span class="string">&quot;/Users/qianyan/github/sonar/sonar-custom/src/test/resources/wrong-syntax-but-not-csm.xml&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
就是不合法的。这个文件是以xml作为后缀的，PMD肯定可以扫描它，但是对于Sonar而言，它并不是InputFile（如果不作处理，就会返回null），所以我们需要在转换为Issue之前剔除掉。</li>
</ul>
<p>最后，不要忘记保存，<code>newIssue.at(newIssueLocation).save();</code>。</p>
<p>Issue呈现在UI上，是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-87d84e5cc8a49c37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Issue"></p>
<h3 id="第八步-注册所有组件"><a href="#第八步-注册所有组件" class="headerlink" title="第八步 注册所有组件"></a>第八步 注册所有组件</h3><p>现在所有的组件已经就绪，是时候将这些组件注册进插件当中了。还记得第一步我们创建的<em>CustomPlugin.java</em>? 所有上述组件，包括Language、Rules、Profiles以及Sensor都得在这个类中进行注册。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lambeta;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.sonar.api.Plugin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomPlugin</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">define</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        context.addExtension(CustomLanguage.class)</span><br><span class="line">                .addExtension(CustomRulesDefinition.class)</span><br><span class="line">                .addExtension(CustomProfileDefinition.class)</span><br><span class="line">                .addExtension(CustomSensor.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，这个插件算是写完了。那么接下来的问题就是如何运行它？</p>
<h2 id="使用插件扫描工程"><a href="#使用插件扫描工程" class="headerlink" title="使用插件扫描工程"></a>使用插件扫描工程</h2><h3 id="下载sonarqube-docker镜像"><a href="#下载sonarqube-docker镜像" class="headerlink" title="下载sonarqube docker镜像"></a>下载sonarqube docker镜像</h3><p>最易于调试的地方莫过于本地了。如果机器是Mac，建议使用Kitematic这个Docker的客户端下载sonarqube的官方镜像，同时将映射的Port定在9000端口上，启动该镜像的容器实例。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-2e1f14fff13e1fd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sonarqube docker"></p>
<h3 id="构建和Copy插件包"><a href="#构建和Copy插件包" class="headerlink" title="构建和Copy插件包"></a>构建和Copy插件包</h3><p>在插件的工程根目录下，运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p>然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp target/sonar-custom-1.0-SNAPSHOT.jar /Users/your-name/Documents/Kitematic/sonarqube/opt/sonarqube/extensions/plugins</span><br></pre></td></tr></table></figure>
<p>如果plugins目录不存在，可以手动创建。执行完命令之后，重启容器。</p>
<h3 id="安装Maven的sonar插件"><a href="#安装Maven的sonar插件" class="headerlink" title="安装Maven的sonar插件"></a>安装Maven的sonar插件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- settings.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interactiveMode</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">usePluginRegistry</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">offline</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.sonarsource.scanner.maven<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- Optional URL to server. Default value is http://localhost:9000 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sonar.host.url</span>&gt;</span></span><br><span class="line">                  http://192.168.99.100:9000</span><br><span class="line">                <span class="tag">&lt;/<span class="name">sonar.host.url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxies</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将这个settings.xml的文件放到~&#x2F;.m2下。</p>
<h3 id="运行Maven-sonar-sonar"><a href="#运行Maven-sonar-sonar" class="headerlink" title="运行Maven sonar:sonar"></a>运行Maven sonar:sonar</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn sonar:sonar -Dsonar.sources=src/test/resources/ -Dsonar.language=custom-key -X</span><br></pre></td></tr></table></figure>
<p><em>src&#x2F;test&#x2F;resources</em>目录展开如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/test/resources</span><br><span class="line">├── right-syntax.csm.xml</span><br><span class="line">├── wrong-syntax-but-not-csm.xml</span><br><span class="line">└── wrong-syntax.csm.xml</span><br></pre></td></tr></table></figure>
<p>然后，根据输出提示，访问<br><a href="http://192.168.99.100:9000/dashboard/index/com.lambeta:sonar-custom">http://192.168.99.100:9000/dashboard/index/com.lambeta:sonar-custom</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://upload-images.jianshu.io/upload_images/217988-136f034d165b9c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Sonar Plugin"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-fd2a3f30fc23d31d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Plugin implements details"></p>
<p>[1] <a href="http://docs.sonarqube.org/display/DEV/Developing+a+Plugin">官方教程</a><br>[2] <a href="https://deors.wordpress.com/2014/03/20/sonarqube-plugins-1/">博客</a><br>[3] <a href="https://github.com/SonarSource/sonar-examples/tree/master/plugins/sonar-example-plugin">官方样例</a><br>[4] <a href="https://github.com/qianyan/sonar-custom-plugin">本文样例</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Reading and Writing Files</title>
    <url>/2016/09/04/Reading-and-Writing-Files/</url>
    <content><![CDATA[<h2 id="读取和写入文件"><a href="#读取和写入文件" class="headerlink" title="读取和写入文件"></a>读取和写入文件</h2><p>数据一般都是存储在纯文本文件当中，存储的形式多种多样。本文，我会介绍如何在Clojure中读取和写入这些数据。</p>
<h3 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1. 打开文件"></a>1. 打开文件</h3><p>新建文件<em>hello.txt</em>，放到<em>resources</em>目录，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world!</span><br><span class="line">hello lambeta!</span><br><span class="line">hello life!</span><br></pre></td></tr></table></figure>
<p>新建<em>4io.clj</em>，输入程序：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">ns</span></span> the-way-to-clojure.4io</span><br><span class="line">  (<span class="symbol">:require</span> [clojure.java.io <span class="symbol">:as</span> io]</span><br><span class="line">            [clojure.string <span class="symbol">:as</span> str]))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">def</span> <span class="title">data-file</span> (<span class="name">io/resource</span> <span class="string">&quot;hello.txt&quot;</span>))</span><br><span class="line">(<span class="name"><span class="built_in">slurp</span></span> data-file) </span><br></pre></td></tr></table></figure>
<p>运行程序，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;hello world! \nhello lambeta!\nhello life!\n&quot;</span><br></pre></td></tr></table></figure>
<h4 id="读取所有行"><a href="#读取所有行" class="headerlink" title="读取所有行"></a>读取所有行</h4><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">line-seq</span></span> (<span class="name">io/reader</span> data-file))</span><br><span class="line"><span class="comment">;;=&gt; (&quot;hello world!&quot; &quot;hello lambeta!&quot; &quot;hello life!&quot;)</span></span><br></pre></td></tr></table></figure>
<h4 id="with-open宏"><a href="#with-open宏" class="headerlink" title="with-open宏"></a>with-open宏</h4><p>with-open宏用于自动关闭打开的文件。</p>
<p>1.1 读取一行，如下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">when-let</span></span> [line (<span class="name">.readLine</span> rdr)]</span><br><span class="line">    (<span class="name">println</span> line)))</span><br></pre></td></tr></table></figure>

<p>1.2 读取多行，如下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="comment">;;; read multiple lines</span></span><br><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">loop</span></span> [line (<span class="name">.readLine</span> rdr)]</span><br><span class="line">    (<span class="name"><span class="built_in">when</span></span> line</span><br><span class="line">      (<span class="name">println</span> line)</span><br><span class="line">      (<span class="name"><span class="built_in">recur</span></span> (<span class="name">.readLine</span> rdr)))))</span><br></pre></td></tr></table></figure>

<h3 id="2-读取文件的技巧"><a href="#2-读取文件的技巧" class="headerlink" title="2. 读取文件的技巧"></a>2. 读取文件的技巧</h3><p>想想读取文件可能有哪些场景？</p>
<ul>
<li>读取整个文本</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">slurp</span></span> data-file)</span><br></pre></td></tr></table></figure>

<ul>
<li>读取一行</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">first</span></span> (<span class="name"><span class="built_in">line-seq</span></span> rdr)))</span><br><span class="line"><span class="comment">;; 或者</span></span><br><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">take</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr)))</span><br><span class="line">-&gt; <span class="string">&quot;hello world!&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>读取前n行</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">doall</span></span> (<span class="name"><span class="built_in">take</span></span> <span class="number">2</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))))</span><br><span class="line">-&gt; (<span class="string">&quot;hello world!&quot;</span> <span class="string">&quot;hello lambeta!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里使用了<code>(doall )</code>方法，如果不用这个方法，在repl中求值的时候会表达式导致抛出<code>Unhandled java.io.IOException  Stream closed</code>异常。究其缘由是<code>(take 2 )</code>返回了一个惰性序列，详细解释参见文末备注。</p>
<ul>
<li>读取前n个字符</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">with-open [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">  (<span class="name"><span class="built_in">loop</span></span> [ch (<span class="name">.read</span> rdr) len <span class="number">20</span>]</span><br><span class="line">    (<span class="name"><span class="built_in">when-not</span></span> (<span class="name"><span class="built_in">or</span></span> (<span class="name"><span class="built_in">=</span></span> <span class="number">-1</span> ch) (<span class="name"><span class="built_in">zero?</span></span> len))</span><br><span class="line">      (<span class="name">println</span> (<span class="name">char</span> ch))</span><br><span class="line">      (<span class="name"><span class="built_in">recur</span></span> (<span class="name">.read</span> rdr) (<span class="name"><span class="built_in">dec</span></span> len)))))</span><br><span class="line">| h</span><br><span class="line">| e</span><br><span class="line">| ...</span><br><span class="line">-&gt; <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<ul>
<li>跳过特定的行</li>
</ul>
<p>在<em>resources</em>目录下，新建<em>records.txt</em>，内容即代码注释所示：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">read-records</span> [input-file]</span><br><span class="line">  <span class="string">&quot;Coloured fox fur production, HOPEDALE, Labrador, 1834-1842</span></span><br><span class="line"><span class="string">  #Source: C. Elton (1942) \&quot;Voles, Mice and Lemmings\&quot;, Oxford Univ. Press</span></span><br><span class="line"><span class="string">  #Table 17, p.265--266</span></span><br><span class="line"><span class="string">  22</span></span><br><span class="line"><span class="string">  29</span></span><br><span class="line"><span class="string">  2</span></span><br><span class="line"><span class="string">  16</span></span><br><span class="line"><span class="string">  12</span></span><br><span class="line"><span class="string">  35</span></span><br><span class="line"><span class="string">  8</span></span><br><span class="line"><span class="string">  83</span></span><br><span class="line"><span class="string">  166&quot;</span></span><br><span class="line">  (<span class="name"><span class="built_in">letfn</span></span> [(<span class="name">skip</span> [lines]</span><br><span class="line">            (<span class="name"><span class="built_in">next</span></span> lines))]</span><br><span class="line">         (<span class="name"><span class="built_in">with-open</span></span> [rdr ((<span class="name"><span class="built_in">comp</span></span> io/reader io/resource) input-file)]</span><br><span class="line">           (<span class="name"><span class="built_in">-&gt;&gt;</span></span></span><br><span class="line">            (<span class="name"><span class="built_in">for</span></span> [line (<span class="name">skip</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))</span><br><span class="line">                  <span class="symbol">:when</span> (<span class="name"><span class="built_in">not</span></span> (<span class="name">.startsWith</span> line <span class="string">&quot;#&quot;</span>))]</span><br><span class="line">              (<span class="name">read-string</span> line))</span><br><span class="line">            (<span class="name"><span class="built_in">apply</span></span> +)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">read-records</span> <span class="string">&quot;records.txt&quot;</span>)</span><br><span class="line">-&gt; <span class="number">373</span></span><br></pre></td></tr></table></figure>

<p>我们在<code>read-records</code>内部新建一个<code>skip</code>方法，顾名思义，跳过第一个元素，然后返回后面的列表。这里旨在跳过文本的声明头。<code>:when (not ...)</code>过滤了文本的注释部分（以#开头的行），并使用<code>read-string</code>转换字符串到数字类型，<code>(for )</code>求值完成后返回只包含数字的列表。最后，我们对列表做了一次累加操作。</p>
<p>我们试试非过滤而是跳过（删除）以”#”开头行的方式获取数字列表，这样更符合要求。重写<em>with-open</em>部分，如下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr ((<span class="name"><span class="built_in">comp</span></span> io/reader io/resource) input-file)]</span><br><span class="line">      (<span class="name"><span class="built_in">apply</span></span> +</span><br><span class="line">             (<span class="name"><span class="built_in">let</span></span> [lines (<span class="name">skip</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))]</span><br><span class="line">               (<span class="name"><span class="built_in">-&gt;&gt;</span></span> lines</span><br><span class="line">                    (<span class="name"><span class="built_in">remove</span></span> (<span class="name">set</span> (<span class="name"><span class="built_in">for</span></span> [line lines <span class="symbol">:while</span> (<span class="name">.startsWith</span> line <span class="string">&quot;#&quot;</span>)] line)))</span><br><span class="line">                    (<span class="name"><span class="built_in">map</span></span> read-string)))))</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr ((<span class="name"><span class="built_in">comp</span></span> io/reader io/resource) input-file)]</span><br><span class="line">      (<span class="name"><span class="built_in">apply</span></span> +</span><br><span class="line">             (<span class="name"><span class="built_in">let</span></span> [lines (<span class="name">skip</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))]</span><br><span class="line">               (<span class="name"><span class="built_in">-&gt;&gt;</span></span> lines</span><br><span class="line">                    (<span class="name"><span class="built_in">drop</span></span> (<span class="name"><span class="built_in">count</span></span> (<span class="name"><span class="built_in">for</span></span> [line lines <span class="symbol">:while</span> (<span class="name">.startsWith</span> line <span class="string">&quot;#&quot;</span>)] line)))</span><br><span class="line">                    (<span class="name"><span class="built_in">map</span></span> read-string)))))</span><br></pre></td></tr></table></figure>
<h3 id="3-读取网络文件"><a href="#3-读取网络文件" class="headerlink" title="3. 读取网络文件"></a>3. 读取网络文件</h3><p>通过slurp读取字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(slurp &quot;http://robjhyndman.com/tsdldata/ecology1/hopedale.dat&quot; :encoding &quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line">-&gt; &quot;Coloured fox fur production, HOPEDALE, Labrador,, 1834-1925\n#Source: C. Elton (1942) \&quot;Voles, Mice and Lemmings\&quot;, Oxford Univ. Press\n#Table 17, p.265--266\n      22   \n...</span><br></pre></td></tr></table></figure>
<p>注意，这个网页上的数据是用UTF-8编码的，所以解码读取时，也应该使用UTF-8。</p>
<h3 id="4-写入文件"><a href="#4-写入文件" class="headerlink" title="4. 写入文件"></a>4. 写入文件</h3><ul>
<li>使用spit方法</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">spit</span> <span class="string">&quot;world.txt&quot;</span> <span class="string">&quot;Hello, lambeta!&quot;</span> <span class="symbol">:append</span> <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>运行程序之后，项目的根目录下会生成<em>world.txt</em>文件，内容是<em>Hello, lambeta</em>。spit方法其实就是向Java的BufferedWriter中写入内容。</p>
<ul>
<li>使用clojure.java.io&#x2F;writer</li>
</ul>
<p>我们在项目的根目录新建<em>numbers.txt</em>，内容是多行的数字对，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.3 2.7</span><br><span class="line">10000 1</span><br><span class="line">-1 1</span><br></pre></td></tr></table></figure>

<p>我们需要把每行两个数字，和它们相加的结果写入到<em>sum-of_numbers.txt</em>文件中。也就是注释中的描述。</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">sum-number-pairs</span> [input-file output-file]</span><br><span class="line">  <span class="string">&quot;Read the data from input-file, which contains two floats per line</span></span><br><span class="line"><span class="string">   separated by a space.  Open file named output-file and, for each line in</span></span><br><span class="line"><span class="string">   input-file, write a line to the output file that contains the two floats</span></span><br><span class="line"><span class="string">   from the corresponding line of input-file plus a space and the sum of the</span></span><br><span class="line"><span class="string">   two floats.&quot;</span></span><br><span class="line">(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> input-file) wtr (<span class="name">io/writer</span> output-file <span class="symbol">:append</span> <span class="literal">true</span>)]</span><br><span class="line">    (<span class="name"><span class="built_in">loop</span></span> [line (<span class="name">.readLine</span> rdr)]</span><br><span class="line">      (<span class="name"><span class="built_in">when</span></span> line</span><br><span class="line">        (<span class="name"><span class="built_in">let</span></span> [pair (<span class="name"><span class="built_in">map</span></span> read-string</span><br><span class="line">                        (<span class="name">str/split</span> line <span class="regex">#&quot;\s&quot;</span>))</span><br><span class="line">              first (<span class="name"><span class="built_in">first</span></span> pair)</span><br><span class="line">              second (<span class="name"><span class="built_in">second</span></span> pair)</span><br><span class="line">              sum (<span class="name"><span class="built_in">+</span></span> first second)]</span><br><span class="line">          (<span class="name">.write</span> wtr (<span class="name"><span class="built_in">str</span></span> first <span class="string">&quot; &quot;</span> second <span class="string">&quot; &quot;</span> sum <span class="string">&quot;\n&quot;</span>)))</span><br><span class="line">        (<span class="name"><span class="built_in">recur</span></span> (<span class="name">.readLine</span> rdr))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">sum-number-pairs</span> <span class="string">&quot;numbers.txt&quot;</span> <span class="string">&quot;sum-of-numbers.txt&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>with-open同时打开了一个用于读取、名为<em>input-file</em>的文件以及一个用于写入、名为<em>output-file</em>的文件，写入方式是追加<code>:append true</code>。随后循环读取<em>input-file</em>中的每行内容。若<em>line</em>不是nil（即存在），那么用空格分隔这行内容，得到一个数组，如：”1.3 2.7” -&gt; [“1.3” “2.7”]。此时数组的元素类型还不是数字（Number），我们使用<code>(map read-string )</code>将元素转换为对应的数字类型，如：[“1.3” “2.7”] -&gt; [1.3 2.7]。之后，分别提取数组的第一、二个元素以及两者的和。最后，写入到wtr中。</p>
<hr>
<p><strong>注意</strong>：程序中的<em>str&#x2F;split</em>是通过<code>(:require [clojure.string :as str])</code>方式引入<em>str</em>命名空间的。</p>
<hr>
<p>运行程序之后，<em>sum-of-numbers.txt</em>中的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.3 2.7 4.0</span><br><span class="line">10000 1 10001</span><br><span class="line">-1 1 0</span><br></pre></td></tr></table></figure>

<h3 id="5-多行记录"><a href="#5-多行记录" class="headerlink" title="5. 多行记录"></a>5. 多行记录</h3><h4 id="5-1-有结束标识"><a href="#5-1-有结束标识" class="headerlink" title="5.1 有结束标识"></a>5.1 有结束标识</h4><p>有时候，记录并不是以一行一行的方式存储在文件当中的，而是以多行数据描述一条记录。比如下面的蛋白质数据：<br><strong>清单 5.1</strong> <em>multimol.pdb</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMPND      AMMONIA</span><br><span class="line">ATOM      1  N  0.257  -0.363   0.000</span><br><span class="line">ATOM      2  H  0.257   0.727   0.000</span><br><span class="line">ATOM      3  H  0.771  -0.727   0.890</span><br><span class="line">ATOM      4  H  0.771  -0.727  -0.890</span><br><span class="line">END</span><br><span class="line">COMPND      METHANOL</span><br><span class="line">ATOM      1  C  -0.748  -0.015   0.024</span><br><span class="line">ATOM      2  O  0.558   0.420  -0.278</span><br><span class="line">ATOM      3  H  -1.293  -0.202  -0.901</span><br><span class="line">ATOM      4  H  -1.263   0.754   0.600</span><br><span class="line">ATOM      5  H  -0.699  -0.934   0.609</span><br><span class="line">ATOM      6  H  0.716   1.404   0.137</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>第一行描述的是分子的名字，接下来到END为止的每行代表原子的ID、类型以及在分子中分布的[x y z]坐标。<br>我们需要一个函数，将数据读取出来并且以规定的格式输出，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((&quot;AMMONIA&quot; </span><br><span class="line">    (&quot;N&quot; &quot;0.257&quot; &quot;-0.363&quot; &quot;0.000&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;0.257&quot; &quot;0.727&quot; &quot;0.000&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;0.771&quot; &quot;-0.727&quot; &quot;0.890&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;0.771&quot; &quot;-0.727&quot; &quot;-0.890&quot;)) </span><br><span class="line"> (&quot;METHANOL&quot; </span><br><span class="line">    (&quot;C&quot; &quot;-0.748&quot; &quot;-0.015&quot; &quot;0.024&quot;)</span><br><span class="line">    (&quot;O&quot; &quot;0.558&quot; &quot;0.420&quot; &quot;-0.278&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;-1.293&quot; &quot;-0.202&quot; &quot;-0.901&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;-1.263&quot; &quot;0.754&quot; &quot;0.600&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;-0.699&quot; &quot;-0.934&quot; &quot;0.609&quot;)</span><br><span class="line">    (&quot;H&quot; &quot;0.716&quot; &quot;1.404&quot; &quot;0.137&quot;)))</span><br></pre></td></tr></table></figure>
<p>也就是说，我们需要把每条记录读入单个列表中，每个列表由分子的名称和多个<code>(Type X Y Z)</code>的原子列表组成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn read-all-molecules [input-file]</span><br><span class="line">  (map (fn [molecules]</span><br><span class="line">         (let [[_ name] (str/split (first molecules) #&quot;\s+&quot;)</span><br><span class="line">               atoms (map (comp #(drop 2 %) #(str/split % #&quot;\s+&quot;))</span><br><span class="line">                          (rest molecules))]</span><br><span class="line">           (concat [name] atoms)))</span><br><span class="line">       ;; 分割成多条记录</span><br><span class="line">       (remove #(= % [&quot;END&quot;]) </span><br><span class="line">               (partition-by #(= % &quot;END&quot;) (line-seq (io/reader input-file))))))</span><br><span class="line"></span><br><span class="line">(read-all-molecules &quot;multimol.pdb&quot;)</span><br></pre></td></tr></table></figure>
<p><code>(remove #(= % [&quot;END&quot;]) (partition-by #(= % &quot;END&quot;) (line-seq (io/reader input-file))))</code>这行代码做的事情就是把文件读取出来变成一个<code>lazy-seq</code>，然后使用<code>parttition-by</code>以<em>END</em>进行分组，最后使用<code>remove</code>方法剔除掉*[“END”]*这样的分组，得到如下中间结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((&quot;COMPND      AMMONIA&quot; </span><br><span class="line">  &quot;ATOM      1  N  0.257  -0.363   0.000&quot;</span><br><span class="line">  &quot;ATOM      2  H  0.257   0.727   0.000&quot;</span><br><span class="line">  &quot;ATOM      3  H  0.771  -0.727   0.890&quot;</span><br><span class="line">  &quot;ATOM      4  H  0.771  -0.727  -0.890&quot;) </span><br><span class="line"> (&quot;COMPND      METHANOL&quot; </span><br><span class="line">  &quot;ATOM      1  C  -0.748  -0.015   0.024&quot;</span><br><span class="line">  &quot;ATOM      2  O  0.558   0.420  -0.278&quot;</span><br><span class="line">  &quot;ATOM      3  H  -1.293  -0.202  -0.901&quot; </span><br><span class="line">  &quot;ATOM      4  H  -1.263   0.754   0.600&quot;</span><br><span class="line">  &quot;ATOM      5  H  -0.699  -0.934   0.609&quot; </span><br><span class="line">  &quot;ATOM      6  H  0.716   1.404   0.137&quot;))</span><br></pre></td></tr></table></figure>
<p>这样离我们的目标已经很近了。观察上述结果，不难发现分子的名称处于列表的第一个<code>(first )</code>，而原子列表可以使用<code>(rest )</code>获取。然后，借助<code>(map )</code>函数遍历所有的记录。</p>
<p><code>(let )</code>中的第一个binding是<code>[_ name] (str/split (first molecules) #&quot;\s+&quot;)</code>，首先用<code>(split )</code>函数分割，再使用了解构提取出分子的名称；第二个binding是原子列表的提取，我们在<code>(split )</code>的基础之上，使用<code>(drop 2 )</code>函数剔除了不用的字段，如：ATOM和1。最后使用<code>(concat )</code>函数将名称和原子列表的列表拼接到一起。</p>
<h4 id="5-2-无结束标识"><a href="#5-2-无结束标识" class="headerlink" title="5.2 无结束标识"></a>5.2 无结束标识</h4><p>5.1中的记录项通过<em>END</em>标识分隔，但是事实上这是一个多余的字段，记录项可以更简练，如下：<br><strong>清单 5.2</strong> <em>multimol-without-end-marker.pdb</em></p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">COMPND      AMMONIA</span><br><span class="line">ATOM      <span class="number">1</span>  N  <span class="number">0.257</span>  <span class="number">-0.363</span>   <span class="number">0.000</span></span><br><span class="line">ATOM      <span class="number">2</span>  H  <span class="number">0.257</span>   <span class="number">0.727</span>   <span class="number">0.000</span></span><br><span class="line">ATOM      <span class="number">3</span>  H  <span class="number">0.771</span>  <span class="number">-0.727</span>   <span class="number">0.890</span></span><br><span class="line">ATOM      <span class="number">4</span>  H  <span class="number">0.771</span>  <span class="number">-0.727</span>  <span class="number">-0.890</span></span><br><span class="line">COMPND      METHANOL</span><br><span class="line">ATOM      <span class="number">1</span>  C  <span class="number">-0.748</span>  <span class="number">-0.015</span>   <span class="number">0.024</span></span><br><span class="line">ATOM      <span class="number">2</span>  O  <span class="number">0.558</span>   <span class="number">0.420</span>  <span class="number">-0.278</span></span><br><span class="line">ATOM      <span class="number">3</span>  H  <span class="number">-1.293</span>  <span class="number">-0.202</span>  <span class="number">-0.901</span></span><br><span class="line">ATOM      <span class="number">4</span>  H  <span class="number">-1.263</span>   <span class="number">0.754</span>   <span class="number">0.600</span></span><br><span class="line">ATOM      <span class="number">5</span>  H  <span class="number">-0.699</span>  <span class="number">-0.934</span>   <span class="number">0.609</span></span><br><span class="line">ATOM      <span class="number">6</span>  H  <span class="number">0.716</span>   <span class="number">1.404</span>   <span class="number">0.137</span></span><br></pre></td></tr></table></figure>
<p>现在的问题变成了没有<em>END</em>标识符，如何进行分组？观察不难发现以<em>COMPND</em>开头的数据行可以作为记录的分隔符。<br>使用<code>(partition-by #(.startsWith % &quot;COMPND&quot;) (line-seq (io/reader input-file)))</code>进行分组，得到的结果如下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">((<span class="string">&quot;COMPND      AMMONIA&quot;</span>) </span><br><span class="line">  (<span class="string">&quot;ATOM      1  N  0.257  -0.363   0.000&quot;</span> </span><br><span class="line">   <span class="string">&quot;ATOM      2  H  0.257   0.727   0.000&quot;</span> </span><br><span class="line">   <span class="string">&quot;ATOM      3  H  0.771  -0.727   0.890&quot;</span></span><br><span class="line">   <span class="string">&quot;ATOM      4  H  0.771  -0.727  -0.890&quot;</span>) </span><br><span class="line"> (<span class="string">&quot;COMPND      METHANOL&quot;</span>) </span><br><span class="line">  (<span class="string">&quot;ATOM      1  C  -0.748  -0.015   0.024&quot;</span> </span><br><span class="line">   <span class="string">&quot;ATOM      2  O  0.558   0.420  -0.278&quot;</span> </span><br><span class="line">   <span class="string">&quot;ATOM      3  H  -1.293  -0.202  -0.901&quot;</span></span><br><span class="line">   <span class="string">&quot;ATOM      4  H  -1.263   0.754   0.600&quot;</span></span><br><span class="line">   <span class="string">&quot;ATOM      5  H  -0.699  -0.934   0.609&quot;</span></span><br><span class="line">   <span class="string">&quot;ATOM      6  H  0.716   1.404   0.137&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>此时，我们对比5.1中中间结果，会发现它们极为相似。也就是说，我们稍加转换就能让两者一致，而一致的好处就是可以复用原来<code>(map )</code>中的逻辑。</p>
<p>稍稍修改原来的分组逻辑，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(map (fn [[name atoms]] (concat name atoms))</span><br><span class="line">       (partition 2</span><br><span class="line">                  (partition-by</span><br><span class="line">                   #(.startsWith % &quot;COMPND&quot;)</span><br><span class="line">                   (line-seq (io/reader input-file)))))</span><br></pre></td></tr></table></figure>
<p>我们先使用<code>(partition 2 )</code>将第一步得到的列表每隔两个元素划为一组，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(((&quot;COMPND      AMMONIA&quot;) </span><br><span class="line">  (&quot;ATOM      1  N  0.257  -0.363   0.000&quot; </span><br><span class="line">   &quot;ATOM      2  H  0.257   0.727   0.000&quot; </span><br><span class="line">   &quot;ATOM      3  H  0.771  -0.727   0.890&quot;</span><br><span class="line">   &quot;ATOM      4  H  0.771  -0.727  -0.890&quot;)) ; 多出一对括号</span><br><span class="line"> ((&quot;COMPND      METHANOL&quot;) </span><br><span class="line">  (&quot;ATOM      1  C  -0.748  -0.015   0.024&quot; </span><br><span class="line">   &quot;ATOM      2  O  0.558   0.420  -0.278&quot; </span><br><span class="line">   &quot;ATOM      3  H  -1.293  -0.202  -0.901&quot;</span><br><span class="line">   &quot;ATOM      4  H  -1.263   0.754   0.600&quot;</span><br><span class="line">   &quot;ATOM      5  H  -0.699  -0.934   0.609&quot;</span><br><span class="line">   &quot;ATOM      6  H  0.716   1.404   0.137&quot;)))</span><br></pre></td></tr></table></figure>
<p>然后使用<code>(map (fn [[name atoms]] ...)</code>将每组里面的两个列表合成为一个列表，这样就得到和原来5.1一模一样的中间结果。</p>
<p>接下来，我们把转换的逻辑从<code>(read-all-molecules )</code>中提取出来，以便复用。改造如下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">read-all-molecules</span> [f input-file]</span><br><span class="line">  (<span class="name"><span class="built_in">let</span></span> [data (<span class="name">f</span> input-file)]</span><br><span class="line">    (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">fn</span></span> [molecules]</span><br><span class="line">           (<span class="name"><span class="built_in">let</span></span> [[_ name] (<span class="name">str/split</span> (<span class="name"><span class="built_in">first</span></span> molecules) <span class="regex">#&quot;\s+&quot;</span>)</span><br><span class="line">                 atoms (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">comp</span></span> #(<span class="name"><span class="built_in">drop</span></span> <span class="number">2</span> %) #(<span class="name">str/split</span> % <span class="regex">#&quot;\s+&quot;</span>))</span><br><span class="line">                            (<span class="name"><span class="built_in">rest</span></span> molecules))]</span><br><span class="line">             (<span class="name"><span class="built_in">concat</span></span> [name] atoms))) data)))</span><br></pre></td></tr></table></figure>
<p>定义转换逻辑，如下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">file-without-markers-&gt;multi-records</span> [input-file]</span><br><span class="line">  (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">fn</span></span> [[name atoms]] (<span class="name"><span class="built_in">concat</span></span> name atoms))</span><br><span class="line">       (<span class="name"><span class="built_in">partition</span></span> <span class="number">2</span></span><br><span class="line">                  (<span class="name">partition-by</span></span><br><span class="line">                   #(<span class="name">.startsWith</span> % <span class="string">&quot;COMPND&quot;</span>)</span><br><span class="line">                   (<span class="name"><span class="built_in">line-seq</span></span> (<span class="name">io/reader</span> input-file))))))</span><br></pre></td></tr></table></figure>
<p>最后，我们来调用的改造之后的方法：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">read-all-molecules</span> </span><br><span class="line">        file-without-markers-&gt;multi-records <span class="string">&quot;multimol-without-end-marker.pdb&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>此时，5.1中的转换逻辑也可以提取出一个函数：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">file-&gt;multi-records</span></span><br><span class="line">  (<span class="name"><span class="built_in">remove</span></span> #(<span class="name"><span class="built_in">=</span></span> % [<span class="string">&quot;END&quot;</span>]) </span><br><span class="line">               (<span class="name">partition-by</span> #(<span class="name"><span class="built_in">=</span></span> % <span class="string">&quot;END&quot;</span>) (<span class="name"><span class="built_in">line-seq</span></span> (<span class="name">io/reader</span> input-file)))))</span><br></pre></td></tr></table></figure>
<p>原来的程序就重构成了如下的模样：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">read-all-molecules</span> file-&gt;multi-records <span class="string">&quot;multimol.pdb&quot;</span>)</span><br></pre></td></tr></table></figure>


<hr>
<p><strong>备注</strong></p>
<p>为了清楚定位这个问题，我们需要提前了解两个知识点</p>
<ol>
<li>什么是惰性序列？</li>
<li>惰性序列在repl中什么时候变现（realizes）？</li>
</ol>
<p>惰性序列是用<code>(lazy-seq [&amp; body] )</code>宏创建出来的。<code>lazy-seq</code>仅在需要的时候才会去调用它的body。<br>当repl尝试<code>pretty-print</code>惰性序列的结果时，才会进行变现操作。</p>
<p>有了上面的知识点，我们来考察<code>with-open</code>和<code>(take 2 (line-seq ))</code>的关系。<code>with-open</code>是宏，我们使用<code>clojure.walk/macroexpand-all</code>展开下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">clojure.walk/macroexpand-all</span> </span><br><span class="line">    &#x27;(<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> data-file)]</span><br><span class="line">                      (<span class="name"><span class="built_in">take</span></span> <span class="number">2</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))))</span><br><span class="line">                      </span><br><span class="line">-&gt; (<span class="name">let*</span> [rdr (<span class="name">io/reader</span> data-file)] </span><br><span class="line">        (<span class="name"><span class="built_in">try</span></span> (<span class="name"><span class="built_in">do</span></span> </span><br><span class="line">                (<span class="name"><span class="built_in">take</span></span> <span class="number">2</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))) </span><br><span class="line">        (<span class="name">finally</span> (<span class="name"><span class="built_in">.</span></span> rdr clojure.core/close))))                      </span><br></pre></td></tr></table></figure>
<p>使用<code>(doc line-seq)</code>查看文档，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clojure.core/line-seq</span><br><span class="line"> [rdr]</span><br><span class="line">Added in 1.0</span><br><span class="line">  Returns the lines of text from rdr as a lazy sequence of strings.</span><br><span class="line">  rdr must implement java.io.BufferedReader.</span><br></pre></td></tr></table></figure>
<p>可以确认<code>line-seq</code>返回一个惰性的字符串序列。<br>再看看<code>(doc take)</code>的文档，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clojure.core/take</span><br><span class="line"> [n]</span><br><span class="line"> [n coll]</span><br><span class="line">Added in 1.0</span><br><span class="line">  Returns a lazy sequence of the first n items in coll, or all items if</span><br><span class="line">  there are fewer than n.  Returns a stateful transducer when</span><br><span class="line">  no collection is provided.</span><br></pre></td></tr></table></figure>
<p>所以<code>take</code>返回的也是一个惰性序列，那么<code>(do (take 2 (line-seq rdr)))</code>（等价于<code>(take 2 (line-seq rdr))</code>）整个返回的就是一个惰性序列。</p>
<p>当我们通过repl求值<code>with-open</code>时，它并没有真的变现<code>(take 2 (line-seq rdr))</code>，而是在运行完<code>try...finally</code>之后，直接返回这个惰性序列作为结果。此时，repl开始尝试pretty-print <code>(take 2 (line-seq rdr))</code>，变现发生，但是rdr已经被关闭了，所以抛出<em>Stream closed</em>异常。</p>
<p>到这里，解决了一大半问题，但是还有一个逻辑上解释不过去的点，就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(with-open [rdr (io/reader data-file)]</span><br><span class="line">  (take 1 (line-seq rdr)))</span><br></pre></td></tr></table></figure>
<p>当我们尝试<code>(take 1 )</code>时并不会抛出异常！也就是说<code>(take 1 )</code>和<code>(take 2 )</code>的行为不同，但是<code>(take )</code>明明都是返回惰性序列啊？</p>
<p>带着这个疑惑，看看<code>line-seq</code>的源代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(when-let [line (.readLine rdr)]</span><br><span class="line">    (cons line (lazy-seq (line-seq rdr)))))</span><br></pre></td></tr></table></figure>
<p>是不是有种豁然开朗的感觉？没有也没关系，我来解释一下。<br><code>line-seq</code>的<code>when-let</code>语句并没有包在<code>(lazy-seq )</code>（这点可以和<code>take</code>的源码比较）中，这说明<code>[line (.readline rdr)]</code>是需要立即求值的。也就是说，我们在求值<code>with-open</code>时，rdr中第一行的内容会被<code>(line-seq )</code>给抓住了。那么当<code>try...finally</code>运行结束之后，pretty-print变现惰性序列时，发现第一行根本不需要从rdr中读，当然就不会抛出异常了。</p>
<p>明确这几点之后，我们看看<code>(doall )</code>为何能解决惰性序列延迟求值的问题？<code>(doall )</code>其实强制变现了整个惰性序列（不断调用序列的<code>next</code>方法），所以并不会等到<code>with-open</code>求值完成之后才求值。</p>
<p>换个角度，我们知道之所以抛出异常，是因为repl对返回的惰性序列求值了。那么如果我们不在repl中求值，程序还会抛出异常吗？</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">ns</span></span> the-way-to-clojure.core</span><br><span class="line">  (<span class="symbol">:require</span> [clojure.java.io <span class="symbol">:as</span> io])</span><br><span class="line">  (<span class="symbol">:gen-class</span>))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">-main</span> [&amp; args]</span><br><span class="line">  (<span class="name"><span class="built_in">with-open</span></span> [rdr (<span class="name">io/reader</span> <span class="string">&quot;hello.txt&quot;</span>)]</span><br><span class="line">    (<span class="name"><span class="built_in">take</span></span> <span class="number">100</span> (<span class="name"><span class="built_in">line-seq</span></span> rdr))))</span><br></pre></td></tr></table></figure>
<p>接着，我们使用<code>lein run</code>来运行<code>main</code>方法。程序运行良好，因为根本没有人用到返回的惰性序列。</p>
<p>如果我们加一句打印语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn -main [&amp; args]</span><br><span class="line">  (println          ; 变现</span><br><span class="line">      (with-open [rdr (io/reader &quot;hello.txt&quot;)]</span><br><span class="line">        (take 100 (line-seq rdr)))))</span><br></pre></td></tr></table></figure>
<p>再用<code>lein run</code>跑一个<code>main</code>方法，异常又不期而遇了。因为此处的<code>println</code>等价于<code>repl</code>的<code>pretty print</code>。</p>
]]></content>
      <categories>
        <category>Clojure</category>
      </categories>
      <tags>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title>Leiningen Profile</title>
    <url>/2016/05/30/Leiningen-Profile/</url>
    <content><![CDATA[<h2 id="记忆用的Mindmap"><a href="#记忆用的Mindmap" class="headerlink" title="记忆用的Mindmap"></a>记忆用的Mindmap</h2><p><img src="/images/Leiningen-Profiles.png" alt="leingingen profiles"></p>
<h2 id="标准的leiningen的工程目录结构"><a href="#标准的leiningen的工程目录结构" class="headerlink" title="标准的leiningen的工程目录结构"></a>标准的leiningen的工程目录结构</h2><p>当我们使用<em>lein new your-project-name</em>之后，工程目录结构如下：</p>
<span id="more"></span>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGELOG.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── doc</span><br><span class="line">│   └── intro.md</span><br><span class="line">├── project.clj</span><br><span class="line">├── resources</span><br><span class="line">├── src</span><br><span class="line">│   └── playground</span><br><span class="line">│       └── core.clj</span><br><span class="line">└── test</span><br><span class="line">    └── playground</span><br><span class="line">        └── core_test.clj</span><br></pre></td></tr></table></figure>
<p>此处的project.clj就是这个工程的描述文件，不过内容是使用clojure编写的，展开如下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">defproject</span> playground <span class="string">&quot;0.1.0-SNAPSHOT&quot;</span></span><br><span class="line">  <span class="symbol">:description</span> <span class="string">&quot;FIXME: write description&quot;</span></span><br><span class="line">  <span class="symbol">:url</span> <span class="string">&quot;http://example.com/FIXME&quot;</span></span><br><span class="line">  <span class="symbol">:license</span> &#123;<span class="symbol">:name</span> <span class="string">&quot;Eclipse Public License&quot;</span></span><br><span class="line">            <span class="symbol">:url</span> <span class="string">&quot;http://www.eclipse.org/legal/epl-v10.html&quot;</span>&#125;</span><br><span class="line">  <span class="symbol">:dependencies</span> [[org.clojure/clojure <span class="string">&quot;1.8.0&quot;</span>]])</span><br></pre></td></tr></table></figure>
<p>此时还看不到profiles的影子，不过试想一下这样的场景：某些工具只是开发时需要，打包artifact却不应包含——写过Node.js的应该对package.json中devDependencies不陌生，其实是一个道理。只不过在project.clj中是这样定义的：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">defproject</span> playground <span class="string">&quot;0.1.0-SNAPSHOT&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="symbol">:profiles</span> &#123;<span class="symbol">:dev</span> &#123;<span class="symbol">:plugins</span> [[refactor-nrepl <span class="string">&quot;2.0.0-SNAPSHOT&quot;</span>]</span><br><span class="line">                           [cider/cider-nrepl <span class="string">&quot;0.10.0&quot;</span>]]&#125;</span><br><span class="line">           <span class="symbol">:provided</span> &#123;<span class="symbol">:dependencies</span> [[javax.servlet/servlet-api <span class="string">&quot;2.5&quot;</span>]]&#125;)</span><br></pre></td></tr></table></figure>
<p>因为我使用emacs编程，除了亲和编辑源码的<a href="https://github.com/clojure-emacs/clojure-mode">clojure-mode</a>，还使用了<a href="https://github.com/clojure-emacs/cider">cider</a>这个与Clojure进程交互的工具，而<a href="https://github.com/clojure-emacs/clj-refactor.el">clj-refactor.el</a>则是Clojure中重构的神器，所以在开发的时候，需要显式地依赖进来（不过自<a href="https://github.com/clojure-emacs/cider/releases/tag/v0.11.0">CIDER 0.11.0 (Bulgaria)</a>之后两者都自动引入了）。另外，写过servlet程序的人大概对于这个servlet-api很是熟悉，看到:provided想必也会会心一笑。</p>
<p>其实这里:dev和:provided是leiningen内置的两种profile，它们类型不同，功能也迥异。在继续深究之前，我们先想想profile应该具有的功能。</p>
<h2 id="Profile的功能"><a href="#Profile的功能" class="headerlink" title="Profile的功能"></a>Profile的功能</h2><p>Profile的主要功能和pom.xml以及package.json一致，描述当前工程的配置、为构建工具（leiningen）提供一套执行流程。具体来讲，包括项目的不同scope（compile&#x2F;test&#x2F;provided）的依赖、开发环境依赖、各种plugin的依赖，以及范围性质的依赖，比如:user，表明当前用户下所有的leinigen工程都会使用到该profile。</p>
<p>每个project（项目）当前<strong>可用</strong>的profiles，可以通过下面这条命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//under root of project playground</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lein show-profiles</span></span><br><span class="line">...</span><br><span class="line">base</span><br><span class="line">debug</span><br><span class="line">default</span><br><span class="line">dev</span><br><span class="line">leiningen/default</span><br><span class="line">leiningen/test</span><br><span class="line">offline</span><br><span class="line">repl</span><br><span class="line">uberjar</span><br><span class="line">update</span><br><span class="line">user</span><br></pre></td></tr></table></figure>
<p>可能其他人的机器上看到的结果和我的不一致，这是正常的，原因是我在~&#x2F;.lein&#x2F;profiles.clj中配置过了。</p>
<h3 id="默认Profiles"><a href="#默认Profiles" class="headerlink" title="默认Profiles"></a>默认Profiles</h3><p>默认启用的profiles定义在:default当中，我们来查看default profile中包含哪些profiles？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> lein show-profiles default</span></span><br><span class="line">[:leiningen/default] ;;指向leiningen/default</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lein show-profiles leiningen/default</span></span><br><span class="line">[:base :system :user :provided :dev] ;;五个默认启用的profiles</span><br></pre></td></tr></table></figure>

<p>这五个profiles代表的含义，在官方文档中有详细的描述，这里我只简略地描述一下:</p>
<ul>
<li>base: leiningen使用到的最基本的配置项，包括设置jvm-opts参数、往resource-paths中添加dev-resources等。它是leinigen的一部分，不应该被修改；</li>
<li>system: 和user类似，不过针对的是所有的用户；</li>
<li>user: 对当前用户下的所有projects有效。所以不应该在project.clj中设置user profile.</li>
<li>provided: 这个和pom.xml中scope是provided类似，只在生成jar的时候才有效，即生成pom.xml时，会把这个profile中定义的依赖以provided的scope添加进入pom.xml。</li>
<li>dev: 指定project专属的开发工具时会用到。</li>
</ul>
<h3 id="特定任务-task-specific-Profile"><a href="#特定任务-task-specific-Profile" class="headerlink" title="特定任务(task-specific) Profile"></a>特定任务(task-specific) Profile</h3><p>除了上面的default profile，还有像:repl和:uberjar这样以任务名称命名的profile。顾名思义，当你运行repl或者uberjar任务时，这些profiles的配置项会被合并到当前工程的profile当中。举个例子，我们定义一个uberjar profile，如下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:uberjar</span> &#123;<span class="symbol">:aot</span> <span class="symbol">:all</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个概念需要澄清，什么是:aot?<br>Clojure的代码总是会以两种方式被编译，aot和runtime。<br>aot是指Ahead of Time Compilation，与之相对的是Runtime Compilation。 两者的区别就是aot会将生成的bytecode保存到磁盘上，也就是我们所熟知的class文件；而Runtime Compilation时的bytecode则在JVM终止后消失。</p>
<p>此时，当你运行<em>lein uberjar</em>时，就会首先在target&#x2F;classes目录下生成clj源文件对应的class文件，打包包含clj和class文件；反之，如果不指定:aot，最终打出的jar包只会包含clj文件。</p>
<p>对于repl profile，这里也给出一个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:repl &#123;:dependencies [^:displace [org.clojure/clojure &quot;1.9.0-alpha3&quot;]] &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>现在当你在任意工程（project）之外运行<em>lein repl</em>的时候，默认的Clojure版本就是1.9.0-alpha3了，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nREPL server started on port 54003 on host 127.0.0.1 - nrepl://127.0.0.1:54003</span><br><span class="line">REPL-y 0.3.7, nREPL 0.2.12</span><br><span class="line">Clojure 1.9.0-alpha3 //这里的版本号</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 1.8.0_45-b14</span><br><span class="line">    Docs: (doc function-name-here)</span><br><span class="line">          (find-doc &quot;part-of-name-here&quot;)</span><br><span class="line">  Source: (source function-name-here)</span><br><span class="line"> Javadoc: (javadoc java-object-or-class-here)</span><br><span class="line">    Exit: Control+D or (exit) or (quit)</span><br><span class="line"> Results: Stored in vars *1, *2, *3, an exception in *e</span><br></pre></td></tr></table></figure>

<p>这里说到在任意工程之外运行会有不一样的结果，隐含的一层意思是项目根目录下的project.clj描述文件的优先级比较高。</p>
<h2 id="Profile的优先级"><a href="#Profile的优先级" class="headerlink" title="Profile的优先级"></a>Profile的优先级</h2><p>leiningen中有3类profiles定义：</p>
<ol>
<li>项目范围：<em>your-project&#x2F;profiles.clj</em></li>
<li>用户范围：*(or ~&#x2F;.lein&#x2F;profiles.clj ~&#x2F;.lein&#x2F;profiles.d&#x2F;xxx.clj)*</li>
<li>系统范围：*&#x2F;etc&#x2F;leiningen&#x2F;profiles.clj*</li>
</ol>
<h3 id="优先级次序"><a href="#优先级次序" class="headerlink" title="优先级次序"></a>优先级次序</h3><p>这些profiles的优先级是这样的：项目范围 &gt; project.clj &gt; 用户范围 &gt; 系统范围。其中项目范围的profile有一种典型应用：对当前项目进行个性化的配置（通过覆写project.clj中的配置），而不提交到git仓库。</p>
<h3 id="定义profiles-clj"><a href="#定义profiles-clj" class="headerlink" title="定义profiles.clj"></a>定义profiles.clj</h3><p>知道优先级之后，接下来的问题是我们该如何定义这样的profiles.clj呢？先看一下我的~&#x2F;.lein&#x2F;profiles.clj</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;<span class="symbol">:user</span>  &#123;<span class="symbol">:plugins</span> [[lein-codox <span class="string">&quot;0.9.4&quot;</span>]</span><br><span class="line">                   [lein-pprint <span class="string">&quot;1.1.1&quot;</span>]</span><br><span class="line">                   [lein-midje <span class="string">&quot;3.1.3&quot;</span>]</span><br><span class="line">                   [lein-try <span class="string">&quot;0.4.3&quot;</span>]</span><br><span class="line">                   [lein-midje-doc <span class="string">&quot;0.0.22&quot;</span>] ]</span><br><span class="line">         <span class="symbol">:injections</span>  [(<span class="name">require</span> &#x27;spyscope.core)</span><br><span class="line">                       (<span class="name">require</span> &#x27;io.aviso.repl </span><br><span class="line">                       &#x27;clojure.repl </span><br><span class="line">                       &#x27;clojure.main)</span><br><span class="line">              (<span class="name">alter-var-root</span> #&#x27;clojure.main/repl-caught</span><br><span class="line">                (<span class="name"><span class="built_in">constantly</span></span> @#&#x27;io.aviso.repl/pretty-pst))</span><br><span class="line">              (<span class="name">alter-var-root</span> #&#x27;clojure.repl/pst</span><br><span class="line">                (<span class="name"><span class="built_in">constantly</span></span> @#&#x27;io.aviso.repl/pretty-pst))]</span><br><span class="line"></span><br><span class="line">         <span class="symbol">:dependencies</span> [[org.clojure/tools.nrepl <span class="string">&quot;0.2.12&quot;</span>]</span><br><span class="line">                        <span class="comment">;; exception</span></span><br><span class="line">                        [io.aviso/pretty <span class="string">&quot;0.1.26&quot;</span>]</span><br><span class="line">                        <span class="comment">;; debug</span></span><br><span class="line">                        [spyscope <span class="string">&quot;0.1.5&quot;</span>] ]</span><br><span class="line">         <span class="symbol">:repositories</span> [[<span class="string">&quot;releases&quot;</span> &#123;<span class="symbol">:url</span> <span class="string">&quot;http://blueant.com/archiva/internal&quot;</span></span><br><span class="line">                           <span class="symbol">:creds</span> <span class="symbol">:gpg</span>&#125;]]&#125;</span><br><span class="line"> <span class="symbol">:dev</span>  &#123;<span class="symbol">:dependencies</span> [[org.clojure/tools.namespace <span class="string">&quot;0.2.11&quot;</span>]]&#125; </span><br><span class="line"> <span class="symbol">:repl</span> &#123;<span class="symbol">:dependencies</span> [^<span class="symbol">:displace</span> [org.clojure/clojure <span class="string">&quot;1.9.0-alpha3&quot;</span>]] &#125;&#125; </span><br></pre></td></tr></table></figure>
<p>这个文件定义了3种profiles，分别是:user, :dev, :repl. 语法结构是一个map的maps，通过keyword命名来区分。:user定义了插件、依赖和启动时自动绑定命名空间，:dev定义了依赖，:repl也定义了依赖，不过这个依赖前面用到了^:displace (Metadata)，标识在具体的项目之外才会依赖此版本的Clojure.</p>
<h2 id="启用Profile"><a href="#启用Profile" class="headerlink" title="启用Profile"></a>启用Profile</h2><p>前面提到leiningen默认会启用包含[:base :system :user :provided :dev]的leiningen&#x2F;profile，default profile指向了leiningen&#x2F;profile. 这里头其实包含了几层意义：</p>
<ul>
<li>profiles是可以自由组合的；</li>
<li>default profile是可以敷写的；</li>
<li>完全可以显式地启用某些profiles.</li>
</ul>
<p>如何组合这些profiles，官方文档中定义的很清楚，无须赘述。敷写default profile也比较简单，直接这么操作{:default [:profile-you-want]}. 那么只剩下如何显式地启用某些profiles了？答案是：with-profile.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lein with-profile user repl</span><br></pre></td></tr></table></figure>
<p>这就是只启用user profile来运行repl命令了。</p>
<h2 id="使用Metadata"><a href="#使用Metadata" class="headerlink" title="使用Metadata"></a>使用Metadata</h2><p>这里的Metadata是用于描述profile自身，那么它们到底有什么作用呢？<br>文档中列举了3个Metadata: ^:leaky, ^{:pom-scope :test}, ^{:pom-scope :provided}. 并告诉我们在生成pom.xml时会根据Metadata的类型将profile中定义的依赖写入其中，但是并未讲述如何使用它们。其实很简单，只要像下面那样在profile的名字之后写上这些Metadata即可。</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:repl</span> ^&#123;<span class="symbol">:pom-scope</span> <span class="symbol">:test</span>&#125; &#123;<span class="symbol">:dependencies</span> [[clj-http <span class="string">&quot;3.1.0&quot;</span>]] &#125;</span><br></pre></td></tr></table></figure>
<p>leiningen会自动把该profile的dependencies的scope设置成test，如下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:repl</span> &#123;<span class="symbol">:dependencies</span> [ [clj-http <span class="string">&quot;3.1.0&quot;</span> <span class="symbol">:scope</span> <span class="string">&quot;test&quot;</span>] ]&#125;</span><br></pre></td></tr></table></figure>
<p>这段逻辑可以从leiningen的<a href="https://github.com/technomancy/leiningen/blob/master/leiningen-core/src/leiningen/core/project.clj#L784">源码</a>当中获得：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">apply-profile-meta</span> [default-meta profile]</span><br><span class="line">    ...</span><br><span class="line">    (<span class="name"><span class="built_in">-&gt;</span></span> dep (<span class="name"><span class="built_in">conj</span></span> <span class="symbol">:scope</span>) (<span class="name"><span class="built_in">conj</span></span> (<span class="name"><span class="built_in">name</span></span> scope)))).</span><br></pre></td></tr></table></figure>

<p>所以如果你指定:repl profile生成pom.xml时，clj-http就会出现在test scope的dependency定义中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lein with-profile repl pom</span><br></pre></td></tr></table></figure>
<p>生成的pom文件，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>clj-http<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>clj-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其余主题Dynamic Eval和Debugging，文档中叙述的比较完整且简单。</p>
<hr>
<p>参考链接<br>[1] <a href="https://github.com/technomancy/leiningen/blob/master/doc/PROFILES.md">Leiningen Profile</a></p>
]]></content>
      <categories>
        <category>Clojure</category>
      </categories>
      <tags>
        <tag>leiningen</tag>
      </tags>
  </entry>
  <entry>
    <title>Generative Testing</title>
    <url>/2016/11/04/Generative-Testing/</url>
    <content><![CDATA[<p>我们为什么要写单元测试？</p>
<p>满足需求是所有软件存在的必要条件，单元测试一定是为它服务的。从这一点出发，我们可以总结出写单元测试的两个动机：驱动（如：TDD）和验证功能实现。另外，软件需求易变的特征决定修改代码成为必然，在这种情况下，单元测试能保护已有的功能不被破坏。</p>
<p>基于以上两点共识，我们看看传统的单元测试有什么特征？</p>
<h2 id="基于用例的测试（By-Example）"><a href="#基于用例的测试（By-Example）" class="headerlink" title="基于用例的测试（By Example）"></a>基于用例的测试（By Example）</h2><p>单元测试最常见的套路就是Given、When、Then三部曲。</p>
<ul>
<li>Given：初始状态或前置条件 </li>
<li>When：行为发生</li>
<li>Then：断言结果</li>
</ul>
<p>编写时，我们会精心准备（Given）一组输入数据，然后在调用行为后，断言返回的结果与预期相符。这种基于用例的测试方式在开发（包括TDD）过程中十分好用。因为它清晰地定义了输入输出，而且大部分情况下体量都很小、容易理解。</p>
<p>但这样的测试方式也有坏处。</p>
<p>第一点在于测试的意图。用例太过具体，我们就很容易忽略自己的测试意图。比如我曾经看过有人在写计算器kata程序的时候，将其中的一个测试命名为<em>return 3 when add 1 and 2</em>，这样的命名其实掩盖了测试用例背后的真实意图——传入两个整型参数，调用add方法之后得到的结果应该是参数之和。我们常说测试即文档，既然是文档就应该明确描述待测方法的行为，而不是陈述一个例子。</p>
<p>第二点在于测试完备性。因为省事省心并且回报率高，我们更乐于写<em>happy path</em>的代码。尽管出于职业道德，我们也会找一个明显的异常路径进行测试，不过这还远远不够。</p>
<p>为了辅助单元测试改善这两点。我这里介绍另一种测试方式——生成式测试（Generative Testing，也称<a href="https://github.com/fpinscala/fpinscala/wiki/Chapter-8:-Property-based-testing">Property-Based Testing</a>）。这种测试方式会基于输入假设输出，并且生成许多可能的数据验证假设的正确性。</p>
<h2 id="生成式测试"><a href="#生成式测试" class="headerlink" title="生成式测试"></a>生成式测试</h2><p>对于第一个问题，我们换种思路思考一下。假设我们不需要写具体的测试用例，那么掩盖意图的可能性也就没有了。想法很美好，但如何实践Given、When、Then呢？答案是让程序生成并自动验证它们。这也就引出生成式测试的概念——我们先声明传入数据可能的情况，然后使用生成器生成符合入参情况的数据，调用待测方法，最后才进行验证。</p>
<h3 id="Given阶段"><a href="#Given阶段" class="headerlink" title="Given阶段"></a>Given阶段</h3><p>Clojure 1.9（Alpha）新内置的clojure.spec可以很轻松地做到这点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; 定义输入参数的可能情况：两个整型参数</span><br><span class="line">(s/def ::add-operators (s/cat :a int? :b int?))</span><br><span class="line">;; 尝试生成数据</span><br><span class="line">(gen/generate (s/gen ::add-operators))</span><br><span class="line"></span><br><span class="line">;; 生成的数据</span><br><span class="line">-&gt; (1 -122)</span><br></pre></td></tr></table></figure>
<p>首先，我们尝试声明两个参数可能出现的情况或者称为规格（specification），即参数a和b都是整数。然后调用生成器产生一对整数。整个分析和构造的过程中，都没有涉及具体的数据，这样会强制我们揣摩输入数据可能的模样，而且也能避免测试意图被掩盖掉——正如前面所说，<em>return 3 when add 1 and 2</em>并不代表什么，<em>return the sum of two integers</em>才具有普遍意义。</p>
<h3 id="Then阶段"><a href="#Then阶段" class="headerlink" title="Then阶段"></a>Then阶段</h3><p>数据是生成了，待测方法也可以调用，但是Then这个断言阶段又让人头疼了，因为我们根本没法预知生成的数据，也就无法知道正确的结果，怎么断言？</p>
<p>拿我们定义的加法运算为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn add [a b]</span><br><span class="line">  (+ a b))</span><br></pre></td></tr></table></figure>
<p>我们尝试把断言改成一个全称命题的格式：</p>
<blockquote>
<p>任取两个整数a, b，a和b加起来的结果总是a, b之和。</p>
</blockquote>
<p>借助<a href="https://github.com/clojure/test.check">test.check</a>，我们在<em>Clojure</em>可以这样表达</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def test-add</span><br><span class="line">  (prop/for-all [a (gen/int)</span><br><span class="line">                 b (gen/int)]</span><br><span class="line">                (= (add a b) (+ a b))))</span><br></pre></td></tr></table></figure>
<p>等等，我们把add方法的实现<code>(+ a b)</code>写到了断言里，这几乎丧失了单元测试的基本意义。换一种断言方式，我们使用加法的逆运算进行描述：</p>
<blockquote>
<p>任取两个整数，把a和b加起来的结果减去a总会得到b。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def test-add</span><br><span class="line">  (prop/for-all [a (gen/int)</span><br><span class="line">                 b (gen/int)]</span><br><span class="line">                (= (- (add a b) a) b))))</span><br></pre></td></tr></table></figure>
<p>我们通过程序陈述了一个已知的真命题。变换以后，就可以使用<code>quick-check</code>对多组生成的整数进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; 随机生成100组数据测试add方法</span><br><span class="line">(tc/quick-check 100 test-add)</span><br><span class="line"></span><br><span class="line">;; 测试结果</span><br><span class="line">-&gt; &#123;:result true, :num-tests 100, :seed 1477285296502&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果表明，刚才运行了100组测试，并且都通过了。理论上，程序可以生成无数的测试数据来验证add方法的正确性。即便不能穷尽，我们也获得一组统计上的数字，而不仅仅是几个纯手工挑选的用例。</p>
<p>至于第二个问题，首先得明确测试是无法做到完备的。很多指导方法保证使用较少的用例做到有效覆盖，比如：等价类、边界值、判定表、因果图、pairwise等等。但是在实际使用过程当中，依然存在问题。举个等价类的例子，假如我们有一个接受自然数并直接返回入参的方法<em>identity-nat</em>，那么对于输入参数而言，全体自然数都互为等价类，其中的一个有效等价类可以是自然数1。如果入参被假定在整数的范围，我们很容易找到一个无效等价类，比如-1。</p>
<p>用Clojure测试代码表现出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(deftest test-with-identity-nat</span><br><span class="line">  (testing &quot;identity of natural integers&quot;</span><br><span class="line">    (is (= 1 (identity-nat 1))))</span><br><span class="line">  (testing &quot;throw exception for non-natural integers&quot;</span><br><span class="line">    (is (thrown? RuntimeException (identity-nat -1)))))</span><br></pre></td></tr></table></figure>
<p>不过如果有人修改了方法<em>identity-nat</em>的实现，单独处理入参为0的情况，这个测试还是能够照常通过。也就是说，实现发生改变，基于等价类的测试有可能起不到防护作用的。当然你完全可以反驳：规则改变，等价类也得重新定义。道理确实如此，但是反过来想想，我们写测试的目的不正是构建一张安全网吗？我们信任测试能在代码变动时给予警告，但此处它失信了，这就尴尬了。</p>
<p>如果使用生成式测试，我们规定：</p>
<blockquote>
<p>任取一个自然数a，在其上调用f的结果总是a。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def test-identity-nat</span><br><span class="line"> (prop/for-all [a (s/gen nat-int?)]</span><br><span class="line">               (= a (identity-nat a))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(tc/quick-check 100 test-identity-nat)</span><br><span class="line"></span><br><span class="line">-&gt; &#123;:result false, :seed 1477362396044, :failing-size 0, :num-tests 1, :fail [0], :shrunk &#123;:total-nodes-visited 0, </span><br><span class="line">         :depth 0, </span><br><span class="line">         :result false, </span><br><span class="line">         :smallest [0]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这个测试尝试对100组生成的自然数（nat-int?）进行测试，但首次运行就发现代码发生过变动。失败的数据是0，而且还给出了最小失败集[0]。拿着这个最小失败集，我们就可以快速地重现失败用例，从而修正。</p>
<p>当然也有可能在一次运行中，我们的测试无法发现失败的用例。但是，如果100个测试用例都通过了，至少表明我们程序对于100个随机的自然数都是正确的。和基于用例的测试相比，这就如同编织出一道更加紧密的安全网。网孔越小，漏掉的情况也越少。</p>
<p>Clojure语言之父Rich Hickey推崇*<a href="https://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a>*哲学，所以生成式测试在Clojure.spec中有更为简约的表达。以上述为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(s/fdef identity-nat</span><br><span class="line">        :args (s/cat :a nat-int?) ;输入参数的规格</span><br><span class="line">        :ret nat-int?             ;返回结果的规格</span><br><span class="line">        :fn #(= (:ret %) (-&gt; % :args :a))) ;入参和出参之间的约束</span><br><span class="line"></span><br><span class="line">(stest/check `identity-nat)</span><br></pre></td></tr></table></figure>
<p><em>fdef</em>宏定义了方法<em>identity-nat</em>的规格，默认情况下会基于参数的规格生成1000组数据进行生成式测试。除了这一好处，它还提供部分类型检查的功能。</p>
<h2 id="再谈TDD"><a href="#再谈TDD" class="headerlink" title="再谈TDD"></a>再谈TDD</h2><p>TDD（测试驱动开发）是一种驱动代码实现和设计的过程。我们说要先有测试，再去实现；保证实现功能的前提下，重构代码以达到较好的设计。整个过程就好比演绎推理，测试就是其中的证明步骤，而最终实现的功能则是证明的结果。</p>
<p>对于开发人员而言，基于用例的测试方式是友好的，因为它能简单直接地表达实现的功能并保证其正确性。一旦进入红、绿、重构的节（guai）奏（quan），开发人员根本停不下来，进入一种心流状态。只不过问题是，基于用例驱动出来的实现可能并不是<strong>恰好</strong>通过的。我们常常会发现，在写完上组测试用例的实现之后，无需任何改动，下组测试照常能运行通过。换句话说，实现代码可能做了多余的事情而我们却浑然不知。在这种情况下，我们可以利用生成式测试准备大量符合规格的数据探测程序，以此检查程序的健壮性，让缺陷无处遁形。</p>
<p>凡是想到的情况都能测试，但是想不到情况也需要测试。这才是生成式测试的价值所在。有人把TDD概念化为“展示你的功能”（Show your work），而把生成式测试概念化为“检查你的功能“（Check your work），我深以为然。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>回到我们写单元测试的动机上：</p>
<ol>
<li>保证或验证实现功能；</li>
<li>保护已经实现的功能不被破坏。<br>基于用例的单元测试和生成式测试在这两点上是相辅相成的。我们可以借助它们尽可能早地找出缺陷，避免缺陷逃逸到生产环境。</li>
</ol>
<p>ThoughtWorks 2016年11月份的技术雷达把Clojure.spec移到了工具象限的评估环中，这表明这个工具值得作一番探究。当然，除了Clojure，<a href="http://hypothesis.works/articles/quickcheck-in-every-language/">其它语言</a>都有相应的生成式测试的框架，你不妨在自己的项目中试一试。</p>
]]></content>
      <categories>
        <category>Clojure</category>
      </categories>
      <tags>
        <tag>testing</tag>
      </tags>
  </entry>
  <entry>
    <title>Emacs configs for a clojurian</title>
    <url>/2017/01/01/Emacs-configs-for-a-clojurian/</url>
    <content><![CDATA[<p>俗话说，工欲善其事必先利其器，完善开发工具与我而言是一件快乐的事情，分享也是一件令人愉悦的事情，所以我想把学习过程中的点滴记录下，留作备忘。本文不会介绍太多花式或有深度的emacs配置，更多是摸索学习的过程，其中充满了乐趣。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>网络上的*.emacs.d&#x2F;init.el<em>配置数不胜数，各路lisp大神的</em>dot file<em>都已经放在github上了，而且前有牛人撰文推荐学习emacs配置的详实方法，看似确实没有什么必要自己折腾一份配置。这个说法对，也不对。我在转向emacs之前，是一名忠实的vim党，从大学开始就不断折腾vim的配置，还花过一段时间专门学习了</em>vimscript<em>，曾经惊叹于</em>vimscript<em>的动态函数式风格的优美和强大。类似地，</em>.vimrc*配置文件在网络上也多如牛毛，华丽和酷炫的插件极大地提升了vim的操作性。尽管如此，我还是乐于一砖一瓦地打造自己的vim环境，竭力演化它变成我心目中的“编辑器之神”。这个过程一般会充满修改然后重启的重复性机械劳作，偶尔会遭遇无论怎么修改就是不生效、甚至遍寻google也一无所获的挫折，但是我就是无法厌倦它，人天生好奇，探索未知事物本身就充满了乐趣，而且一旦配置奏效，便能获得满满的成就感。新事物对程序员具有极大的吸引力，但是程序员不会止步于使用新事物，而且会在惊奇之余，渴望控制那股背后主导它的力量本身，行使“上帝之力”。</p>
<p>话说回来，为什么我会从vim党摇身一变成为emacs党呢？这就不得不提起Clojure这门lisp方言，出于对lisp和函数式编程的痴迷，我选择了基于JVM的Clojure作为自己的偏好语言，而emacs天生为lisp而生。有了这个充足的理由，我开始收集emacs的cheatsheet并打印出来，天天放在手边翻阅，甚至买了一本英文版的<em>Learning GNU Emacs</em>书籍，只要有机会就打开emacs开始刷4clojure上的编程题。由于emacs对lisp的亲和性，我几乎没花多少时间就掌握住了常用的操作技巧。不过，emacs最负盛名的学习曲线确实让学习者绕过圈子，只要一段时间不用，就会忘记很多基本操作。另外，为了更好地在emacs中编写Clojure，还需要cider-mode和clojure-mode的支持，这时候就不得不编辑<em>init.el</em>文件，本着<em>KISS (keep it simple, stupid)<em>原则，我照着各种插件的说明文档中，把配置项复制粘贴到</em>init.el</em>文件当中，运行起来没有问题就好。随着自定义的内容变多，<em>init.el</em>文件也急剧膨胀起来。膨胀本来算不上问题，但我是个比较有操守的程序员，臃肿的代码是我极力避免的坏味道（bad smell）。所以胸臆之中涌动一股浩然之气，决心学起<em>emacs lisp</em>，把emacs的配置从头来过。</p>
<h2 id="从『头』开始"><a href="#从『头』开始" class="headerlink" title="从『头』开始"></a>从『头』开始</h2><p><em>init.el</em>文件位于*~&#x2F;.emacs.d<em>目录之下，如果没有，自行创建一份即可。<br>首先，我们需要用到emacs的包管理工具</em>package.el*，因为emacs 24及其以上的版本都已经内置，所以无需下载到本地，直接通过<code>require</code>加载到emacs的运行时。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> &#x27;package)</span><br><span class="line">(<span class="name">setq</span> package-archives &#x27;((<span class="string">&quot;melpa&quot;</span> . <span class="string">&quot;http://melpa.org/packages/&quot;</span>)</span><br><span class="line">						 (<span class="string">&quot;melpa-stable&quot;</span> . <span class="string">&quot;https://stable.melpa.org/packages/&quot;</span>)</span><br><span class="line">						 (<span class="string">&quot;marmalade&quot;</span> . <span class="string">&quot;http://marmalade-repo.org/packages/&quot;</span>)</span><br><span class="line">						 (<span class="string">&quot;elpy&quot;</span> . <span class="string">&quot;http://jorgenschaefer.github.io/packages/&quot;</span>)</span><br><span class="line">						 (<span class="string">&quot;gnu&quot;</span> . <span class="string">&quot;http://elpa.gnu.org/packages/&quot;</span>))</span><br><span class="line">	  package-enable-at-startup <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码涉及到<code>setq</code>（变量赋值）的操作，<code>package-archives</code>，顾名思义，多个包的下载源，我给<code>package-archives</code>设置了5个包源，它们之间服从顺序的优先级，即先从第一个源中下载包，如果没有，到第二个原种寻找，以此类推。此外，这里<code>(&quot;melpa&quot; . &quot;http://melpa.org/packages/&quot;)</code>中的点号（dot）表示法也比较奇怪，其实这是lisp中的<em>Dotted pair</em>表示法，用法和普通的列表类似，但因为是<em>pair</em>的缘故，你可以使用<code>(car )</code>获取<code>&quot;melpa&quot;</code>，<code>(cdr )</code>获取到的却不再是一个列表，而是<code>&quot;http://melpa.org/packages/&quot; </code>这个值本身。</p>
<p>对<em>emacs lisp</em>不熟悉不要紧，先找个教程练习一下它的用法，比如<a href="https://learnxinyminutes.com/docs/elisp/">learnxinyminutes</a>就非常不错。完成这个教程，大体不会对<em>elisp</em>犯怵了。接下来，只需要使用<code>c-h v</code>和<code>c-h f</code>查看<em>elisp</em>中定义的变量函数就能很快上手自行配置。<br>来个实际的例子，在大牛的配置文件中，经常能看到如下成对的配置：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> package-enable-at-startup <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">package-initialize</span>)</span><br></pre></td></tr></table></figure>
<p>开始我觉得这是一对矛盾的配置，<code>package-enable-at-startup</code>设置为nil，暗示emacs启动时不会启用<code>package</code>，而<code>package-initialize</code>明显表明在做<code>package</code>的初始化工作。这种时候，我心中就蹦跶出一句话“世界上本没有矛盾，如果出现了，检查你都有哪些前提条件，就会发现其中一个是错的”。这种非异常的知识点很难通过搜索引擎找到满意的答案，而阅读文档恰恰是最合适的解决方式。emacs对<code>elisp</code>文档的支持非常全面，只需将鼠标移到<code>package-enable-at-startup</code>变量上，按下<code>c-h v</code> (control + h, v) 组合键，就能在其它窗口（window) 看到文档描述：</p>
<blockquote>
<p>Whether to activate installed packages when Emacs starts.<br>If non-nil, packages are activated after reading the init file<br>and before <code>after-init-hook&#39;.  Activation is not done if </code>user-init-file’ is nil (e.g. Emacs was started with “-q”).</p>
</blockquote>
<p>意思是在读入<em>init.el</em>之后，这个变量才会生效。换句话说，在读取<em>init.el</em>的过程中，该变量不论是nil或是non-nil都不会影响<code>package</code>的加载和初始化。所以，这两者之间并没有矛盾。当然，此时你可能会想把<code>package-enable-at-startup</code>设置为nil意欲何为？<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Installation.html">官方文档</a>中有如下的解释：</p>
<blockquote>
<p>This will automatically set package-enable-at-startup to nil, to avoid loading the packages again after processing the init file.</p>
</blockquote>
<p>简单点说，就是防止在<code>package-initialize </code>之后重复加载包，因为可能会影响性能。</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>如果把什么东西都揉到<em>init.el</em>文件中，这个文件一定会很快变得臃肿不堪。为了解决这个问题，需要引入模块化的思想——把特定功能的配置放到独立的文件中，然后<code>require</code>进来。按照惯例，我在*~&#x2F;.emacs.d<em>目录下建立一个</em>lisp<em>目录用于存放所有自定义的模块文件，随后在</em>init.el<em>中加入下面这句代码，意在把</em>lisp*目录加到emacs的加载路径列表里。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">add-to-list</span> &#x27;load-path (<span class="name">expand-file-name</span> <span class="string">&quot;lisp&quot;</span> user-emacs-directory))</span><br></pre></td></tr></table></figure>
<p>看似，接下来就可以在每个独立的模块文件中编写各种功能的配置。但是由于<code>package.el</code>功能的局限，我们很快就会遇到包重复安装和配置漂移（configuration drift）的麻烦。<code>package.el</code>提供了<code>package-install-p</code>（p是predicate的意思）和<code>package-install</code>两个配套使用的函数，也就是说一般得先判断包在不在，才决定安不安装。幸运的是，有人已经很好地解决了这部分问题，<a href="https://github.com/jwiegley/use-package">use-package</a>就是非常好用的包，它将包的配置和包的定义聚合到了一块，并且保证包一定会安装在你的系统当中。<br>在使用<code>use-package</code>之前，我们需要先安装它，如下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">unless</span> (<span class="name">package-installed-p</span> &#x27;use-package)</span><br><span class="line">  (<span class="name">package-refresh-contents</span>)</span><br><span class="line">  (<span class="name">package-install</span> &#x27;use-package))</span><br><span class="line"></span><br><span class="line">(<span class="name">eval-when-compile</span></span><br><span class="line">  (<span class="name">require</span> &#x27;use-package))</span><br></pre></td></tr></table></figure>
<p>由于<code>use-package</code>本身就是一个包，所以可以使用<code>package-install</code>安装到本地，然后<code>require</code>到emacs的运行时，值得一提的是这个<code>eval-when-compile</code>函数，使用<code>c-h f</code>查看它的定义:</p>
<blockquote>
<p>Like ‘progn’, but evaluates the body at compile time if you’re compiling.<br>Thus, the result of the body appears to the compiler as a quoted constant.<br>In interpreted code, this is entirely equivalent to &#96;progn’.</p>
</blockquote>
<p>初次看到<strong>compile time</strong>，心中难免会有疑问：lisp不是动态语言吗，怎么还需要编译？这种时候，我们就要求助于<em>elisp</em>的文档了。在emacs中按下<code>c-h i</code>获取主话题（topic）的菜单，然后点击<em>Elisp</em>进入它的操作指南。重点查看<em>Evaluation</em>和<em>Byte Compilation</em>两个章节。不难发现lisp的解析器可以读取解析两种类型的lisp代码，一种是适合人类阅读的代码，以<em>el</em>作为后缀；另一种是编译字节码，以<em>elc</em>作为后缀。编译字节码运行速度优于前一种代码，我们可以通过<code>byte-compile-file</code>把前一种代码的文件编译成字节码文件。有趣的是，如果我们使用<em>package</em>来安装包，对应包的目录下都存在配套的<em>el</em>和<em>elc</em>两类文件。<br>在<em>Byte Compilation</em>条目下，有<code>eval-when-compile</code>的完整描述：</p>
<blockquote>
<p>If you’re using another package, but only need macros from it (the byte compiler will expand those), then ‘eval-when-compile’ can be used to load it for compiling, but not executing. For example,</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">eval-when-compile</span></span><br><span class="line">   (<span class="name">require</span> &#x27;my-macro-package))</span><br></pre></td></tr></table></figure>
<p>这里头有三个关键字<strong>load</strong>、<strong>compiling</strong>和<strong>executing</strong>值得留意一下。为了弄懂它们的含义，我们需要了解lisp解析器基本的工作原理：<code>code text -[characters]-&gt; load -[lisp object]-&gt; evaluation/compiling -[bytecode]-&gt; lisp interpretor</code>。换句话说，除非你想编译包含上述代码的文件，否则它的作用和<code>progn</code>一模一样，顺序地求值包含其中的表达式。当你正在编译文件的时候，包中宏就会原地展开，然后被<code>eval-when-compile</code>宏加载进内存并被编译成字节码，供后续解析器执行。</p>
<h2 id="Clojure相关"><a href="#Clojure相关" class="headerlink" title="Clojure相关"></a>Clojure相关</h2><p>载入<em>use-package</em>之后，我需要开始配置自己强大的Clojure开发环境了。首先，引入几个包：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">use-package</span> rainbow-delimiters</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">use-package</span> clj-refactor</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">use-package</span> company</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:defer</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span> (<span class="name">global-company-mode</span>))</span><br></pre></td></tr></table></figure>
<p><em>rainbow-delimiters</em>能够让括号变得如同彩虹一样绚丽（主要是易于区分forms），<em>clj-refactor</em>是重构Clojure程序的神器，<em>company</em>提供了强大的命令补全提示功能。</p>
<h3 id="clojure-mode"><a href="#clojure-mode" class="headerlink" title="clojure mode"></a>clojure mode</h3><p>接下来，我们在*~&#x2F;.emacs.d&#x2F;lisp<em>目录下新建一个</em>init-clojure.el*文件，内容如下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> &#x27;clj-refactor)</span><br><span class="line">(<span class="name">require</span> &#x27;rainbow-delimiters)</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> midje-mode</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> my-clj-refactor-mode-hook ()</span><br><span class="line">	(<span class="name">clj-refactor-mode</span> <span class="number">1</span>)</span><br><span class="line">	(<span class="name">yas-minor-mode</span> <span class="number">1</span>) <span class="comment">; for adding require/use/import</span></span><br><span class="line">	(<span class="name">cljr-add-keybindings-with-prefix</span> <span class="string">&quot;C-c C-m&quot;</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> clojure-mode</span><br><span class="line">			 <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">			 <span class="symbol">:config</span></span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;clojure-mode-hook #&#x27;rainbow-delimiters-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;clojure-mode-hook #&#x27;subword-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;clojure-mode-hook #&#x27;midje-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;clojure-mode-hook #&#x27;my-clj-refactor-mode-hook)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;clojure-mode-hook #&#x27;enable-paredit-mode))</span><br><span class="line"></span><br><span class="line">(<span class="name">provide</span> &#x27;init-clojure)</span><br></pre></td></tr></table></figure>
<p>这里就能看出<em>use-package</em>的好处来了，针对<em>clojure-mode</em>的配置项都统一放到<code>:config</code>中管理起来。配置完毕后，使用<code>(provide &#39;init-clojure)</code>将模块以这样的名字暴露给其它客户端调用。</p>
<h3 id="CIDER-mode"><a href="#CIDER-mode" class="headerlink" title="CIDER mode"></a>CIDER mode</h3><p>有了<em>clojure-mode</em>之后，我们还需要一个Clojure可交互式的开发工具，CIDER便是这么一款工具。同样地，我们在<em>lisp</em>目录下新建一个名为<em>init-clojure-cider.el</em>，内容如下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> &#x27;init-clojure)</span><br><span class="line">(<span class="name">require</span> &#x27;company)</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> cider</span><br><span class="line">			 <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">			 <span class="symbol">:config</span></span><br><span class="line">			 (<span class="name">setq</span> nrepl-popup-stacktraces <span class="literal">nil</span>)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-mode-hook &#x27;eldoc-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-mode-hook #&#x27;rainbow-delimiters-mode)</span><br><span class="line">			 <span class="comment">;; Replace return key with newline-and-indent when in cider mode.</span></span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-mode-hook &#x27;(lambda () (local-set-key (kbd <span class="string">&quot;RET&quot;</span>) &#x27;newline-and-indent)))</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-mode-hook #&#x27;company-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-repl-mode-hook &#x27;subword-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-repl-mode-hook &#x27;paredit-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-repl-mode-hook #&#x27;company-mode)</span><br><span class="line">			 (<span class="name">add-hook</span> &#x27;cider-repl-mode-hook #&#x27;rainbow-delimiters-mode))</span><br><span class="line"></span><br><span class="line">(<span class="name">provide</span> &#x27;init-clojure-cider)</span><br></pre></td></tr></table></figure>
<p>配置的首部，我使用<code>(require &#39;init-clojure)</code>先加载<em>init-clojure</em>，然后对CIDER本身进行一系列的配置。配置的详细信息可以通过CIDER github主页获取到，这里我就不再赘述。</p>
<p>最后，需要在<em>init.el</em>文件中添加入这么一句<code>(require &#39;init-clojure-cider)</code>，重新启动emacs，找到一个Clojure项目，按下<code>C-c M-j</code> (hack-jack-in)，就能获得一个Clojure的交互式开发环境。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当然，我的emacs配置绝对不止这些，但是其余的过程大体类似。由于emacs速来有伪装成编辑器的操作系统的称号，所以我的探索是无止境的。如果大家对我的配置感兴趣，可以直接去我github上<a href="https://github.com/qianyan/dotfiles">dotfiles</a>上查看。</p>
<h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><p>参考链接<br>[1] <a href="https://sriramkswamy.github.io/dotemacs/">sriramkswamy dotemacs</a><br>[2] <a href="https://github.com/purcell/emacs.d/">purcell emacs.d</a></p>
]]></content>
      <categories>
        <category>Clojure</category>
      </categories>
      <tags>
        <tag>emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>Clojure集合管道函数练习</title>
    <url>/2016/09/12/Collection-Pipelines-By-TDD/</url>
    <content><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>TDD讨论组里的<a href="http://www.jackyshen.com/">申导</a>最近在B站直播了Martin Fowler的经典文章*<a href="http://www.martinfowler.com/articles/refactoring-pipelines.html">Refactoring with Loops and Collection Pipelines</a><em>中谈到的<strong>利用集合管道对循环进行函数式重构</strong>。视频地址在<a href="http://www.bilibili.com/mobile/video/av6146294.html">这里</a>，申导的翻译在<a href="http://www.jackyshen.com/2016/07/04/Refactoring-with-Loops-and-Collection-Pipelines/">这里</a>。组织者<a href="http://www.seabornlee.cn/">小波（Seaborn Lee）</a>趁机出了一道关于集合管道函数<a href="https://codingstyle.cn/topics/205">题目</a>。我就想啊，论函数式编程，舍</em>Clojure<em>其谁？而且我在</em>Clojure*很少能写出<code>loop... recur</code>这样偏底层的循环代码。话不多说，撸起袖子开工。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一家澡堂有 m 个房间，每个房间有 n 个时段，现在要给用户推荐「最早的可以预约的时段」。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rooms: [</span><br><span class="line">  &#123;</span><br><span class="line">     room_id: 1,</span><br><span class="line">     periods: [</span><br><span class="line">        &#123;</span><br><span class="line">           time: &#x27;17:00-18:00&#x27;,</span><br><span class="line">           status: &#x27;available&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">           time: &#x27;18:00-19:00&#x27;,</span><br><span class="line">           status: &#x27;occupied&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">     room_id: 2,</span><br><span class="line">     periods: [</span><br><span class="line">        &#123;</span><br><span class="line">           time: &#x27;17:00-18:00&#x27;,</span><br><span class="line">           status: &#x27;occupied&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">           time: &#x27;18:00-19:00&#x27;,</span><br><span class="line">           status: &#x27;available&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>期望返回：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  room_id: 1,</span><br><span class="line">  time: &#x27;17:00-18:00&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目很简单，基本思路：首先过滤出每个房间<code>periods</code>中<code>status</code>为<code>available</code>的时间段，然后取第一个也就是最早的时间段（默认为递增排序的），接着将<code>room_id</code>和这个时间段以<strong>期望返回</strong>的形式合并。再然后对所有合并的结果依据时间段进行一次排序（<code>sort</code>），最后取第一个结果即可。</p>
<h2 id="1-Clojure-解法"><a href="#1-Clojure-解法" class="headerlink" title="1. Clojure 解法"></a>1. Clojure 解法</h2><h3 id="转换数据格式"><a href="#转换数据格式" class="headerlink" title="转换数据格式"></a>转换数据格式</h3><p>原题中给的是json的格式，不适合在<em>Clojure</em>中处理，所以我们手工转换成需要的形式，如下：<br><strong>清单1-1</strong> 数据定义</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">def</span> <span class="title">rooms</span></span><br><span class="line">  [&#123;<span class="symbol">:room-id</span> <span class="number">1</span></span><br><span class="line">    <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;</span><br><span class="line">              &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;]&#125;</span><br><span class="line">   &#123;<span class="symbol">:room-id</span> <span class="number">2</span></span><br><span class="line">    <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;</span><br><span class="line">              &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;]&#125;])</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>清单1-2</strong> 房间最早可预约时间段</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-room</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">-&gt;&gt;</span></span> rooms</span><br><span class="line">       (<span class="name"><span class="built_in">map</span></span></span><br><span class="line">        (<span class="name"><span class="built_in">juxt</span></span> first (<span class="name"><span class="built_in">fn</span></span> [&#123;<span class="symbol">:keys</span> [periods]&#125;]</span><br><span class="line">                      (<span class="name"><span class="built_in">-&gt;&gt;</span></span> periods</span><br><span class="line">                           (<span class="name"><span class="built_in">filter</span></span> #(<span class="name"><span class="built_in">=</span></span> (<span class="symbol">:status</span> %) <span class="symbol">:available</span>))</span><br><span class="line">                           (<span class="name"><span class="built_in">ffirst</span></span>)))))</span><br><span class="line">       (<span class="name"><span class="built_in">map</span></span> #(<span class="name"><span class="built_in">into</span></span> &#123;&#125; %))</span><br><span class="line">       (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span>)</span><br><span class="line">       (<span class="name"><span class="built_in">first</span></span>)))</span><br><span class="line">       </span><br><span class="line">(<span class="name">the-earliest-available-room</span> rooms)</span><br><span class="line">-&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span><span class="punctuation">,</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码和上面的解析是一一对应的关系。为了让程序清晰，符合管道的用法，这里使用了thread last宏（<code>-&gt;&gt;</code>），它的作用是把前面一个<code>form</code>作为后一个<code>form</code>的最后一个参数。与之呼应的是thread first宏（<code>-&gt;</code>），它的作用类似，不过会传成第一个参数。</p>
<p>我们先看<code>(map (juxt ...) ...)</code>这一段代码。<code>juxt</code>是一个非常有意思的函数，而且超级实用。它的文档描述如下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">doc</span> juxt)</span><br><span class="line">-&gt;</span><br><span class="line">clojure.core/juxt</span><br><span class="line"> [f]</span><br><span class="line"> [f g]</span><br><span class="line"> [f g h]</span><br><span class="line"> [f g h &amp; fs]</span><br><span class="line">Added in <span class="number">1.1</span></span><br><span class="line">  Takes a set of functions and returns a fn that is the juxtaposition</span><br><span class="line">  of those fns.  The returned fn takes a variable number of args<span class="punctuation">,</span> and</span><br><span class="line">  returns a vector containing the result of applying each fn to the</span><br><span class="line">  args (<span class="name">left-to-right</span>).</span><br><span class="line">  ((<span class="name"><span class="built_in">juxt</span></span> a b c) x) =&gt; [(<span class="name">a</span> x) (<span class="name">b</span> x) (<span class="name">c</span> x)]</span><br></pre></td></tr></table></figure>
<p>它的神奇之处在于可以对同一个参数应用不同的函数，而且还能将应用的结果全部收集起来。想想题目的解析中提及的以<strong>期望返回</strong>的形式合并，如果我们应用<code>juxt</code>函数，就能得到<code>[(:room-id 1) (:time &quot;17:00-18:00&quot;)]</code>这样的中间结果。</p>
<p><code>(juxt first (fn ...))</code>中<code>first</code>用于提取<code>:room-id</code>，而后面的<code>lambda</code>表达式则用于提取<code>:time</code>。解法很直观，筛选出<code>:status</code>是<code>:available</code>的时间段，然后使用<code>(ffirst)</code>取第一个map的首个entry。如：<code>&#123;:time &quot;17:00-18:00&quot; :status :available&#125;</code>，那么应用<code>(ffirst)</code>的结果就是<code>[:time &quot;17:00-18:00&quot;]</code>。</p>
<p>接下来，又进行了一次map操作，这次的目的是把元组的entries，转换为map。举个例子：<code>[[:room-id 1] [:time &quot;17:00-18:00&quot;]]</code> &#x3D;&gt; <code>&#123;:room-id 1 :time &quot;17:00-18:00&quot;&#125;</code>。转换成map之后，方便以<code>:time</code>对结果进行排序<code>(sort-by :time)</code>，最后取出第一个元素<code>(first)</code>，即我们期望的返回。</p>
<p>写完之后，我很想再写个TDD版本的。话不多说，继续撸袖子。</p>
<h2 id="2-Clojure-TDD-解法"><a href="#2-Clojure-TDD-解法" class="headerlink" title="2. Clojure TDD 解法"></a>2. Clojure TDD 解法</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>生成工程</li>
</ul>
<p>进入命令行，输入<code>lein new midje the-earliest-available-period-of-bathroom</code>，leiningen会生成基于<code>midje</code>这个测试框架的工程。</p>
<ul>
<li><p>Git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">&gt; .gitignore</span><br><span class="line">.lein*</span><br><span class="line">.nrep*</span><br><span class="line">target/</span><br><span class="line">这里ctrl-c退出</span><br><span class="line">git add .</span><br><span class="line">git commit --message &quot;init commit&quot;</span><br></pre></td></tr></table></figure>
<p>我使用了<code>zsh</code>和<code>oh-my-zsh</code>，自带了很多git操作的alias，可以通过<code>alias |grep git</code>查看。后续的git操作都会使用alias。</p>
</li>
<li><p>自动测试</p>
</li>
</ul>
<p>输入<code>lein repl</code>，然后<code>(use &#39;midje.repl)</code>，最后输入<code>(autotest)</code>。这样一旦文件修改保存，测试就会自动触发。</p>
<ul>
<li>Emacs</li>
</ul>
<p>用来写代码的。</p>
<h3 id="Tasking（任务拆分）"><a href="#Tasking（任务拆分）" class="headerlink" title="Tasking（任务拆分）"></a>Tasking（任务拆分）</h3><p>先不急着敲代码，我们先从测试的角度看看完成这个需求需要哪几步？</p>
<ul>
<li><input disabled="" type="checkbox"> 单间澡堂有一个可用时间段</li>
<li><input disabled="" type="checkbox"> 单间澡堂有多个可用时间段</li>
<li><input disabled="" type="checkbox"> 所有澡堂（包含输入为空）没有可用时间段</li>
<li><input disabled="" type="checkbox"> 多间澡堂都有可用时间段</li>
<li><input disabled="" type="checkbox"> 多间澡堂中有的有可用时间段，有的没有可用时间段</li>
</ul>
<h3 id="第1个任务"><a href="#第1个任务" class="headerlink" title="第1个任务"></a>第1个任务</h3><ul>
<li><input disabled="" type="checkbox"> 单间澡堂有一个可用时间段</li>
</ul>
<h4 id="1-写测试"><a href="#1-写测试" class="headerlink" title="1. 写测试"></a>1. 写测试</h4><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">def</span> <span class="title">room-1</span> &#123;<span class="symbol">:room-id</span> <span class="number">1</span></span><br><span class="line">    <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;</span><br><span class="line">              &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">               <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;]&#125;)</span><br><span class="line"></span><br><span class="line">(<span class="keyword">def</span> <span class="title">room-2</span> &#123;<span class="symbol">:room-id</span> <span class="number">2</span></span><br><span class="line">             <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;</span><br><span class="line">                       &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;]&#125;)</span><br><span class="line">                        </span><br><span class="line">(<span class="name">facts</span> <span class="string">&quot;about `the-earliest-avaible-period-of-bathroom`&quot;</span></span><br><span class="line">  (<span class="name">fact</span> <span class="string">&quot;should recommand if there is only one room with available period&quot;</span></span><br><span class="line">    <span class="comment">;; 1号</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-1]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;)</span><br><span class="line">    <span class="comment">;; 2号</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-2]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">2</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;))</span><br></pre></td></tr></table></figure>

<h4 id="2-写实现"><a href="#2-写实现" class="headerlink" title="2. 写实现"></a>2. 写实现</h4><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>针对1号测试，这个实现有点“荒诞”，术语<code>hard code</code>说的就是这个，但是眼下足够了。不过此时，应该再写一个类似的测试来去除<code>hard code</code>，即2号测试。<br>相应地，我们要修改实现。</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">defn the-earliest-available-recommand [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">let</span></span> [&#123;<span class="symbol">:keys</span> [room-id periods]&#125; (<span class="name"><span class="built_in">first</span></span> rooms)</span><br><span class="line">        available-periods (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %)) periods)]</span><br><span class="line">    (<span class="name"><span class="built_in">merge</span></span> &#123;<span class="symbol">:room-id</span> room-id&#125;</span><br><span class="line">           (<span class="name"><span class="built_in">select-keys</span></span> (<span class="name"><span class="built_in">first</span></span> available-periods) [<span class="symbol">:time</span>]))))</span><br></pre></td></tr></table></figure>

<h4 id="3-关闭并提交"><a href="#3-关闭并提交" class="headerlink" title="3. 关闭并提交"></a>3. 关闭并提交</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 单间澡堂有一个可用时间段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;one available room&quot;</span><br></pre></td></tr></table></figure>
<h3 id="第2个任务"><a href="#第2个任务" class="headerlink" title="第2个任务"></a>第2个任务</h3><ul>
<li><input disabled="" type="checkbox"> 单间澡堂有多个可用时间段</li>
</ul>
<h4 id="1-写测试-1"><a href="#1-写测试-1" class="headerlink" title="1. 写测试"></a>1. 写测试</h4><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">def</span> <span class="title">room-3</span> &#123;<span class="symbol">:room-id</span> <span class="number">3</span></span><br><span class="line">             <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;</span><br><span class="line">                       &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;</span><br><span class="line">                       &#123;<span class="symbol">:time</span> <span class="string">&quot;19:00-20:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:available</span>&#125;]&#125;)</span><br><span class="line">...                        </span><br><span class="line">(<span class="name">fact</span> <span class="string">&quot;should recommand the earliest one if there is only one room with multiple available periods&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">3</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>保存，发现测试还是跑过了。原因在于我们默认了<code>period</code>是递增排序的。我们看看有没有重构点？实现太简单了暂时找不到，那就欢欢喜喜地跳过实现步骤。</p>
<h4 id="2-关闭并提交"><a href="#2-关闭并提交" class="headerlink" title="2. 关闭并提交"></a>2. 关闭并提交</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 单间澡堂有多个可用时间段<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;one room with multiple available periods&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第3个任务"><a href="#第3个任务" class="headerlink" title="第3个任务"></a>第3个任务</h3><ul>
<li><input disabled="" type="checkbox"> 所有澡堂（包含输入为空）没有可用时间段</li>
</ul>
<h4 id="1-写测试-2"><a href="#1-写测试-2" class="headerlink" title="1. 写测试"></a>1. 写测试</h4><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">def</span> <span class="title">non-available-room</span> &#123;<span class="symbol">:room-id</span> <span class="number">4</span></span><br><span class="line">             <span class="symbol">:periods</span> [&#123;<span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;</span><br><span class="line">                       &#123;<span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;</span><br><span class="line">                       &#123;<span class="symbol">:time</span> <span class="string">&quot;19:00-20:00&quot;</span></span><br><span class="line">                        <span class="symbol">:status</span> <span class="symbol">:occupied</span>&#125;]&#125;)</span><br><span class="line">                        </span><br><span class="line">(<span class="name">fact</span> <span class="string">&quot;should show `:no-available-room` if there is no available room&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> []) =&gt; <span class="symbol">:no-available-room</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [non-available-room]) =&gt; <span class="symbol">:no-available-room</span>))                        </span><br></pre></td></tr></table></figure>
<p>这回肯定挂掉。</p>
<h4 id="2-写实现-1"><a href="#2-写实现-1" class="headerlink" title="2. 写实现"></a>2. 写实现</h4><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">let</span></span> [&#123;<span class="symbol">:keys</span> [room-id periods]&#125; (<span class="name"><span class="built_in">first</span></span> rooms)</span><br><span class="line">        available-periods (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %)) periods)]</span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">seq</span></span> available-periods)</span><br><span class="line">      (<span class="name"><span class="built_in">merge</span></span> &#123;<span class="symbol">:room-id</span> room-id&#125;</span><br><span class="line">             (<span class="name"><span class="built_in">select-keys</span></span> (<span class="name"><span class="built_in">first</span></span> available-periods) [<span class="symbol">:time</span>]))</span><br><span class="line">      <span class="symbol">:no-available-room</span>)))</span><br></pre></td></tr></table></figure>
<p>这里使用了<em>Clojure</em>中判断集合是否为空较为常用的手法<code>(seq )</code>，如果集合非空，那么返回集合本身；反之，返回nil，nil在逻辑上是false。测试通过。</p>
<h4 id="3-关闭并提交-1"><a href="#3-关闭并提交-1" class="headerlink" title="3. 关闭并提交"></a>3. 关闭并提交</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 所有澡堂（包含输入为空）没有可用时间段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;no available room&quot;</span><br></pre></td></tr></table></figure>

<h3 id="第4个任务"><a href="#第4个任务" class="headerlink" title="第4个任务"></a>第4个任务</h3><ul>
<li><input disabled="" type="checkbox"> 多间澡堂都有可用时间段</li>
</ul>
<h4 id="1-写测试-3"><a href="#1-写测试-3" class="headerlink" title="1. 写测试"></a>1. 写测试</h4><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">fact</span> <span class="string">&quot;should recommand the earliest if there has more than one room and each has available periods&quot;</span></span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [room-1 room-2]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [room-2 room-1]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [room-2 room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">2</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;</span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [room-1 room-2 room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-写实现-2"><a href="#2-写实现-2" class="headerlink" title="2. 写实现"></a>2. 写实现</h4><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">seq</span></span> rooms)</span><br><span class="line">    (<span class="name"><span class="built_in">first</span></span> (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span></span><br><span class="line">                    (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">fn</span></span> [room]</span><br><span class="line">                           (<span class="name"><span class="built_in">let</span></span> [&#123;<span class="symbol">:keys</span> [room-id periods]&#125; room</span><br><span class="line">                                 available-periods (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %)) periods)]</span><br><span class="line">                             (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">seq</span></span> available-periods)</span><br><span class="line">                               (<span class="name"><span class="built_in">merge</span></span> &#123;<span class="symbol">:room-id</span> room-id&#125;</span><br><span class="line">                                      (<span class="name"><span class="built_in">select-keys</span></span> (<span class="name"><span class="built_in">first</span></span> available-periods) [<span class="symbol">:time</span>]))</span><br><span class="line">                               <span class="symbol">:no-available-room</span>)))</span><br><span class="line">                         rooms)))</span><br><span class="line">    <span class="symbol">:no-available-room</span>))</span><br></pre></td></tr></table></figure>
<p>到这里，我们开始使用<code>(map )</code>函数处理多个房间的内容。注意，当输入房间是空集合的时候，这里需要相应地做<code>(seq rooms)</code>判空处理，否则会返回nil，而不是我们想要的<code>:no-available-room</code>。</p>
<h4 id="3-关闭并提交-2"><a href="#3-关闭并提交-2" class="headerlink" title="3. 关闭并提交"></a>3. 关闭并提交</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 多间澡堂都有可用时间段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;more than one room&quot;</span><br></pre></td></tr></table></figure>

<h4 id="4-重构"><a href="#4-重构" class="headerlink" title="4. 重构"></a>4. 重构</h4><p>代码写到这里，再不重构就说不过去了。另外，管道没看到，倒是看到一堆括号。<br>我们使用thread last<code>(-&gt;&gt; )</code>做一次重构：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">seq</span></span> rooms)</span><br><span class="line">    (<span class="name"><span class="built_in">-&gt;&gt;</span></span> rooms</span><br><span class="line">         (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">fn</span></span> [room]</span><br><span class="line">                (<span class="name"><span class="built_in">let</span></span> [&#123;<span class="symbol">:keys</span> [room-id periods]&#125; room</span><br><span class="line">                      available-periods (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %)) periods)]</span><br><span class="line">                  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">seq</span></span> available-periods)</span><br><span class="line">                    (<span class="name"><span class="built_in">merge</span></span> &#123;<span class="symbol">:room-id</span> room-id&#125;</span><br><span class="line">                           (<span class="name"><span class="built_in">select-keys</span></span> (<span class="name"><span class="built_in">first</span></span> available-periods) [<span class="symbol">:time</span>]))</span><br><span class="line">                    <span class="symbol">:no-available-room</span>))))</span><br><span class="line">         (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span>)</span><br><span class="line">         first)</span><br><span class="line">    <span class="symbol">:no-available-room</span>))</span><br></pre></td></tr></table></figure>
<p>还行，至少没那么多嵌套了。提交一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;[refactor] use macro thread-last -&gt;&gt; to pipe&quot;</span><br></pre></td></tr></table></figure>
<p>继续重构，使用我们的<code>juxt</code>函数。</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">letfn</span></span> [(<span class="name">period</span> [&#123;<span class="symbol">:keys</span> [periods]&#125;]</span><br><span class="line">            (<span class="name"><span class="built_in">-&gt;&gt;</span></span> periods</span><br><span class="line">                 (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %)))</span><br><span class="line">                 ffirst</span><br><span class="line">                 (#(<span class="name"><span class="built_in">or</span></span> % [<span class="symbol">:time</span> <span class="symbol">::non-available</span>]))))]</span><br><span class="line">    (<span class="name"><span class="built_in">-&gt;&gt;</span></span> rooms</span><br><span class="line">         (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">fn</span></span> [room]</span><br><span class="line">                (<span class="name"><span class="built_in">apply</span></span> conj &#123;&#125; ((<span class="name"><span class="built_in">juxt</span></span> first period) room))))</span><br><span class="line">         (<span class="name"><span class="built_in">remove</span></span> #(#&#123;<span class="symbol">::non-available</span>&#125; (<span class="symbol">:time</span> %)))</span><br><span class="line">         (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span>)</span><br><span class="line">         first</span><br><span class="line">         (#(<span class="name"><span class="built_in">or</span></span> % <span class="symbol">:no-available-room</span>)))))</span><br></pre></td></tr></table></figure>
<p>看上去还行，不过不爽的是<code>(#(or % [:time ::non-available]))</code>。为了迎合<code>(-&gt;&gt; )</code>宏，我们给<code>(or )</code>包了一层。原因是<code>(-&gt;&gt; )</code>会让前面的结果出现在最后一个参数的位置，而我们需要将结果放到<code>(or )</code>的第一个参数的位置。有没有什么好看的解决方法呢？当然有！我们可以使用<code>(-&gt; )</code>来做到这点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn the-earliest-available-recommand [rooms]</span><br><span class="line">  (letfn [(period [&#123;:keys [periods]&#125;]</span><br><span class="line">            (-&gt; periods</span><br><span class="line">                (-&gt;&gt; (filter #(#&#123;:available&#125; (:status %)))</span><br><span class="line">                     ffirst)</span><br><span class="line">                (or [:time ::non-available])))]</span><br><span class="line">    (-&gt; rooms</span><br><span class="line">        (-&gt;&gt; (map (fn [room]</span><br><span class="line">                    (apply conj &#123;&#125; ((juxt first period) room))))</span><br><span class="line">             (remove #(#&#123;::non-available&#125; (:time %)))</span><br><span class="line">             (sort-by :time)</span><br><span class="line">             first)</span><br><span class="line">        (or :no-available-room))))</span><br></pre></td></tr></table></figure>
<p>顿时觉得世界干净了不少。再提交一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;[refactor] use juxt to extract needed fields&quot;</span><br></pre></td></tr></table></figure>
<h3 id="第5个任务"><a href="#第5个任务" class="headerlink" title="第5个任务"></a>第5个任务</h3><ul>
<li><input disabled="" type="checkbox"> 多间澡堂中有的有可用时间段，有的没有可用时间段</li>
</ul>
<h4 id="1-写测试-4"><a href="#1-写测试-4" class="headerlink" title="1. 写测试"></a>1. 写测试</h4><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">fact</span> <span class="string">&quot;should recommand the earliest available room even if there has non available room&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-1 non-available-room]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-2 non-available-room]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">2</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>测试直接通过，又可以跳过实现代码了。不过，这也预示着我们的测试是有覆盖的，也需要花时间整理这些测试用例。在那之前，先提交一下。</p>
<h4 id="2-关闭并提交-1"><a href="#2-关闭并提交-1" class="headerlink" title="2. 关闭并提交"></a>2. 关闭并提交</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 多间澡堂中有的有可用时间段，有的没有可用时间段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;mixed non-available and available rooms&quot;</span><br></pre></td></tr></table></figure>
<h3 id="为第3个任务补上测试用例"><a href="#为第3个任务补上测试用例" class="headerlink" title="为第3个任务补上测试用例"></a>为第3个任务补上测试用例</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 所有（包含多个）澡堂（包含输入为空）没有可用时间段</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">fact</span> <span class="string">&quot;should show `:no-available-room` if there is no available room&quot;</span></span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> []) =&gt; <span class="symbol">:no-available-room</span></span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [non-available-room]) =&gt; <span class="symbol">:no-available-room</span></span><br><span class="line">   (<span class="name">the-earliest-available-recommand</span> [non-available-room non-available-room]) =&gt; <span class="symbol">:no-available-room</span>))</span><br></pre></td></tr></table></figure>
<p>这里的第3个用例包含第2个用例，我们待会整理掉。不过现在先提交一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;multiple non-available rooms&quot;</span><br></pre></td></tr></table></figure>
<h3 id="整理测试"><a href="#整理测试" class="headerlink" title="整理测试"></a>整理测试</h3><p>在前面进行的任务当中，我们发现有两次没有写实现测试就通过的情况。这说明测试用例是有覆盖的。</p>
<ul>
<li>第2个任务的测试用例其实覆盖了第1个任务的测试用例，所以可以直接删去后者；</li>
<li>第5个任务的测试用例覆盖了第4个任务的部分测试用例，所以可以合并到一起。</li>
</ul>
<p>整理下来，最终的测试变成下面这样：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">facts</span> <span class="string">&quot;about `the-earliest-avaible-period-of-bathroom`&quot;</span></span><br><span class="line">  (<span class="name">fact</span> <span class="string">&quot;should recommand the earliest one if there is only one room with multiple available periods&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">3</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;)</span><br><span class="line">  </span><br><span class="line">  (<span class="name">fact</span> <span class="string">&quot;should show `:no-available-room` if there is no available room&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> []) =&gt; <span class="symbol">:no-available-room</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [non-available-room non-available-room]) =&gt; <span class="symbol">:no-available-room</span>)</span><br><span class="line"> </span><br><span class="line">  (<span class="name">fact</span> <span class="string">&quot;should recommand the earliest if there has more than one room and each may have available periods&quot;</span></span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-1 room-2]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-2 room-1]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-2 room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">2</span> <span class="symbol">:time</span> <span class="string">&quot;18:00-19:00&quot;</span>&#125;</span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-1 room-2 room-3]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;</span><br><span class="line">    (<span class="name">the-earliest-available-recommand</span> [room-1 non-available-room]) =&gt; &#123;<span class="symbol">:room-id</span> <span class="number">1</span> <span class="symbol">:time</span> <span class="string">&quot;17:00-18:00&quot;</span>&#125;))</span><br></pre></td></tr></table></figure>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><blockquote>
<p>The final goal of any engineering activity is some type of documentation.</p>
</blockquote>
<p>更新README.md文件，其中描述程序解决的问题以及运行步骤，当然包含设计思路那更好了。提交一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;update readme&quot;</span><br></pre></td></tr></table></figure>

<h3 id="美化代码"><a href="#美化代码" class="headerlink" title="美化代码"></a>美化代码</h3><blockquote>
<p>代码是诗行 - by lambeta</p>
</blockquote>
<h2 id="什么是好看的代码？除了清晰明了，格式也必须产生美感。顺眼不少，最后提交一下。"><a href="#什么是好看的代码？除了清晰明了，格式也必须产生美感。顺眼不少，最后提交一下。" class="headerlink" title="什么是好看的代码？除了清晰明了，格式也必须产生美感。顺眼不少，最后提交一下。"></a>什么是好看的代码？除了清晰明了，格式也必须产生美感。<br><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">letfn</span></span> [(<span class="name">period</span> [&#123;<span class="symbol">:keys</span> [periods]&#125;]</span><br><span class="line">            (<span class="name"><span class="built_in">-&gt;</span></span> periods</span><br><span class="line">                (<span class="name"><span class="built_in">-&gt;&gt;</span></span> (<span class="name"><span class="built_in">filter</span></span> #(#&#123;<span class="symbol">:available</span>&#125; (<span class="symbol">:status</span> %))))</span><br><span class="line">                (<span class="name"><span class="built_in">ffirst</span></span>) <span class="comment">; 统一套上括号</span></span><br><span class="line">                (<span class="name"><span class="built_in">or</span></span> [<span class="symbol">:time</span> <span class="symbol">::non-available</span>])))]</span><br><span class="line">    (<span class="name"><span class="built_in">-&gt;</span></span> rooms</span><br><span class="line">        (<span class="name"><span class="built_in">-&gt;&gt;</span></span> (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">juxt</span></span> first period))</span><br><span class="line">             (<span class="name"><span class="built_in">map</span></span> #(<span class="name"><span class="built_in">into</span></span> &#123;&#125; %)) <span class="comment">; 合并单独提出来</span></span><br><span class="line">             (<span class="name"><span class="built_in">remove</span></span> #(#&#123;<span class="symbol">::non-available</span>&#125; (<span class="symbol">:time</span> %)))</span><br><span class="line">             (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span>)</span><br><span class="line">             (<span class="name"><span class="built_in">first</span></span>)) <span class="comment">; 统一套上括号</span></span><br><span class="line">        (<span class="name"><span class="built_in">or</span></span> <span class="symbol">:no-available-room</span>))))</span><br></pre></td></tr></table></figure><br>顺眼不少，最后提交一下。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ga .</span><br><span class="line">gcmsg &quot;[refactor] beautify pipe format&quot;</span><br></pre></td></tr></table></figure></h2><p>这篇文章发出来一天，TDD讨论群的一位麦姓朋友@我道：</p>
<blockquote>
<p>core&#x3D;&gt; (first {:a 1 :b 2})<br>[:a 1]<br>core&#x3D;&gt; (first {:b 2 :a 1})<br>[:b 2]<br>@lambeta map的元素应该是无序的，用first来获得key value pair是不可靠的。</p>
</blockquote>
<p>看到这个建议的时候，我心里一阵欣喜——又有一员<em>Clojurians</em>，可以切磋技艺了！冷静下来，发现自己确实忽略了map中的entries可能是无序的。所以我做了如下的验证：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">type</span></span> &#123;&#125;)</span><br><span class="line">-&gt; clojure.lang.PersistentArrayMap</span><br></pre></td></tr></table></figure>
<p>看到<code>PersistentArrayMap</code>的时候，我明白这些entries是保持插入顺序的，也就是说，<code>(first &#123;:a 1 :b 2&#125;)</code>的求值结果一定是<code>[:a 1]</code>。照这个思路，在我的程序当中使用<code>(first )</code>取map的第一个元素并不会出错。不过，本着谨慎的心态，我查了一下clojure的<a href="https://clojuredocs.org/clojure.core/array-map">array-map</a>，发现一个有趣的例子：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">make-map</span> [count] (<span class="name"><span class="built_in">zipmap</span></span> (<span class="name"><span class="built_in">range</span></span> count) (<span class="name"><span class="built_in">range</span></span> count)))</span><br><span class="line">(<span class="name"><span class="built_in">type</span></span> (<span class="name">make-map</span> <span class="number">9</span>))</span><br><span class="line"><span class="comment">;; =&gt; clojure.lang.PersistentArrayMap</span></span><br><span class="line">(<span class="name"><span class="built_in">type</span></span> (<span class="name">make-map</span> <span class="number">10</span>))</span><br><span class="line"><span class="comment">;; =&gt; clojure.lang.PersistentHashMap</span></span><br></pre></td></tr></table></figure>
<p>这表明当map中的entries数量超过一定数量（不一定是9，例外见：<a href="http://dev.clojure.org/jira/browse/CLJ-1587">PersistentArrayMap’s assoc doesn’t respect HASHTABLE_THRESHOLD</a>）时，<code>PersistentArrayMap</code>就变成了<code>PersistentHashMap</code>，那也就意味着，<code>(first )</code>取出来的值可能是<em>随机的</em>。举个例子：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">first</span></span> &#123;<span class="number">7</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">1</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">3</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">9</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">8</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">5</span> <span class="number">5</span>&#125;)</span><br><span class="line">-&gt; [<span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>返回的结果并不是相当然的<code>[7 7]</code>，而是<code>[0 0]</code>。那么<code>(first )</code>到底干了些什么呢？Cognitect公司的<a href="https://github.com/puredanger">alexmiller</a>回答我说：<code>(first )</code>会把它的参数强制转换（coerce）成了一个序列，然后取第一个值。我们试着用<code>(seq )</code>转换一下：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">type</span></span> &#123; <span class="number">7</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">1</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">3</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">9</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">8</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">5</span> <span class="number">5</span>&#125;)</span><br><span class="line">-&gt; clojure.lang.PersistentHashMap</span><br><span class="line">(<span class="name"><span class="built_in">seq</span></span> &#123; <span class="number">7</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">1</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">3</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">9</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">8</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">5</span> <span class="number">5</span>&#125;)</span><br><span class="line">-&gt; ([<span class="number">0</span> <span class="number">0</span>] [<span class="number">7</span> <span class="number">7</span>] [<span class="number">1</span> <span class="number">1</span>] [<span class="number">4</span> <span class="number">4</span>] [<span class="number">6</span> <span class="number">6</span>] [<span class="number">3</span> <span class="number">3</span>] [<span class="number">2</span> <span class="number">2</span>] [<span class="number">9</span> <span class="number">9</span>] [<span class="number">8</span> <span class="number">8</span>])</span><br></pre></td></tr></table></figure>
<p>果然，<code>[0 0]</code>出现在序列的首位。至于为什么是这样的顺序，需要深入<em>Clojure</em>的hash算法和数据结构当中，有时间另起一篇博客解释。我们再试试<code>PersistentArrayMap</code>的情况：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">type</span></span> &#123; <span class="number">7</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">1</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">3</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">9</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span> <span class="number">0</span>&#125;)</span><br><span class="line">-&gt; clojure.lang.PersistentArrayMap</span><br><span class="line">(<span class="name"><span class="built_in">seq</span></span> &#123; <span class="number">7</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">1</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">6</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">3</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">9</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span> <span class="number">0</span>&#125;)</span><br><span class="line">-&gt; ([<span class="number">7</span> <span class="number">7</span>] [<span class="number">1</span> <span class="number">1</span>] [<span class="number">4</span> <span class="number">4</span>] [<span class="number">6</span> <span class="number">6</span>] [<span class="number">3</span> <span class="number">3</span>] [<span class="number">2</span> <span class="number">2</span>] [<span class="number">9</span> <span class="number">9</span>] [<span class="number">0</span> <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>顺序确实和原来的一致。</p>
<p>我们的程序当中是不应该假设map是有序的，所以需要修改实现代码。</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">letfn</span></span> [(<span class="name">period</span> [&#123;<span class="symbol">:keys</span> [periods]&#125;]</span><br><span class="line">            (<span class="name"><span class="built_in">-&gt;</span></span> periods</span><br><span class="line">                (<span class="name"><span class="built_in">-&gt;&gt;</span></span> (<span class="name"><span class="built_in">filter</span></span> (<span class="name"><span class="built_in">comp</span></span> #&#123;<span class="symbol">:available</span>&#125; <span class="symbol">:status</span>)))</span><br><span class="line">                (<span class="name"><span class="built_in">first</span></span>)</span><br><span class="line">                (<span class="name"><span class="built_in">find</span></span> <span class="symbol">:time</span>)))</span><br><span class="line">          (<span class="name">room-id</span> [room]</span><br><span class="line">            (<span class="name"><span class="built_in">find</span></span> room <span class="symbol">:room-id</span>))]</span><br><span class="line">    (<span class="name"><span class="built_in">-&gt;</span></span> rooms</span><br><span class="line">        (<span class="name"><span class="built_in">-&gt;&gt;</span></span> (<span class="name"><span class="built_in">map</span></span> (<span class="name"><span class="built_in">comp</span></span> (<span class="name"><span class="built_in">partial</span></span> into &#123;&#125;) (<span class="name"><span class="built_in">juxt</span></span> room-id period)))</span><br><span class="line">             (<span class="name"><span class="built_in">filter</span></span> <span class="symbol">:time</span>)</span><br><span class="line">             (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:time</span>)</span><br><span class="line">             (<span class="name"><span class="built_in">first</span></span>))</span><br><span class="line">        (<span class="name"><span class="built_in">or</span></span> <span class="symbol">:no-available-room</span>))))</span><br></pre></td></tr></table></figure>
<p><code>(find )</code>函数，用于从map中获取包含该键值的entry，如果找不到，返回nil。这样就避免了潜在无序的entries对程序的干扰。另外，<code>(partial into &#123;&#125;)</code>和<a href="https://en.wikipedia.org/wiki/Currying">Currying</a>很像，它通过接收<code>into</code>函数及其首个参数，构造出一个接收后续参数的函数。当然也可以直接使用<code>#(into &#123;&#125; %)</code>这样的形式。</p>
<p>下面是麦姓朋友的另一种解法，和我的解法思路不完全一样，值得学习借鉴。</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">the-earliest-available-recommand</span> [rooms]</span><br><span class="line">  (<span class="name"><span class="built_in">letfn</span></span> [(<span class="name">earliest-available-time</span> [periods]</span><br><span class="line">            (<span class="name"><span class="built_in">-&gt;&gt;</span></span> periods</span><br><span class="line">                 (<span class="name"><span class="built_in">filter</span></span> (<span class="name"><span class="built_in">comp</span></span> #&#123;<span class="symbol">:available</span>&#125; <span class="symbol">:status</span>))</span><br><span class="line">                 (<span class="name"><span class="built_in">map</span></span> <span class="symbol">:time</span>)</span><br><span class="line">                 (<span class="name"><span class="built_in">sort</span></span>)</span><br><span class="line">                 (<span class="name"><span class="built_in">first</span></span>)))]</span><br><span class="line">    (<span class="name">rename-keys</span></span><br><span class="line">     (<span class="name"><span class="built_in">-&gt;&gt;</span></span> rooms</span><br><span class="line">          (<span class="name"><span class="built_in">map</span></span> #(<span class="name"><span class="built_in">update-in</span></span> % [<span class="symbol">:periods</span>] earliest-available-time))</span><br><span class="line">          (<span class="name"><span class="built_in">filter</span></span> <span class="symbol">:periods</span>)</span><br><span class="line">          (<span class="name"><span class="built_in">sort-by</span></span> <span class="symbol">:periods</span>)</span><br><span class="line">          (<span class="name"><span class="built_in">first</span></span>))</span><br><span class="line">     &#123;<span class="symbol">:periods</span> <span class="symbol">:time</span>&#125;)))</span><br></pre></td></tr></table></figure>
<p>真诚欢迎大家继续点评。</p>
<hr>
<p><a href="https://github.com/qianyan/kata-bathroom/">本文样例</a></p>
]]></content>
      <categories>
        <category>Clojure</category>
      </categories>
      <tags>
        <tag>kata</tag>
      </tags>
  </entry>
  <entry>
    <title>Pipleline as Code</title>
    <url>/2017/03/01/Pipleline-as-Code/</url>
    <content><![CDATA[<p>2016年11月份的技术雷达中给出了一个简明的定义：流水线即代码 (Pipeline as Code) 通过编码而非配置持续集成&#x2F;持续交付 (CI&#x2F;CD) 运行工具的方式定义部署流水线。<br>其实早在2015年11月份的技术雷达当中就已经有了类似的概念：</p>
<blockquote>
<p>The way to avoid programming in your CI&#x2F;CD tool is to extract the complexities of the build process from the guts of the tool and into a simple script which can be invoked by a single command. This script can then be executed on any developer workstation and therefore eliminates the privileged&#x2F;singular status of the build environment<br>大意是将复杂的构建流程纳入一个简单的脚本文件，然后用一条命令调用。这样，任意的开发者都能在自己的工作区中执行脚本重建一套一模一样的构建环境，从而消除 CI&#x2F;CD 环境由于散乱配置腐化而成的特异性。这么做的原因很好理解，使用 CI&#x2F;CD 工具是为了暴露产品代码中的问题的，如果它们自身已经复杂到不稳定的地步，我们还使用它就是自找麻烦。</p>
</blockquote>
<p>从某种程度上看，实施流水线即代码是不证自明的。在 CI&#x2F;CD 的时间过程中，凡是可以被编码的东西都已经被代码化了，比如：构建、测试、数据库迁移、部署和基础设施&#x2F;环境配置 (Infrastruture as Code) 等。说得烂俗点，流水线已经是 CI&#x2F;CD 实践过程中的“最后一公里”，让流水线变成软件开发中的“一等公民”（即代码）是大势所趋、民心所向。不过，这种论断毕竟欠缺说服力，我们接着从实践的痛点出发总结当前流水线遇到的问题。</p>
<h2 id="实践中的痛点"><a href="#实践中的痛点" class="headerlink" title="实践中的痛点"></a>实践中的痛点</h2><p>我给客户搭建和配置过不少 CI&#x2F;CD 流水线（被同事戏谑地称为“CI&#x2F;CD搭建兽”），最大的痛苦莫过于每次都得从头来过，即便大部分情况下所用的工具和配置都大同小异。其次是手工操作产生的配置漂移 (configuration drift) 。以 Jenkins 为例，先不谈 1.0 版本不支持流水线这一概念的问题，我们为了解决遇到的构建、测试和部署等问题，一般会在多个文本框中粘贴大量 shell&#x2F;batch 脚本；甚至会通过这些文本框安装各种插件或者依赖包、设置环境变量等等。久而久之（实际上不需要多久），这台 Jenkins 服务器就变得不可替代（特异化）了，因为没人清楚到底对它做了哪些更改以及这些更改对承载它的系统产生哪些影响，这时 Jenkins 服务器俨然腐化成了老马所说的雪花服务器 (snowflake server)。雪花服务器有两点显著的特征：</p>
<ol>
<li>特别难以复现</li>
<li>几乎无法理解</li>
</ol>
<p>第一点是由于以往所做的更改并没有被记录下来，所以做过的操作都是七零八落的，没有办法复现同样的操作，也无法复制一个同样的系统。<br>第二点则是由于绝大部分情况下散乱的配置是没有文档描述的，哪部分是重要的已经无从知晓，改动的风险很大。</p>
<p>这些问题会在流水线的演化过程中恶化得越来越严重。一般来讲，除非不再使用，否则流水线不会保持一成不变。具体实施过程中，考虑到项目，尤其是遗留项目当前的特点和团队成员的“产能”，我们会先将构建和部署自动化；部署节奏稳定后，开始将单元测试和代码分析自动化；接着可以指导测试人员将验收测试自动化；然后尝试将发布自动化。在这之后，就要开始持续优化流水线，包括 CI 的速度和稳定性等。换句话说，流水线的演化其实是和项目的当前进展密切相关的，保证这样的对应关系有时是有必要的，比如：在版本控制下，多发布分支所需流水线和主干分支会存在不同。发布分支是主干分支某个时刻分出去的，它需要在那时的流水线上才能正常工作。由于前面所说雪花服务器的特征，重建这样一条流水线并不是一件容易的事情。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-e8d3fcb49a100197.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="演进式的持续集成"></p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>其实，流水线即代码本身已经回答这个问题了。当前实现了这一概念的工具大体遵循了两种模式：</p>
<ol>
<li>版本控制</li>
<li>DSL（领域特定语言）</li>
</ol>
<p>对于特别难以复现、没有保证对应关系的痛点，我们就把流水线写成代码放到版本控制工具中管理起来。这样一来，每一次更改都能被记录下来，而且它会始终和此时的项目进展保持同步。</p>
<p>对于几乎无法理解、没有文档支持的痛点，我们就选用领域特定语言描述整条流水线。举个 Jenkins 2.0 例子，它允许我们在项目的特定目录下放置一个 Jenkinsfile 的文件，内容大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node(&#x27;master&#x27;) &#123;</span><br><span class="line">	stage(&#x27;Checkout&#x27;) &#123;…&#125;</span><br><span class="line">	stage(&#x27;Code Analysis&#x27;) &#123;…&#125;</span><br><span class="line">	stage(&#x27;Unit Test&#x27;) &#123;…&#125;</span><br><span class="line">	stage(&#x27;Packing&#x27;) &#123;…&#125;</span><br><span class="line">	stage(&#x27;Archive&#x27;) &#123;…&#125;</span><br><span class="line">	stage(&#x27;DEV&#x27;) &#123;…&#125;</span><br><span class="line">&#125;</span><br><span class="line">stage(&#x27;SIT&#x27;) &#123;</span><br><span class="line">	timeout(time:4, unit:&#x27;HOURS&#x27;) &#123;</span><br><span class="line">		input &quot;Deploy to SIT?&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	node(&#x27;master&#x27;) &#123;…&#125;</span><br><span class="line">&#125;</span><br><span class="line">stage(&#x27;Acceptance Test&#x27;) &#123;</span><br><span class="line">	node(&#x27;slave&#x27;) &#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Jenkins 2.0 使用Groovy实现了一套描述流水线的DSL，即便不了解Groovy语言，只要对流水线稍微熟悉，就能按照<a href="https://github.com/jenkinsci/pipeline-plugin/blob/master/TUTORIAL.md">例子和文档</a>编写出符合要求的代码。</p>
<p>类似的工具还有Concourse.ci、λCD (LambdaCD) 等。<br>Concourse.ci 使用了 yaml 实现了DSL，独立抽象出Resource（外部依赖，如：git repo）、Job（函数， get 和 put Resource ）和 Task（纯函数，必须明确定义 Input 和 Output ）模型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-250bc1dc50e3bdd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Concousre.ci"></p>
<p>而 λCD 则使用 Clojure 语言实现了 DSL，抽象出 Pipeline 和 Step 模型，使用了Lisp特有的宏 (macro) 和普通函数，编写起来简单明了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-8b29a42d225edebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="λCD"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def pipeline-def</span><br><span class="line">  `(</span><br><span class="line">    (either</span><br><span class="line">     manualtrigger/wait-for-manual-trigger</span><br><span class="line">     wait-for-repo)</span><br><span class="line"></span><br><span class="line">    (with-workspace</span><br><span class="line">      clone</span><br><span class="line">      (in-parallel</span><br><span class="line">       run-some-tests</span><br><span class="line">       run-smokeing-tests)</span><br><span class="line"></span><br><span class="line">      run-package</span><br><span class="line">      deploy)))</span><br></pre></td></tr></table></figure>
<p>上述的pipeline-def就是这条流水线的定义，极为优雅得是，它的代码和UI事实上构成了一一映射的关系，简单到极致。</p>
<p>值得一提的是，λCD 有别于其它同类型的工具，它本身就是一份用 Clojure 写就的微服务。换句话说，其它的工具可能需要借助基础设施即代码完成自身的安装，但λCD不用，它完全可以采用其它微服务的部署方式，比如用 λCD 部署它自己，类似于编译器的自举 (bootstraping)。这个时候，我们就需要两套 λCD 服务，一套用于部署自身，另一套部署开发中的工程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-85057d2c87c41ab1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流水线自举"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>流水线即代码是个新概念，也就意味着我们还需要花时间去探索与之相关的实践，比如，调试和测试（既然是代码就需要测试）。一旦有了这些实践，我们就可以把流水线本身作为产品放到流水线上运作起来，那时将会看到一种很好玩的现象——旧的流水线会构建并部署新流水线，完成流水线的自举 (pipeline bootstrap) 。此外，当流水线成为代码，它在最终的交付物中必然占据一席之地，其潜在的价值还等待我们挖掘，至少从精益的角度，流水线能做的事情还有很多。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>一个Java中操作字符串的类库</title>
    <url>/2017/09/06/Underscore-string-java/</url>
    <content><![CDATA[<h2 id="Underscore-string-java-是什么？"><a href="#Underscore-string-java-是什么？" class="headerlink" title="Underscore.string.java 是什么？"></a>Underscore.string.java 是什么？</h2><p><a href="https://github.com/qianyan/underscore.string.java">underscore.string.java</a> 是一个Java中方便操作字符串的类库，提供了众多帮助方法。</p>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>写过 Javascript 代码的人，估计没有几个不知道 <a href="http://underscorejs.org/">underscore</a> 这个类库的，因为它太好（有）用了，尽管现如今由于实现上不够优雅的缘故，已经被<a href="https://lodash.com/">lodash</a>所取代。而我想介绍的是 github 上 star 3000+的 <a href="https://github.com/epeli/underscore.string">underscore.string</a>，它原本是 underscore 的扩展，不过现在已经演变成独立的库。顾名思义，它的作用就是弥补 Javascript 本身对于字符串操作支持的匮乏。<br>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slugify = <span class="built_in">require</span>(<span class="string">&quot;underscore.string/slugify&quot;</span>);</span><br><span class="line"><span class="title function_">slugify</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">-&gt; hello-world</span><br></pre></td></tr></table></figure>
<p><code>slugify</code>是一种规整字符串的操作，常用于把url中的非法字符规整成 <em>word-word</em> 的模样。比如，我的这篇 blog 是通过 hexo 生成的 <code>hexo new &quot;Underscore.string.java&quot;</code>，它会自动帮我转换成 <em>2017-09-06-Underscore-string-java</em> 这样的亲和url的格式。</p>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>接触这个类库的时候，我正在使用 google <a href="https://github.com/google/guava">guava</a>，惊讶于这里头的各类操作，包括 ImmutableList、CharMatcher、Strings 等等。一来准备针对 guava 练练手，二来确实想学习一下 underscore.string 的操作，所以就开始着手写起了 <a href="https://github.com/qianyan/underscore.string.java">underscore.string.java</a> 这个项目。编写的过程中确实学到了不少平常不太可能接触到的设计方法。</p>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>这个类库已经正式发布在 Maven Central Repository. 最新版本是 <a href="http://search.maven.org/#search%7Cga%7C1%7Cunderscore.string.java">0.2.0</a>.</p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ul>
<li>java &gt;&#x3D; 1.6</li>
<li>guava 18.0</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&#x27;com.lambeta:underscore.string.java:0.2.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lambeta<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>underscore.string.java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="支持的特性"><a href="#支持的特性" class="headerlink" title="支持的特性"></a>支持的特性</h2><ul>
<li>capitalize</li>
<li>slugify</li>
<li>count</li>
<li>trim</li>
<li>ltrim</li>
<li>rtrim</li>
<li>repeat</li>
<li>decapitalize</li>
<li>join</li>
<li>reverse</li>
<li>clean</li>
<li>chop</li>
<li>splice</li>
<li>pred</li>
<li>succ</li>
<li>titleize</li>
<li>camelize</li>
<li>dasherize</li>
<li>underscored</li>
<li>classify</li>
<li>humanize</li>
<li>quote</li>
<li>unquote</li>
<li>surround</li>
<li>numberFormat</li>
<li>strRight</li>
<li>strRightBack</li>
<li>strLeft</li>
<li>strLeftBack</li>
<li>toSentence</li>
<li>truncate</li>
<li>lpad</li>
<li>rpad</li>
<li>lrpad</li>
<li>words</li>
<li>prune</li>
<li>isBlank</li>
<li>replaceAll</li>
<li>swapCase</li>
<li>naturalSort</li>
<li>naturalCmp</li>
<li>dedent</li>
<li>commonPrefix</li>
<li>commonSuffix</li>
<li>chopPrefix</li>
<li>chopSuffix</li>
<li>screamingUnderscored</li>
<li>stripAccents</li>
<li>pascalize</li>
<li>translate</li>
<li>mixedCase</li>
<li>collapseWhitespaces</li>
<li>ascii</li>
<li>chomp</li>
<li>startsWith</li>
<li>endsWith</li>
<li>levenshtein</li>
<li>hamming</li>
<li>longestCommonSubstring</li>
</ul>
<h2 id="New-Features-in-0-2-1-SNAPSHOT"><a href="#New-Features-in-0-2-1-SNAPSHOT" class="headerlink" title="New Features in 0.2.1-SNAPSHOT"></a>New Features in 0.2.1-SNAPSHOT</h2><h3 id="gradle-1"><a href="#gradle-1" class="headerlink" title="gradle"></a>gradle</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url <span class="string">&#x27;https://oss.sonatype.org/content/groups/public&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> (<span class="string">&quot;com.lambeta:underscore.string.java:0.2.1-SNAPSHOT&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="maven-1"><a href="#maven-1" class="headerlink" title="maven"></a>maven</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-repo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>sonatype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://oss.sonatype.org/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lambeta<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>underscore.string.java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>replaceZeroWidthDelimiterWith</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何高效地学习编程语言</title>
    <url>/2017/04/18/Techniques-for-Efficiently-Learning-Programming-Languages/</url>
    <content><![CDATA[<blockquote>
<p>这是Clojure好书《Clojure for the Brave and True》作者 Daniel Higginbotham 写于2017年4月16日的博文。从作者的丰富的经验来看，本文非常具有指导意义。</p>
</blockquote>
<p>学习编程语言是一种技巧：做好了，你会感受到掌握新事物之后的快感（dopamine：多巴胺）；做不好，就会接二连三的沮丧，甚至放弃。下面这些学习编程语言的最佳技巧是我从多年的<a href="http://www.braveclojure.com/">著书</a><a href="http://www.flyingmachinestudios.com/programming/the-unofficial-guide-to-rich-hickeys-brain/">写作</a>，<a href="https://www.youtube.com/watch?v=eRq5UBx6cbA">演讲</a>和<a href="http://www.braveclojure.com/training/">培训</a>中总结出来的。这里头很多技巧来源于对高效学习前沿研究做了解释的书籍。你可以在 <a href="http://www.communitypicks.com/r/learnprogramming">Community Picks Learn Programming</a> 中找到那些书（还有其它牛x的编程书籍）。</p>
<h2 id="持续测试自己以抵抗胜任力错觉"><a href="#持续测试自己以抵抗胜任力错觉" class="headerlink" title="持续测试自己以抵抗胜任力错觉"></a>持续测试自己以抵抗胜任力错觉</h2><p>最不济的学习方法中的一种就是重读或者重看材料。这种重复会给你一种感觉——似乎不用花什么气力，你就理解了话题所涵盖的内容。研究者们把这种现象称作胜任力错觉。</p>
<p>更好的一种方式（你可以掌握的最佳技巧之一）则是持续地测试自己。不要重读一个函数、类或者一个对象是什么，而是让自己定义这些概念或者把它们用到短小的程序当中——强迫你用某种方式显示自己的理解。这一过程常常很不舒服的，但是对形成长期记忆非常有效。更进一步，你可以在阅读材料之前先去行测试，举个例子，尝试在阅读一个章节之前做做练习。值得一提的是，这也被证明有助于记忆的形成。</p>
<p>测试对于学习的显著影响被称为<strong>测试效用</strong>，下面是一些具体方法可以利用：</p>
<ul>
<li>在阅读章节或者看视频之前，尝试猜测你将要学习的东西，并写下来。</li>
<li>在阅读章节之前先做做这个章节的练习题。</li>
<li>一直做练习，即使是最难的那些。暂时（永远）放弃一个练习也是可以的，不过至少要尝试一遍。（下个章节会详细谈到）</li>
<li>阅读短小的程序并且尝试不看源码重新写一个。或者，再小一些，写个函数也行。</li>
<li>在学习了对象、类、方法或者高阶函数等新概念之后，立即编码做示例。</li>
<li>创建阐述这些概念的图示，以及这些概念之间的区别和联系。</li>
<li>把你刚刚学到的概念写成博客。</li>
<li>尝试把概念解释给非技术的朋友听。（在写《Clojure for Brave and True》的时候，我常常这么干。这样能够以外行的话阐述一个想法，进而迫使你深入理解想法本身。）</li>
</ul>
<p>这些技巧的大部分都要规约到编写代码上！说到编程，由于程序都是重文本和概念性的，所以很容易以为我们仅仅通过阅读（代码）就在学习。但是程序同时也是一门手艺，就像其它手艺一样你得操练才能娴熟。编码是暴露你对程序作有错误假设的最佳方式。你越快地这么做，就会越快地纠正错误和提升技能。</p>
<p>如果你想了解更多测试效应的事情，敬请查看<a href="http://www.communitypicks.com/r/learnprogramming/s/17592186047889-make-it-stick-the-science-of-successful-learning">坚持：成功学习的科学（make it stick： The Science of Successful Learning）</a>。</p>
<h2 id="花时间放空自己"><a href="#花时间放空自己" class="headerlink" title="花时间放空自己"></a>花时间放空自己</h2><p>如果你纠结在一个问题上，或者对刚才读到的东西不能理解，就去散散步甚或洗个澡 —— 只要能进入一种舒缓、放空的状态就行。解除障碍的最佳方式之一就是歇一会儿，这可能听上去有点反直觉，但确实如此。</p>
<p>问题是，当全神贯注解决问题时，我们很容易陷入思维障碍（mental blinder）。我的意思是，这差不多就是“关注”（字面上）的意思。不过，全神贯注会导致我们只能一直探索解决方案空间的一小部分。一旦放空，我们的潜意识就可以探索并联结我们经验中的广泛领域。</p>
<p>对我来说，这就像当你试图在纸质地图上找到一个目的地（是否还记得？）。你不用刻意就确信你想抵达的城市应该就在这里！在地图的左上角的区域，所以你看了一遍又一遍，都没有成功。然后你放下地图，做了深呼吸并让目光游离了一会儿。当你重新看地图时，确切的地点立马映入眼帘。</p>
<p>我们曾经都有过这样的经验，在洗澡的时候突发灵感。现在你对于为什么这么做有了更好的了解，那么也就能刻意地使用这个技巧。个人来讲，如果纠结在某事上，我真的会洗个澡，这个技巧的功效显著。另一方面，我又是多么干净（注：洗澡这件事）。</p>
<p>如果你想多学一些关于思考的关注和分散模式，敬请查看<a href="http://www.communitypicks.com/r/learnprogramming/s/17592186047884-a-mind-for-numbers-how-to-excel-at">A Mind for Numbers: How to Excel at Math and Science (Even If You FLunked Algebra)</a></p>
<h2 id="别浪费时间沮丧"><a href="#别浪费时间沮丧" class="headerlink" title="别浪费时间沮丧"></a>别浪费时间沮丧</h2><p>和上一个章节相关：别浪费时间为代码沮丧了。沮丧会让我们做一些愚蠢的事情，比如重新编译或者重刷浏览器，期望这次会有所不同。</p>
<p>把沮丧看作你的知识有差距的信号。一旦你意识到自己沮丧了，它可以帮你后退一步，清晰地识别问题。如果你写的代码不起作用，坦率地向自己或者别人说明你期望的结果。使用科学的方法，就非预期行为的根因提出一个假说。然后测试你的假说。再次试验后，如果依然解决不了，就把这个问题放到一边，待会儿回来。</p>
<p>在一些似乎没法解决的问题上，我不知有多少次恼怒地扔掉了自己的笔记本电脑。隔天再看，一个显而易见的解决方案立马跳入脑海。甚至上周就发生过。</p>
<h2 id="确认你正在处理语言的哪个方面"><a href="#确认你正在处理语言的哪个方面" class="headerlink" title="确认你正在处理语言的哪个方面"></a>确认你正在处理语言的哪个方面</h2><p>个人观点，我觉得记住这些是有用的——当学习一门编程语言的时候，你实际上正在学四件事情。</p>
<ul>
<li>怎么写代码：语法、语义以及资源管理</li>
<li>语言的范式：面向对象，函数式，逻辑等</li>
<li>产出物的生态圈：如何构建、运行可执行文件以及如何使用库</li>
<li>工具：编辑器，编译器，调试器，代码质量检测器（linter）</li>
</ul>
<p>这四项很容易搞混，不幸的结果是，当你遇到问题最终完全找错了地方。</p>
<p>举个例子，某些完全的编程新手，可能准备开始构建iOS应用。他们可能会试着让自己的应用在朋友的手机上运行，只看得到有关需要开发人员证书或其他信息的消息。这是产出物生态圈的一部分，不过小白可能将此视为编写代码的问题。他们可能会浏览自己写的每行代码来尝试解决问题，尽管问题和代码没有半毛钱关系。</p>
<p>如果我系统地处理这些方面，我会发现学习一种语言会更加容易。我将在其它的博客文章中罗列一些待回答的宽泛问题的列表，应该能帮助你学习任何语言。</p>
<h2 id="明确目的，外部模型，内部模型"><a href="#明确目的，外部模型，内部模型" class="headerlink" title="明确目的，外部模型，内部模型"></a>明确目的，外部模型，内部模型</h2><p>任何时候你学习使用新工具，明确学习的目的，外部模型和内部模型都是十分有用的。</p>
<p>当你了解了工具的目的时，你的大脑会加载有用的上下文细节，使你更容易吸收新知识。这就好比拼图：当你看到完整拼图之后，更容易把各部件拼到一起。这个道理适用于语言本身以及语言库。</p>
<p>工具的外部模型就是它呈现出来的接口以及它想让你思考问题解决的方式。Clojure 的外部模型就是一个 Lisp，它想让你把编程当做大部分以数据为中心，不可变的转换过程。Ansible 希望你把服务器的整备工作想成定义最终状态，而不是定义抵达那种状态所要采取的步骤。</p>
<p>工具的内部模型就是如何将输入到其接口转换成一些底层的抽象。Clojure 把 Lisp 转换成 JVM 的字节码。Ansible 把任务定义转换成了 shell 命令。在一个理想国中，你不需要理解工具的内部模型，但事实上，理解内部模型总是有用的，因为在某些看上去迷惑或者矛盾的部分，它可以让你有个统一视图。举个例子，当 DNA 双螺旋模型被发现的时候，它帮助科学家们了解更高层次的现象。从我的角度来讲，当然，这篇博文也是历来所有伟大科学成就之一。</p>
<p>很多教程经常混淆工具的外部和内部模型，使学习者感到困惑。意识到这点可以帮你轻松辨别何时你会感到沮丧。</p>
<h2 id="间隔重复帮助记忆"><a href="#间隔重复帮助记忆" class="headerlink" title="间隔重复帮助记忆"></a>间隔重复帮助记忆</h2><p>间隔重复被证明是长期记忆中新信息编码的最佳方法之一。 这个想法是以不断增加的时间间隔来测验自己，使用最少重复次数来最小化记忆衰减。 卫报写了一篇<a href="https://www.theguardian.com/education/2016/jan/23/spaced-repetition-a-hack-to-make-your-brain-store-information">很好的介绍性文章</a>。</p>
<h2 id="睡眠和练习"><a href="#睡眠和练习" class="headerlink" title="睡眠和练习"></a>睡眠和练习</h2><p>保重身体！身体可不仅仅是你脑袋的载体。如果你想保持专注和高效的学习，就要足够的睡眠和练习，而不是（原文：beats the pants off）狂饮咖啡因和能量饮料。</p>
<h2 id="更多小贴士"><a href="#更多小贴士" class="headerlink" title="更多小贴士"></a>更多小贴士</h2><p>如果你还有其它有用的技巧，请不吝评论！如果你想知道更多关于学习编程的优质资源，敬请查看<a href="http://www.communitypicks.com/r/learnprogramming">Community Picks: Learn Programming</a>，这是一个社区策划编程学习书籍的收集活动，内容广泛，包含入门编程，工艺以及关于软技能和面试方面的书籍。</p>
<hr>
<p>原文链接<br>[1] <a href="http://www.flyingmachinestudios.com/programming/learn-programming-languages-efficiently/">Techniques for Efficiently Learning Programming Languages</a></p>
]]></content>
      <categories>
        <category>Clojure</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在SpringBootTest中启用不同的profiles</title>
    <url>/2017/04/27/How-to-active-different-profiles-in-SpringBootTest/</url>
    <content><![CDATA[<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul>
<li>测试类标注@ActiveProfiles(resolver &#x3D; ProfilesResolver.class)</li>
<li>自定义类 ProfilesResolver 实现接口 ActiveProfilesResolver，并实现接口中唯一的方法<code>resolve(Class&lt;?&gt; targetClass)</code></li>
<li>maven-surefire-plugin 插件中配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;systemPropertyVariables&gt;</span><br><span class="line">    &lt;spring.profiles.active&gt;$&#123;spring.profiles.active&#125;&lt;/spring.profiles.active&gt;</span><br><span class="line">&lt;/systemPropertyVariables&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>实现如下：</p>
<h3 id="1-标注启用"><a href="#1-标注启用" class="headerlink" title="1. 标注启用"></a>1. 标注启用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes = &#123;PetstoreApp.class&#125;, // 我们的 application 名为 PetstoreApp</span><br><span class="line">    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line">@ActiveProfiles(resolver = ProfilesResolver.class)</span><br><span class="line">public abstract class BaseResourceTest &#123;</span><br><span class="line">    @BeforeClass</span><br><span class="line">    public static void setUp() &#123;</span><br><span class="line">        String activeProfiles = System.getProperty(&quot;spring.profiles.active&quot;);</span><br><span class="line">        System.out.println(String.format(&quot;Resource Tests resolved profiles are [%s]&quot;, activeProfiles));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类存在的意义就是为了让其它类别的 ResourceTest 继承它，并在一次启动当中运行完所有的集成测试。避免每个 ResourceTest 都初始化启动 Application，造成运行速度变慢。</p>
<p><strong>注意<code>abstract</code>关键字</strong><br>如果不使用<code>abstract</code>关键字，那么maven-surefire-plugin就会抛出如下错误：</p>
<blockquote>
<p>Tests in error:<br>  BaseResourceTest.initializationError »  No runnable methods</p>
</blockquote>
<h3 id="2-实现自定义类-ProfilesResolver，如下："><a href="#2-实现自定义类-ProfilesResolver，如下：" class="headerlink" title="2. 实现自定义类 ProfilesResolver，如下："></a>2. 实现自定义类 ProfilesResolver，如下：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.test.context.ActiveProfilesResolver;</span><br><span class="line"></span><br><span class="line">public class ProfilesResolver implements ActiveProfilesResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] resolve(Class&lt;?&gt; aClass) &#123;</span><br><span class="line">        String activeProfiles = System.getProperty(&quot;spring.profiles.active&quot;);</span><br><span class="line"></span><br><span class="line">        return new String[] &#123;activeProfiles != null ? activeProfiles : &quot;local&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里表示我们会从系统变量当中读取<em>spring.profiles.active</em>，但是这个变量从什么地方来呢？<br>我首先想到的是 maven 的 profiles 中设置 properties，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;profile&gt;</span><br><span class="line">        &lt;id&gt;local&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;spring.profiles.active&gt;local&lt;/spring.profiles.active&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">&lt;/profile&gt;</span><br></pre></td></tr></table></figure>
<p>如此，当我们在命令行中运行<code>mvn test -Plocal</code>的时候，就表明启用了 local 这个 profile。相应地，在 maven 的上下文当中，<em>spring.profiles.active</em>变量的值就是<em>local</em>。</p>
<p>但是运行测试的时候，我们 ProfilesResolver 中的<code> System.getProperty(&quot;spring.profiles.active&quot;)</code>返回的始终是<code>null</code>。其实道理很简单，maven 中定义的 properties 全是给 maven 自己（包含各类插件）用的，它并不会<strong>传递</strong>给应用程序使用。</p>
<p><strong>注意：</strong></p>
<hr>
<p>properties 中定义的 spring.profiles.active 其实主要是给插件 maven-resources-plugin 使用的，具体请参看备注。</p>
<hr>
<h3 id="3-定义systemPropertyVariables"><a href="#3-定义systemPropertyVariables" class="headerlink" title="3. 定义systemPropertyVariables"></a>3. 定义<code>systemPropertyVariables</code></h3><p>所以我们需要定义<code>systemPropertyVariables</code>，顾名思义，这是系统变量的定义，在应用程序中就可以使用<code>System.getProperty(&quot;spring.profiles.active&quot;)</code>获得。</p>
<p>放在哪里合适呢？跑测试的插件中最合适！</p>
<p>所以，我们有如下的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;runOrder&gt;alphabetical&lt;/runOrder&gt;</span><br><span class="line">    &lt;systemPropertyVariables&gt;</span><br><span class="line">        &lt;spring.profiles.active&gt;$&#123;spring.profiles.active&#125;&lt;/spring.profiles.active&gt;</span><br><span class="line">    &lt;/systemPropertyVariables&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结合上面 properties 的配置，当我们再次运行<code>mvn test -Plocal</code>的时候，就会得到一个名为<em>spring.profiles.active</em>的系统变量，它的值由<code>$&#123;spring.profiles.active&#125;</code>决定。此处，就是local。</p>
<hr>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p><strong>properties 中 spring.profiles.active 的另外用途</strong><br>只要 maven 的 properties 中定义了 <em>spring.profiles.active</em> ，运行<code>mvn spring-boot:run -Plocal</code>的时候，spring boot 就会启用<code>applicaiton-local.yml</code> profile 文件。</p>
<p>为什么会这样的呢？按常理推断，应该是<em>spring-boot-maven-plugin</em>的配置项自动读取了我们设置的 properties <code>spring.profiles.active</code>，但是只要看一眼这个插件的<a href="http://docs.spring.io/spring-boot/docs/current/maven-plugin/run-mojo.html#profiles">文档</a>就会发现，除非显式地在插件的<em>configuration</em>下配置了<em>profiles</em>参数或者手动传入<em>run.profiles</em>系统变量<a href="http://docs.spring.io/spring-boot/docs/current/maven-plugin/examples/run-profiles.html">example</a>，否则插件本身（可以像我一样扫一眼插件的<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-tools/spring-boot-maven-plugin/src/main/java/org/springframework/boot/maven/AbstractRunMojo.java">源码</a>）并无法感知到底启用 spring 的哪个 profile！所以这个假设不成立。</p>
<p><strong>答案在<em>bootstrap.yml</em>当中！</strong><br>以下是<em>resources&#x2F;config&#x2F;bootstrap.yml</em>中的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: petstore</span><br><span class="line">    profiles:</span><br><span class="line">        # The commented value for `active` can be replaced with valid Spring profiles to load.</span><br><span class="line">        # *注意底下这句话*</span><br><span class="line">        # Otherwise, it will be filled in by maven when building the WAR file</span><br><span class="line">        # Either way, it can be overridden by `--spring.profiles.active` value passed in the commandline or `-Dspring.profiles.active` set in `JAVA_OPTS`</span><br><span class="line">        active: #spring.profiles.active#</span><br></pre></td></tr></table></figure>
<p>这里的注释很有用，明确地告诉我们在构建 WAR 包的时候，maven 会帮我们把<code>#spring.profiles.active#</code>替换成真正的值。</p>
<p>这又是怎么做到的呢？一切归功于<em>maven-resources-plugin</em>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;maven-resources-plugin.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;default-resources&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;validate&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;copy-resources&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;</span><br><span class="line">                &lt;useDefaultDelimiters&gt;false&lt;/useDefaultDelimiters&gt;</span><br><span class="line">                &lt;delimiters&gt;</span><br><span class="line">                    &lt;delimiter&gt;#&lt;/delimiter&gt; &lt;!-- 看这里 --&gt;</span><br><span class="line">                &lt;/delimiters&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;directory&gt;src/main/resources/&lt;/directory&gt;</span><br><span class="line">                        &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">                        &lt;includes&gt;</span><br><span class="line">                            &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">                            &lt;include&gt;**/*.yml&lt;/include&gt;</span><br><span class="line">                        &lt;/includes&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;directory&gt;src/main/resources/&lt;/directory&gt;</span><br><span class="line">                        &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">                        &lt;excludes&gt;</span><br><span class="line">                            &lt;exclude&gt;**/*.xml&lt;/exclude&gt;</span><br><span class="line">                            &lt;exclude&gt;**/*.yml&lt;/exclude&gt;</span><br><span class="line">                        &lt;/excludes&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                &lt;/resources&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>这个插件除了简单的 copy 功能之外，还能进行 <em>Filtering</em> <a href="https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html">操作</a>。</p>
<blockquote>
<p>Filtering<br>Variables can be included in your resources. These variables, denoted by the ${…} delimiters, can come from the system properties, your project properties, from your filter resources and from the command line.</p>
</blockquote>
<p>大意是说，你可以在 resources 文件定义自己的变量，这些变量可以来自系统属性、maven 工程属性，你过滤的 resources 文件和命令行。</p>
<p>说白了，就是在 copy 资源文件的时候，同时帮你把文件中的变量（占位符）替换成真实的值。而这里就是通过<code>&lt;delimiter&gt;#&lt;/delimiter&gt;</code>来规定变量格式的！换句话说，在文件中只要是以<code>#</code>开头和结尾的字符串都会被替换掉（变量有定义的情况下；否则保持原样）。</p>
<p>这里，由于绑定了生命周期——validate，可以直接运行<code>mvn validate -Plocal</code>这样的命令进行快速验证。得到的<em>bootstrap.yml</em>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: petstore</span><br><span class="line">    profiles:</span><br><span class="line">        # The commented value for `active` can be replaced with valid Spring profiles to load.</span><br><span class="line">        # Otherwise, it will be filled in by maven when building the WAR file</span><br><span class="line">        # Either way, it can be overridden by `--spring.profiles.active` value passed in the commandline or `-Dspring.profiles.active` set in `JAVA_OPTS`</span><br><span class="line">        active: dev # 替换成功</span><br></pre></td></tr></table></figure>

<p>回到最开始的疑问，为什么只要 maven 的 properties 中定义了 <em>spring.profiles.active</em> ，运行<code>mvn spring-boot:run -Plocal</code>的时候，就可以spring boot 就会启用<code>applicaiton-local.yml</code> profile 文件呢？</p>
<p>因为，maven 在运行命令之前已经做了 copy-resources 的操作，那时候就已经把<em>bootstrap.yml</em>中的<em>spring.profiles.active</em>替换成 local 了，所以启动 springboot application 的时候，它会启用<em>spring.profiles.active</em>代表的值，此处就是 local，那么启用的文件自然就是<em>application-local.yml</em>。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何发布jar到clojars</title>
    <url>/2017/09/17/release-jar-to-clojars/</url>
    <content><![CDATA[<h2 id="Clojars-介绍"><a href="#Clojars-介绍" class="headerlink" title="Clojars 介绍"></a>Clojars 介绍</h2><p>Clojars 是一个为开源 Clojure 类库打造的仓库，截止2017年9月17日，大概有19831个项目发布在上面。整个网站也是用 Clojure 编写的。</p>
<h2 id="发布-Clojure-library"><a href="#发布-Clojure-library" class="headerlink" title="发布 Clojure library"></a>发布 Clojure library</h2><h3 id="1-注册-clojars"><a href="#1-注册-clojars" class="headerlink" title="1. 注册 clojars"></a>1. 注册 clojars</h3><p>前往 <a href="https://clojars.org/register">clojars</a> 注册</p>
<h3 id="2-lein-部署"><a href="#2-lein-部署" class="headerlink" title="2. lein 部署"></a>2. lein 部署</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lein deploy clojars # lein deploy [repository name], here the repo name is clojars.</span><br></pre></td></tr></table></figure>
<p>如果不想加上 <code>clojars</code> 参数，则需要在当前项目下的 <em>project.clj</em> 添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;:deploy-repositories [[&quot;releases&quot; :clojars]</span><br><span class="line">                       [&quot;snapshots&quot; :clojars]]&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里注意一点：</strong><br>这里使用 <code>:deploy-repositories</code> 而非 <code>:repositories</code>，原因是 <code>:repositories</code> 除了用于部署还会作为依赖源被项目使用。所以，如若必要，还是职责单一点好。这样，也可以加入 <em>:user profile (~&#x2F;.lein&#x2F;profiles.clj)</em> 供所有本地项目发布使用。</p>
<p>这个时候可以执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lein deploy</span><br><span class="line">No credentials found for snapshots(did you mean `lein deploy clojars`?) </span><br><span class="line"># 这里应该是 leiningen 的 bug，提示信息 `lein deploy clojars` 显得很奇怪，可以忽略之。</span><br><span class="line">See `lein help deploying` for how to configure credentials to avoid prompts.</span><br><span class="line">Username: username</span><br><span class="line">Password: password</span><br></pre></td></tr></table></figure>
<p>如上，这时会弹出用户名和密码输入框。为了节省时间，避免每次输入，最好把用户凭证 (credentials) 以文件的形式存放到用户范围的目录下，即*~&#x2F;.lein&#x2F;credentials.clj*，并做加密处理。</p>
<h3 id="3-设置全局的-credentials-map"><a href="#3-设置全局的-credentials-map" class="headerlink" title="3. 设置全局的 credentials map"></a>3. 设置全局的 credentials map</h3><p>首先，把如下的 credentials map 写入 <em>~&#x2F;.lein&#x2F;credentials.clj</em></p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;<span class="regex">#&quot;https://clojars.org/repo&quot;</span> &#123;<span class="symbol">:username</span> <span class="string">&quot;username_on_clojars&quot;</span> <span class="symbol">:password</span> <span class="string">&quot;password_on_clojars&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>其次，使用 gpg 加密该文件</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">$ gpg --default-recipient-self -e \</span><br><span class="line">    ~/.lein/credentials.clj &gt; ~/.lein/credentials.clj.gpg</span><br></pre></td></tr></table></figure>
<p>加密后，即可删除原文件 <em>~&#x2F;.lein&#x2F;credentials.clj</em>。然后在<code>:deploy-repositories</code> map 中指定 <code>:creds :gpg</code></p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;<span class="symbol">:deploy-repositories</span> [[<span class="string">&quot;releases&quot;</span> <span class="symbol">:clojars</span></span><br><span class="line">                        <span class="symbol">:creds</span> <span class="symbol">:gpg</span>]]</span><br><span class="line">                       [<span class="string">&quot;snapshots&quot;</span> <span class="symbol">:clojars</span></span><br><span class="line">                        <span class="symbol">:creds</span> <span class="symbol">:gpg</span>]]&#125;</span><br></pre></td></tr></table></figure>
<p>完成上述，<code>lein deploy</code> 的时候即可解密 <code>~/.lein/credentials.clj.gpg</code>，从中获取对应仓库的<code>username</code>和<code>password</code>（<strong>注：</strong>为了便于索引查找，credentials 使用正则表达式 #”<a href="https://clojars.org/repo">https://clojars.org/repo</a>“ 作为 key）</p>
<h2 id="Error-gpg-agent-timeout"><a href="#Error-gpg-agent-timeout" class="headerlink" title="Error: gpg agent timeout"></a>Error: gpg agent timeout</h2><p>有时候，deploy 时会出现 gpg agent 超时的错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lein deploy</span><br><span class="line">gpg: problem with the agent: Timeout</span><br><span class="line">gpg: decryption failed: No secret key</span><br><span class="line">Could not decrypt credentials from /Users/qianyan/.lein/credentials.clj.gpg</span><br><span class="line">nil</span><br><span class="line">See `lein help gpg` for how to install gpg.</span><br></pre></td></tr></table></figure>
<p>仔细搜索<a href="https://github.com/technomancy/leiningen/blob/master/doc/DEPLOY.md#gpg">文档</a>会发现下面这句很重要的话</p>
<blockquote>
<p>Due to a bug in gpg you currently need to use gpg-agent and have already unlocked your key before Leiningen launches, but with gpg-agent you only have to enter your passphrase periodically; it will keep it cached for a given period.</p>
</blockquote>
<p>大意是，leiningen 需要用到 gpg-agent，而且在 <code>lein deploy</code> 之前，就应该解锁密钥。</p>
<p>不实际操作的话，还是很难弄懂这句话具体的指代。我们不妨思考一下。</p>
<h3 id="1-看看后台是否有个进程叫做-gpg-agent？"><a href="#1-看看后台是否有个进程叫做-gpg-agent？" class="headerlink" title="1. 看看后台是否有个进程叫做 gpg-agent？"></a>1. 看看后台是否有个进程叫做 gpg-agent？</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef |grep gpg</span></span><br><span class="line">  501 87095     1   0  8:27PM ??         0:00.00 gpg-agent --daemon</span><br></pre></td></tr></table></figure>
<p>嗯，还真有！</p>
<h3 id="2-gpg-直接解密-credentials-clj-gpg"><a href="#2-gpg-直接解密-credentials-clj-gpg" class="headerlink" title="2. gpg 直接解密 credentials.clj.gpg"></a>2. gpg 直接解密 credentials.clj.gpg</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --decrypt ~/.lein/credentials.clj.gpg</span></span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Yan Qian (lambeta) &lt;qianyan.lambda@gmail.com&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID E13DFD8A, created 2016-05-14 (main key ID 3C5030FF)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来，漫无止境的等待中...</span></span><br></pre></td></tr></table></figure>
<p>这奇怪的等待让我不安，所以我使出了杀手锏 <code>kill -9</code>，直接把 gpg-agent 干掉。</p>
<h3 id="3-重新-gpg-–decrypt"><a href="#3-重新-gpg-–decrypt" class="headerlink" title="3. 重新 gpg –decrypt"></a>3. 重新 gpg –decrypt</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --decrypt ~/.lein/credentials.clj.gpg</span></span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Yan Qian (lambeta) &lt;qianyan.lambda@gmail.com&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID E13DFD8A, created 2016-05-14 (main key ID 3C5030FF)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里要输入 passphrase</span></span><br><span class="line">gpg: encrypted with 2048-bit RSA key, ID E13DFD8A, created 2016-05-14</span><br><span class="line">      &quot;Yan Qian (lambeta) &lt;qianyan.lambda@gmail.com&gt;&quot;</span><br><span class="line">&#123; #&quot;https://clojars.org/repo&quot; &#123;:username &quot;username_on_clojars&quot; :password &quot;password_on_clojars&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>终于可以输入 passphrase 了，解密完成。这大概就是上面引文所说的 unlock your key before Leiningen launches.</p>
<h3 id="4-重新部署"><a href="#4-重新部署" class="headerlink" title="4. 重新部署"></a>4. 重新部署</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lein deploy</span></span><br><span class="line">Created /Users/qianyan/Projects/clojure-pr/clj-moco/target/clj-moco-0.1.0-SNAPSHOT.jar</span><br><span class="line">Wrote /Users/qianyan/Projects/clojure-pr/clj-moco/pom.xml</span><br><span class="line">Retrieving clj-moco/clj-moco/0.1.0-SNAPSHOT/maven-metadata.xml</span><br><span class="line">    from https://clojars.org/repo/</span><br><span class="line">Sending clj-moco/clj-moco/0.1.0-SNAPSHOT/clj-moco-0.1.0-20170917.122837-4.jar (10k)</span><br><span class="line">    to https://clojars.org/repo/</span><br><span class="line">Sending clj-moco/clj-moco/0.1.0-SNAPSHOT/clj-moco-0.1.0-20170917.122837-4.pom (3k)</span><br><span class="line">    to https://clojars.org/repo/</span><br><span class="line">Retrieving clj-moco/clj-moco/maven-metadata.xml</span><br><span class="line">    from https://clojars.org/repo/</span><br><span class="line">Sending clj-moco/clj-moco/0.1.0-SNAPSHOT/maven-metadata.xml (1k)</span><br><span class="line">    to https://clojars.org/repo/</span><br><span class="line">Sending clj-moco/clj-moco/maven-metadata.xml (1k)</span><br><span class="line">    to https://clojars.org/repo/</span><br></pre></td></tr></table></figure>
<p>没有出现 gpg-agent timeout 的错误，部署完成。</p>
<hr>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--default-recipient-self</span><br><span class="line">    Use the default key as default recipient if option --recipient is not used and don’t ask if this is a valid one.</span><br><span class="line">    The default key is the first one from the secret keyring or the one set with --default-key.</span><br></pre></td></tr></table></figure></h2><p>参考链接<br>[1] <a href="https://github.com/technomancy/leiningen/blob/master/doc/DEPLOY.md">Leiningen Deployment</a><br>[2] <a href="https://www.gnupg.org/documentation/manuals/gnupg-devel/GPG-Configuration-Options.html#GPG-Configuration-Options">GPG: How to change the configuration</a></p>
]]></content>
      <categories>
        <category>Clojure</category>
      </categories>
      <tags>
        <tag>leiningen</tag>
      </tags>
  </entry>
  <entry>
    <title>如何发布Jar包到Maven Central Repository</title>
    <url>/2017/09/15/release-jar-to-maven-central-repository/</url>
    <content><![CDATA[<h2 id="太长不读篇"><a href="#太长不读篇" class="headerlink" title="太长不读篇"></a>太长不读篇</h2><ol>
<li>在 <a href="https://issues.sonatype.org/secure/Signup!default.jspa">issues tracker</a> 上注册</li>
<li>创建 <a href="https://issues.sonatype.org/browse/OSSRH-33944">issues</a></li>
<li>配置 <a href="https://github.com/qianyan/underscore.string.java/blob/master/build.gradle">build.gradle</a></li>
<li>gpg 生成 key pair 以便签名</li>
<li>上传 Release Archive</li>
<li>关闭并验证 <a href="https://oss.sonatype.org/">Staging 环境</a>的 Archive</li>
<li>发布 Archive</li>
<li>通知 issue 管理员开启同步</li>
</ol>
<h2 id="细读篇"><a href="#细读篇" class="headerlink" title="细读篇"></a>细读篇</h2><h3 id="1-注册"><a href="#1-注册" class="headerlink" title="1. 注册"></a>1. 注册</h3><p>Maven Central 网站并不提供注册的功能，你需要到 Sonatype 网站上进行注册。而事实上，Sonatype 网站也没有直接提供一个注册链接。真正的注册入口在 <a href="https://issues.sonatype.org/secure/Signup!default.jspa">issues tracker</a> 上。一旦完成注册后，你需要创建包含待发布包信息的 issue。</p>
<h3 id="2-创建-issue"><a href="#2-创建-issue" class="headerlink" title="2. 创建 issue"></a>2. 创建 issue</h3><p><img src="http://upload-images.jianshu.io/upload_images/217988-502c1f4fc580c120.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建 issues"><br>在 Sonatype 的 <a href="https://issues.sonatype.org/secure/Dashboard.jspa">dashboard</a> 上点击创建按钮，根据弹出框的提示，填写简介、描述、GroupId、Project URL、SCM url 以及你在 jira 上的用户名。创建完毕后，会被自动跳转到该 issue 的详情页并分配一个唯一的ID，如：OSSRH-33944。余下的时间只需要等待，一般在两个工作日之内，Sonatype 的工作人员就会着手处理，然后他会在该 issue 底下的评论区留言。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-29e35a58393f39ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建成功的 issue"></p>
<p>如果代码是托管在 github 上，按照惯例，GroupId 应该取 github 上的域名，比如：com.github.qianyan。不过，这里我预备上传的包的 GroupId 是 com.lambeta，这是我购买的域名。审核者对此有所顾虑，所以很贴心地留言如下：</p>
<blockquote>
<p>Do you own the domain lambeta.com? If not, please read:<br><a href="http://central.sonatype.org/pages/choosing-your-coordinates.html">http://central.sonatype.org/pages/choosing-your-coordinates.html</a><br>You may also choose a groupId that reflects your project hosting, in this case, something like io.github.qianyan or com.github.qianyan</p>
</blockquote>
<p>在回复这个域名确实为我所有之后，工作人员就贴出不同环境的仓库地址。</p>
<blockquote>
<p>Configuration has been prepared, now you can:<br>Deploy snapshot artifacts into repository <a href="https://oss.sonatype.org/content/repositories/snapshots">https://oss.sonatype.org/content/repositories/snapshots</a><br>Deploy release artifacts into the staging repository <a href="https://oss.sonatype.org/service/local/staging/deploy/maven2">https://oss.sonatype.org/service/local/staging/deploy/maven2</a><br>Promote staged artifacts into repository ‘Releases’<br>Download snapshot and release artifacts from group <a href="https://oss.sonatype.org/content/groups/public">https://oss.sonatype.org/content/groups/public</a><br>Download snapshot, release and staged artifacts from staging group <a href="https://oss.sonatype.org/content/groups/staging">https://oss.sonatype.org/content/groups/staging</a><br><strong>please comment on this ticket when you promoted your first release, thanks</strong></p>
</blockquote>
<p><strong>最后一句很重要</strong>，说的是，当我第一次正式发布的时候，需要留言告知工作人员，以便他们开启中央仓库的同步，这样我的包才会在 Maven Central 仓库中可见。</p>
<h3 id="3-配置项目的-build-gradle"><a href="#3-配置项目的-build-gradle" class="headerlink" title="3. 配置项目的 build.gradle"></a>3. 配置项目的 build.gradle</h3><p>拿到仓库地址，我们就需要在自己的项目中进行一些必要的配置，包含：jar、sourcesJar、javadocJar 以及对这些产物的 signing（签名）。</p>
<h4 id="maven-插件"><a href="#maven-插件" class="headerlink" title="maven 插件"></a>maven 插件</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven&#x27;</span></span><br></pre></td></tr></table></figure>
<p>maven 插件提供了 uploadArchives task，我们需要在这个 task 中配置仓库地址，以及 pom 的相关信息，因为上载到 maven 仓库的包必须要有 pom 文件，否则无法查找或被依赖。具体配置如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            beforeDeployment &#123; deployment -&gt; signing.signPom(deployment) &#125;</span><br><span class="line"></span><br><span class="line">            repository(<span class="attr">url:</span> <span class="string">&quot;https://oss.sonatype.org/service/local/staging/deploy/maven2/&quot;</span>) &#123;</span><br><span class="line">                authentication(<span class="attr">userName:</span> ossrhUsername, <span class="attr">password:</span> ossrhPassword)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            snapshotRepository(<span class="attr">url:</span> <span class="string">&quot;https://oss.sonatype.org/content/repositories/snapshots&quot;</span>) &#123;</span><br><span class="line">                authentication(<span class="attr">userName:</span> sonatypeUsername, <span class="attr">password:</span> sonatypePassword)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pom.project &#123;</span><br><span class="line">                name project.name</span><br><span class="line">                packaging <span class="string">&#x27;jar&#x27;</span></span><br><span class="line">                description <span class="string">&#x27;underscore string in java&#x27;</span></span><br><span class="line">                url <span class="string">&#x27;https://github.com/qianyan/underscore.string.java&#x27;</span></span><br><span class="line"></span><br><span class="line">                scm &#123;</span><br><span class="line">                    url <span class="string">&#x27;https://github.com/qianyan/underscore.string.java&#x27;</span></span><br><span class="line">                    connection <span class="string">&#x27;https://github.com/qianyan/underscore.string.java.git&#x27;</span></span><br><span class="line">                    developerConnection <span class="string">&#x27;git@github.com:qianyan/underscore.string.java.git&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name <span class="string">&#x27;MIT Licence&#x27;</span></span><br><span class="line">                        url <span class="string">&#x27;https://raw.githubusercontent.com/qianyan/underscore.string.java/master/LICENSE&#x27;</span></span><br><span class="line">                        distribution <span class="string">&#x27;repo&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        id <span class="string">&#x27;lambeta&#x27;</span></span><br><span class="line">                        name <span class="string">&#x27;Yan Qian&#x27;</span></span><br><span class="line">                        email <span class="string">&#x27;qianyan.lambeta@gmail.com&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应生成的 pom.xml 大致如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>underscore.string.java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>underscore string in java<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/qianyan/underscore.string.java<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>MIT Licence<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://raw.githubusercontent.com/qianyan/underscore.string.java/master/LICENSE<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>lambeta<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Yan Qian<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">email</span>&gt;</span>qianyan.lambeta@gmail.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">connection</span>&gt;</span>https://github.com/qianyan/underscore.string.java.git<span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>git@github.com:qianyan/underscore.string.java.git<span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/qianyan/underscore.string.java<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> <code>authentication(userName: ossrhUsername, password: ossrhPassword)</code> 和 <code>authentication(userName: sonatypeUsername, password: sonatypePassword)</code>，这里的用户名和密码其实就是在 Sonatype 上注册的用户名和密码。为了让 gradle 脚本顺利执行，需要在当前工程下的 gradle.properties 文件中设置对应的变量，如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">sonatypeUsername=</span><br><span class="line">sonatypePassword=</span><br><span class="line">ossrhUsername=</span><br><span class="line">ossrhPassword=</span><br></pre></td></tr></table></figure>
<p>这份文件会作为源代码的一部分提交，所以聪明的我们不会傻傻地把自己的用户名和密码 push 到 github 上面。和大部分 *nix 系统上的工具类似，gradle 也有本地配置，我们可以新建一份 gradle.properties 文件到 <code>~/.gradle/gradle.properties</code>，然后把用户名和密码写入其中。这样，实际运行时，本地配置就会覆盖项目下对应的这些变量值。</p>
<h4 id="4-设置-gpg-以签名-Archive"><a href="#4-设置-gpg-以签名-Archive" class="headerlink" title="4. 设置 gpg 以签名 Archive"></a>4. 设置 gpg 以签名 Archive</h4><p><a href="https://gnupg.org/">gpg</a> 生成的 key pair 主要是供签名使用的。假定本机已经安装 gpg，首先使用 gpg 生成 key pair。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --gen-key</span></span><br></pre></td></tr></table></figure>
<p>然后，查找你的 keyId：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --list-keys</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-&gt;</span></span><br><span class="line">pub   2048R/XXXXXX 2017-09-14 [expires: 2018-05-14]</span><br><span class="line">uid       [ultimate] Yan Qian (lambeta) &lt;qianyan.lambeta@gmail.com&gt;</span><br></pre></td></tr></table></figure>
<p>其中 XXXXXX 就是你的 keyId。接下来必须发布你的公钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --keyserver hkp://pgp.mit.edu --send-keys XXXXXX</span></span><br></pre></td></tr></table></figure>
<p>验证公钥已经发布成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --keyserver hkp://pgp.mit.edu --search-keys qianyan.lambeta@gamil.com <span class="comment"># user email address</span></span></span><br></pre></td></tr></table></figure>
<p>当然，上述操作都可以使用 <a href="https://gpgtools.org/">gpg tools</a> 在 UI 上完成。</p>
<h4 id="signing-插件"><a href="#signing-插件" class="headerlink" title="signing 插件"></a>signing 插件</h4><p>完成上述步骤之后，我们需要在 build.gradle 中添加 signing 插件及其配置，如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;signing&#x27;</span></span><br><span class="line"></span><br><span class="line">signing &#123;</span><br><span class="line">    required &#123; gradle.taskGraph.hasTask(<span class="string">&quot;uploadArchives&quot;</span>) &#125;</span><br><span class="line">    sign configurations.archives</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置明确了 gradle task 的 DAG 中必须含有 uploadArchives，之后针对 archives 进行签名。</p>
<p>signing 插件如何同 gpg 生成 key pair 交互呢？这就需要在<code>~/.gradle/gradle.properties</code>再声明三个变量，如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">signing.keyId=XXXXXX</span><br><span class="line">signing.password=your_key_pair_password</span><br><span class="line">signing.secretKeyRingFile=<span class="regexp">/Users/</span>your_name<span class="regexp">/.gnupg/</span>secring.gpg</span><br></pre></td></tr></table></figure>
<p>还剩下最后的一步，归档 Jar，sourceJar（源代码）和javadocJar（API 文档），这些是需要签名的对象。</p>
<h4 id="archive"><a href="#archive" class="headerlink" title="archive"></a>archive</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span></span><br><span class="line"></span><br><span class="line">task sourcesJar(<span class="attr">type:</span> Jar) &#123;</span><br><span class="line">    classifier = <span class="string">&#x27;sources&#x27;</span></span><br><span class="line">    from sourceSets.main.allSource</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task javadocJar(<span class="attr">type:</span> Jar, <span class="attr">dependsOn:</span> javadoc) &#123;</span><br><span class="line">    classifier = <span class="string">&#x27;javadoc&#x27;</span></span><br><span class="line">    from <span class="string">&#x27;build/docs/javadoc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives jar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">    archives javadocJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归档产物最终都会被签名，生成以 .asc 为后缀的签名文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">build/libs</span><br><span class="line">├── underscore.string.java-0.0.1-javadoc.jar</span><br><span class="line">├── underscore.string.java-0.0.1-javadoc.jar.asc</span><br><span class="line">├── underscore.string.java-0.0.1-sources.jar</span><br><span class="line">├── underscore.string.java-0.0.1-sources.jar.asc</span><br><span class="line">├── underscore.string.java-0.0.1.jar</span><br><span class="line">└── underscore.string.java-0.0.1.jar.asc</span><br></pre></td></tr></table></figure>
<p>这些产出物在最终发布的时候，需要经过验证，如果验证失败，比如：缺少 javadoc 或者某个 *.asc 文件，则不被允许发布。</p>
<h3 id="5-上传-Release-Archives"><a href="#5-上传-Release-Archives" class="headerlink" title="5. 上传 Release Archives"></a>5. 上传 Release Archives</h3><p>根据的 maven 的标准，日常开发我们会使用 snapshot 版本，如：0.0.1-SNAPSHOT；发布时，去掉后缀-SNAPSHOT，即：0.0.1。而 maven 会根据这个特点，机智地辨识是上传到 snapshotRepository 还是 releaseRepository 的。因为我们得发布包，所以修改版本为 0.0.1 之后，我们只需要简单地执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gradle uploadArchives <span class="comment"># or `gradle uA` this is a shortcut.</span></span></span><br></pre></td></tr></table></figure>
<h3 id="6-关闭并验证-Staging-环境上的-Archive"><a href="#6-关闭并验证-Staging-环境上的-Archive" class="headerlink" title="6. 关闭并验证 Staging 环境上的 Archive"></a>6. 关闭并验证 Staging 环境上的 Archive</h3><p><img src="http://upload-images.jianshu.io/upload_images/217988-c6a888ec20e93530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="staging Repo"></p>
<p>登录 Sonatype 的 <a href="https://oss.sonatype.org/">Nexus Repository Manager</a>，然后点击左边侧边栏的 Staging Repositories，搜索<code>comlambeta</code> (GroupId 去掉中间的’.’)。接下来查看 Content tab，重点检查 pom 或者签名文件是否遗漏！当确认无误后，即可关闭 (Close) 这个 Repo。关闭过程中，Nexus 会逐项检查产物是否合规，如果出现验证错误，则在 Activity tab 中显示具体失败的步骤及原因。</p>
<h3 id="7-发布-Archive"><a href="#7-发布-Archive" class="headerlink" title="7. 发布 Archive"></a>7. 发布 Archive</h3><p>如果上面的验证通过，上面本来不可用的 Release 按钮会变为可用。点击 Release 按钮，直接发布包。</p>
<h3 id="8-通知-issue-管理员开启同步"><a href="#8-通知-issue-管理员开启同步" class="headerlink" title="8. 通知 issue 管理员开启同步"></a>8. 通知 issue 管理员开启同步</h3><p>发布包之后，就可以通知管理员开启同步。我在原来的 issue 的评论区留言：</p>
<blockquote>
<p>I have a first release version 0.0.1 for this library.</p>
</blockquote>
<p>很快地，管理员就回复同步已经开启：</p>
<blockquote>
<p>Central sync is activated for com.lambeta. After you successfully release, your component will be published to Central, typically within 10 minutes, though updates to search.maven.org can take up to two hours.</p>
</blockquote>
<p>不过，由于当时所用 gradle2.1 的版本，导致了上传时 pom 文件被遗漏，在 search.maven.org 中搜索不到。管理员很热心地解释了这个现象：</p>
<blockquote>
<p>search.maven.org needs a valid POM file to be a part of your uploaded artifacts. Browsing Maven Central directly:<br><a href="http://repo1.maven.org/maven2/com/lambeta/underscore.string.java/0.0.1/">http://repo1.maven.org/maven2/com/lambeta/underscore.string.java/0.0.1/</a><br>it appears that a POM file is missing.</p>
</blockquote>
<p>遂升级到 3.1 版本，重新上传之后就能在 <a href="http://search.maven.org/#search%7Cga%7C1%7Ccom.lambeta">search.maven.org</a> 中看到。</p>
<h3 id="9-检查同步成功"><a href="#9-检查同步成功" class="headerlink" title="9. 检查同步成功"></a>9. 检查同步成功</h3><p>除了通过 <a href="http://search.maven.org/#search%7Cga%7C1%7Ccom.lambeta">search.maven.org</a> 检查同步是否成功之外，查询<a href="http://mvnrepository.com/search?q=com.lambeta">mvnrepository</a>也是常用的搜索方式。不过，值得一提的是，mvnrepository 相较于 search.maven.org 同步会更慢点，原因是 mvnrepository 引用了 central.maven.org 仓库。而 <code>central.maven.org == repo1.maven.org</code>，两个域名对应的 IP 是一样的，而这个 repo1.maven.org 就是默认的 Maven central repository，也就是 search.maven.org 的仓库。<br>所以，你可以在以下两个仓库看到发布包：<br><a href="http://central.maven.org/maven2/com/lambeta/underscore.string.java/">http://central.maven.org/maven2/com/lambeta/underscore.string.java/</a><br><a href="http://repo1.maven.org/maven2/com/lambeta/underscore.string.java/">http://repo1.maven.org/maven2/com/lambeta/underscore.string.java/</a></p>
<hr>
<p>参考链接<br>[1] <a href="http://zserge.com/blog/gradle-maven-publish.html">simple library publishing with gradle</a><br>[2] <a href="http://central.sonatype.org/pages/releasing-the-deployment.html">release deployment</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>系统之美</title>
    <url>/2017/11/22/thinking-in-systems/</url>
    <content><![CDATA[<p>世界是普遍联系、永恒发展的，这是我很欣赏的一名大学马原老师奉为圭臬的话，也是给我很大触动的金玉良言。世界是一个大系统，其中有纷繁复杂的事物，用独特的行为方式互相影响，或直接或间接，要么直截了当因果相连，要么兜兜转转蝴蝶效应。如果持不可知论，世界将永存混沌。系统总是比看上去复杂，但是其中玄妙又遵循因果。依照系统思考的基本原则，系统的行为总是由系统的结构决定。我们不愿意看到的很多现象，归根结底都是系统性问题，是系统的内部结构决定的行为特征。这是一个很重要的问题。我们只有正视并承认这一点才有重塑系统的勇气和可能。</p>
<p>系统结构是不胜枚举的，但是我们总可以抽象出模式（系统基模 archetypes）提取特征。不论是还原论还是整体论，只要能帮助我们分析问题都是好的理论。在分析过程中，使用还原论分解系统的元素，然后把这些元素放回原位，互相关联起来，组合勾画出系统的反馈回路。从整体论的视角重塑系统，思考反馈回路又会产生怎样的行为。系统思考的研究者将特定的、会引发特定行为的系统结构成为系统基模，常见的8种系统基模陷阱分别是<strong>政策阻力、公地悲剧、目标侵蚀、竞争升级、富者愈富、转嫁负担、规避规则和目标错位</strong>。</p>
<p>可我们不禁想问：系统思考究竟是什么？要回答上面的这个问题，首先得搞清楚系统是什么。<strong>系统是一组相关联的事物——在一定的时间内，以特定的行为相互影响。系统可能会受到外力的影响，对此产生的反馈方式就是系统的特征。</strong></p>
<p>系统思考的观察方式并不是唯一的解释系统的方式。就像康德说的，人都是戴着有色眼镜生存的，不同的观察方式或许可以突破这一层有色眼镜，使用投影的方式在多个维度综合塑造起系统的真实模样。我甚至希望自己看待同一件事物的视角是相互矛盾的，那样我才会感受到自己的认知是多么有限，这个世界是多么伟大、在有限的生命中充满怎样无限的可能。</p>
<p>从还原论的视角认知的世界是由基本要素构成的，但是系统思考则不同。它的基本理论是，系统由要素、连接，功能或目标组成。一支笔是系统，它的组成要素有笔芯、油墨、笔筒和笔头。笔筒套着笔芯，笔芯镶着笔头，油墨会沿着笔芯和笔头流淌，这就是连接。一支笔的功能可能是写字或画画，然而这些功能是很难从系统内部联想到的，必须让一只手攥住它运作起来，让油墨勾连出运动的线条，力透纸背，入木三分，才能观测出实际的功能。有时候，系统的要素是显而易见的，总能应需要分解，但是分解的粒度却是极难把握的，再加上要素可能是无形的，那么就极有可能找不出所有的要素。这个时候，把注意力转向连接则是更为明智和恰当的选择。系统连接的表现形式多种多样，可能是物质流、信息流，准入条件或约束规则，交易、交谈。在现实中，连接多表现在系列动作上，球员之间更加信任、老师给学生打分等等。如果系统中的连接发生改变，系统会受到很大的影响，此后表现出的行为和原来的行为大相径庭。而犹胜这个的，便是系统的目标或者功能发生改变。因为系统有自组织的特点，目标发生的改变会强制系统内部要素应激，最终会导致结构发生改变，从而表现出令人咂舌的行为。</p>
<p>当我们理解系统不仅仅是要素的集合，而且包含内在连接和功能或目标了之后。接下来就得接受系统是动态变化的这一事实。存量是所有系统的基础，存量是任何时候都能观察、感知、计数和测量的系统要素。<strong>存量是对系统中变化量的一种历史记录。</strong>那么也就是说存量总是会随着时间变化而改变的，而使存量发生变化的就是流量，流量可以看做瞬时的存量。一旦这样理解系统的结构，系统的动态性也就不言而喻了。存量的改变决定了系统的动态变化速度，也让系统具备了延迟性的特点——在任何环境下，系统都不会马上受影响；即使想要改变系统的行为，也需要一定的时间等待它缓慢生效。对存量的改变是通过控制流量做到的。进入的流量大于出去的流量，系统的存量就会增加；反之，会减少；最理想的情况是存量维持在一个动态的平衡状态。如果我们想要改变系统的行为，就需要找到系统流量的控制点，促进或者削弱控制点（手段），以此达成我们想要系统表现出来的行为或者趋势。</p>
<p>系统根据存量的多少，又可以分为单存量和多存量系统。单存量系统因为只有一个存量，控制点数量较少，系统内在连接较少，所以控制起来不是太难。但是即便如此，我们也要意识到由于客观规律的约束，造成流量的不恒定，系统最终态或多或少会偏离预定的值。而复杂的多存量系统，则会因为存量之间会相互施加对控制点（包括自己的控制点）的影响，变得错综复杂，难以理出头绪。所以更好的梳理方式是观察现在系统结构包含哪些行为，以及触发这些行为的条件。这有点类似知果索因的探究方式：行为就是对控制点施加的影响，而条件则是改变存量的外在表现。比如喝咖啡这样的行为。触发这个行为的条件是我困了。困了是体内能量低于正常水平的外在表现。而能量在这里可以看做存量。</p>
<h2 id="系统思考的3大特征"><a href="#系统思考的3大特征" class="headerlink" title="系统思考的3大特征"></a>系统思考的3大特征</h2><p>承认系统是美的，这是我们研究系统的动力。<em>假如一个系统整体是良好的，那么每个部分都是好的。</em></p>
<p>系统具有适应力（Resilience）的特征。适应力指的是系统在多变的环境下保持自身存在和运作的能力，与之相对的是脆弱性或刚性。或者用KK的话说，适应力就是反脆弱性。面对周遭环境的不确定性，系统会表现出短期振荡、阶段性发作和周期性兴衰，适应力会参与其中让系统振荡收敛，复原。在系统正常运行的情况下，适应力是很难被察觉到的，而系统的稳定程度则比较容易统计出来。适应力在系统超出限度，调节回路被破坏，要素被分解的情况下才能被观察。这也就要求我们在设计系统的时候，不仅要考虑到系统正常运行时的指标，也要考虑到极端情况下，系统自我恢复的能力。系统的适应力不是凭空产生的，它是多个调节回路共同影响之下出现的结果。而且复杂的系统一般都有元调节回路（meta-resilience），甚至是元元调节回路（metameta-resilience），这就让系统具备了很强的自组织能力。</p>
<p>系统的第二个特征就是自组织（Self-orgnization）。自组织指的是系统让自己更为复杂化的能力。自组织往往伴随着被扼杀的动作，主要原因是自组织具有不可预料的特质，引导系统发展出全新的行为模式和系统结构。面对可能的不确定性，现在的人们会感到恐慌，其结果采取打压的态度。但是庆幸的是适应力和自组织是系统的基本特征，不可能被消灭。和适应力类似，可能是很多简单的规则逐步产生系统的自组织能力的。比如，现实中的雪花分形，还有生命游戏（game of life）。</p>
<p>系统的第三个特征是层次性（Hierarchy）。层次性指的是系统和子系统之间包含和生成的关系。子系统能够维持自身，并发挥一定的功能，并服务于一个更大系统的需求，而更大的系统负责调节和强化各个子系统的运作，那么就可以产生并保持相对稳定、有适应力和效率的结构。<strong>系统的层次性一般是自下而上进化的，上层的目的是服务于下层的目的，而不是牺牲多数人的目的以维护少数人的目的。</strong>层次结构要求整体优化，不能让某个子系统的目的占据上风，也不能有太多中央控制。这就意味着层次结构必须平衡整体系统和子系统的关系。</p>
<h2 id="系统思考的6大障碍"><a href="#系统思考的6大障碍" class="headerlink" title="系统思考的6大障碍"></a>系统思考的6大障碍</h2><ol>
<li>别被表象迷惑<br>不要太关注事件本身，而是得关注系统的长期行为趋势，和触发这些行为的条件，这有助于帮助我们梳理出系统结构。而系统结构是行为的根源。</li>
<li>在非线性的世界里，不要用线性的思维模式<br>线性系统可以被模块化，但是非线性系统通常是不可解、不可拆分的。非线性关系之间的相对优势发生改变，会导致不同回路的主导地位发生改变，导致千奇百怪存量的改变。</li>
<li>恰当地定义边界<br>世界万物是互相联系的，不存在孤立的系统。所以边界的划分也应该依据我们的需求和目的。过窄导致对影响因素分析不足，而过宽要致使信息噪声过大，反而难以找出关键要素。</li>
<li>看清各种限制因素<br>限制是客观存在的，它会限制系统的输入和输出。而且限制本身还是动态的，系统也可能是自身的限制因素。<strong>从某种程度上说，找到限制或约束力最大的因素是系统得以生存的基础。可能我们从来没让系统进化的更好，只是不断地打破限制因素，系统自己的特征决定了进化方向。</strong></li>
<li>无所不在的时间延迟<br>系统中的延迟无处不在，为了更好地处理问题，一定的预见性必不可少。不然会错过解决问题的黄金时间。</li>
<li>有限理性<br>我们不得不承认即使知道了全部信息，我们也无法做出完全合理的决策。只有快速构建反馈，可视化结果，让人知道做了决策之后的后果，行为就能发生转变。</li>
</ol>
<h2 id="系统思考的8大陷阱"><a href="#系统思考的8大陷阱" class="headerlink" title="系统思考的8大陷阱"></a>系统思考的8大陷阱</h2><ol>
<li>政策阻力<br>其中政策阻力表现的是哪儿不痛快堵哪里，病急乱投医，治标不治本。</li>
<li>公地悲剧<br>公地悲剧表现在对公有资源的滥用，由于个体遭受的损失由全体承担。</li>
<li>目标侵蚀<br>目标侵蚀是说关注在系统的坏的表现上，产生降低目标、减少修正行为进而加剧的恶性循环。</li>
<li>竞争升级<br>竞争升级就是囚徒困境中的先发制人策略的概述，直到一方退出或者资源耗竭为止。</li>
<li>富者愈富<br>富者愈富指的是为富不仁的道理，富人会刻意不去承担责任。</li>
<li>转嫁负担<br>转嫁负担是指上瘾行为，依赖外部干预者，而导致系统自身解决问题的能力变弱。</li>
<li>规避规则<br>规避规则是说上有政策，下有对策。</li>
<li>目标错位<br>而目标错误最严重，在错误的目标下，任何回路都只会导致无用的结果。</li>
</ol>
<h2 id="改变系统的12杠杆点"><a href="#改变系统的12杠杆点" class="headerlink" title="改变系统的12杠杆点"></a>改变系统的12杠杆点</h2><ol>
<li>数字<br>关注系统参数是一种低效的杠杆点，可能短期内有效，但是长期看来不起决定性作用。</li>
<li>缓冲器<br>存量意味着系统比较稳定，但是换个角度看，也可能是一种浪费。而且因为是物理实体，通常不易调节。</li>
<li>存量-流量结构<br>类似于缓冲器。不过这是系统的内在结构（不仅包含存量），因为是物理实体调节起来不太容易。</li>
<li>时间延迟<br>承认系统具有延迟的特点，时间延迟无法消除，也就要求我们顺势而为，配合系统的改变节拍， 放慢增长速度。</li>
<li>调节回路<br>为了改善系统的自我矫正能力，需要增强调节回路的力量。比如：保持信息公开透明。 </li>
<li>增强回路<br>减少增强回路的产生成果，可能是更加有力的杠杆点。</li>
<li>信息流<br>从人心的角度看，人们避免对自己的决策负责。信息流的缺失是系统功能不良的常见原因之一。恢复信息流，是比重建系统结构更加经济的方式。 </li>
<li>系统规则<br>系统的规则会让系统的行为产生翻天覆地的变化，如果规则倾向于维护一小部分人的利益，减少了来自其他人的反馈，就会触发“富者愈富” 的陷阱，导致自我毁灭。</li>
<li>自组织<br>自组织是进化的机制，而它需要一些原材料，即多样性。消除了多样性，世界将会陷入灾难。</li>
<li>目标<br>很多人身处系统之中，也无法得知系统的目标。系统的目标是一个高杠杆点，而它的目标很大程度上是让自己无限增长。那就需要一个更大的系统把维持平衡作为自己的目标。</li>
<li>社会范式<br>社会公认的观念就是社会范式，这些观念不需要特地强调就能被人所认同。改变社会范式的难度是巨大的，但是你可以积极接触那些拥抱新范式的人，参与宣传当中，避免接触反对这些新范式的人。而且，往往在构建系统模型的时候更容易改变范式，因为你跳出了系统本身，把它作为一个整体来观察了。</li>
<li>超越范式<br>意识到范式也是人类看待这个世界的一种模型罢了。不要纠结真理是否存在，假设所有的东西都可能是错的，为了完成目标，只要去选择合适的手段就好了。</li>
</ol>
<h2 id="系统的15大生存法则"><a href="#系统的15大生存法则" class="headerlink" title="系统的15大生存法则"></a>系统的15大生存法则</h2><ol>
<li>跟上系统的节拍<br>先去了解系统的真实状况，让事实说话，然后用系统性思考动态地分析问题。 </li>
<li>把你的心智模式展现在阳光下<br>用科学的方式检验自己的心智模式，包括价值观。 </li>
<li>相信、尊重并分享信息<br>信息是系统运作的重要连接 ，控制信息甚至就是控制了整个系统。比如：政治家办报。</li>
<li>谨慎使用语言，并用系统的概念去丰富语言<br>只有可以被谈论了，那东西才会火（发展），比如：微服务。</li>
<li>关注重要的，而不总是可以衡量的<br>容易衡量的东西一般不会被忘记；但是不容易衡量的东西，比如：质量、幸福感等等就很容易被遗漏，如果设计时不去考虑这些，人们就不会关注，更不会改进。</li>
<li>为反馈系统制定带有反馈功能的政策<br>把学习融入管理当中，构建调整回路的回路。 </li>
<li>追求整体利益<br>铭记层级组织存在的目的是服务于底层的。不要过度放大任何部分的重要性。</li>
<li>聆听系统的智慧<br>存在的系统自然有它存在的理由，发挥它现有的自我运行的力量和结构是最好的方式。</li>
<li>界定系统的职责<br>职责不是功能。也不是软件设计方法中单一职责表达的变化。职责就是责任，怎么增强系统的内在责任，就必须让每次决策及其结果之间建立起反馈回路。让决策者很快看到后果，意识到结果的严重程度，这才是优化决策最直接的方式。</li>
<li><strong>保持谦逊，做一名学习者</strong><br>不要假装自己是专家，虚张声势是无法改进自己的方式，因为它只能隐藏问题。面对不确定性，我们要做的不是假装自己知晓一切，还是应该“拥抱失误”，这意味着我们需要搜索、使用和分享“我们到底在哪里失误了”这样的信息。</li>
<li>庆祝复杂性<br>这是一种思考方式的转变。系统的复杂性从来不是问题，没有谁可以控制它，它恰是多样性和统一性的条件，所以这个世界才如此异彩纷呈。正如土地理论（Land ethic）所说“当某件事情倾向于保护生物群落的一致性，稳定性和自然之美，它就是对的，否则就是错的”。鼓励自组织、无序、变异和多样性才是我们应该做的。</li>
<li>扩展时间的范围<br>学习过去的经验，面向未来解决现在的问题，不然会很快会崩溃。</li>
<li>打破各种清规戒律<br>系统思考要求“跨领域”思考，正如区块链技术融合分布式原理、加密学理论、博弈论中的理性经济人那样，跨领域的思考模式会产生颠覆性的发明。</li>
<li>扩大关切的范围<br>世界是普遍联系的，没有任何系统是孤立存在的。你关切的东西，不应该仅仅是自己。“各扫自己门前雪，何管他人瓦上霜”是短视的表现。</li>
<li>不要降低“善”的标准<br>世界上充斥着奇葩猎奇的新闻，因为这些新闻是大都涉及偏离现有的社会范式的故事，人们对这个世界上的坏消息总是更容易相信些，这些坏消息成为了“目标侵蚀”的佐证，从而很轻易地丧失自己自幼学习的普世价值观，转而“同流合污”。</li>
</ol>
<p>系统思考的方式能引导我们看清问题的本质，这已经是莫大的帮助了。至于做或者不做，这是个人的选择权利，在人类精神的系统关照下，我们应当知道什么该做，什么必须去做。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷团队工作流</title>
    <url>/2017/09/19/agile-team-workflow/</url>
    <content><![CDATA[<h2 id="站会"><a href="#站会" class="headerlink" title="站会"></a>站会</h2><p>站会中的内容是每天工作的开始，也是对昨天工作的回顾。一般会由团队的某位成员主持，这位主持人有责任让电子系统上的story卡片和看板上的保持一致。站会上，大家依看板从右至左依次更新自己负责story的状态，如果遇到阻碍，应该在站会上及时提出，团队之中的成员如果能提供帮助，应该在站会之后，组织解决方案的讨论。</p>
<h3 id="站会反模式"><a href="#站会反模式" class="headerlink" title="站会反模式"></a>站会反模式</h3><ol>
<li>站会上由组长一人发言、分配任务；</li>
<li>一人长篇阔论占据大半时间（合理的发言时间为1-2分钟，总的时间控制在15分钟左右）；</li>
<li>站会上谈论和story卡片无关的内容。</li>
</ol>
<h2 id="迭代计划会议-IPM"><a href="#迭代计划会议-IPM" class="headerlink" title="迭代计划会议 (IPM)"></a>迭代计划会议 (IPM)</h2><p>迭代计划会议是项目组成员在每一个迭代开始时，聚到一起共同决定这个迭代的 backlog (代办事项) 需要交付的故事卡。<br>这个会议的产出物包含：</p>
<ol>
<li>迭代的 backlog 和用户故事的验收条件</li>
<li>这个迭代的总体业务目标</li>
<li>故事点数，也即开发测试人员对用户故事的评估及承诺</li>
</ol>
<p>参与者包含：</p>
<ol>
<li>Product Owner</li>
<li>Scrum Master</li>
<li>开发团队</li>
<li>其他干系人</li>
</ol>
<p>日程：</p>
<ol>
<li>团队确立这个迭代可以完成的工作量（以点数计），一般从历史迭代中获取</li>
<li>团队根据定义的顺序讨论故事卡，对于每一张故事卡，需要讨论的内容包含：<ol>
<li>衡量故事的相对大小（以点数计），可能会进行故事卡的拆分</li>
<li>沟通验收条件</li>
<li>根据已经讨论出来故事卡的价值、时间和风险，PO重新确定故事卡的优先级</li>
<li>一旦预先设定的工作量到达，就停止本轮迭代会议</li>
</ol>
</li>
<li>团队就迭代的业务目标达成共识</li>
</ol>
<h2 id="用户故事-kickoff-会议"><a href="#用户故事-kickoff-会议" class="headerlink" title="用户故事 kickoff 会议"></a>用户故事 kickoff 会议</h2><p>Story kick off，指的是启动一个 Stroy 进入开发阶段。Story kick off的时候，通常需要三种角色参与：BA、QA 以及开发 Story 的 Dev。</p>
<p>会议内容：</p>
<ul>
<li>DEV 自己先完整地过一遍 Story 的描述；</li>
<li>DEV 给 BA 和 QA 去讲这个 Story 的功能以及 AC；</li>
<li>要能够清晰的讲出来，并且三者达成一致，如果有疑惑，需要当场得到解决；</li>
<li>DEV 开始开发 Story，并自行将 Story 拆分成多个子任务列表，开工。</li>
</ul>
<p><a href="http://www.infoq.com/cn/articles/my-agile-practice-in-thoughtworks">我在ThoughtWorks中的敏捷实践</a></p>
<h2 id="Desk-Check-Shoulder-Check"><a href="#Desk-Check-Shoulder-Check" class="headerlink" title="Desk Check &#x2F; Shoulder Check"></a>Desk Check &#x2F; Shoulder Check</h2><p>Desk Check 发生在开发人员确信自己已经完成了故事卡，需要另外的人（BA、QA、Dev）坐到旁边一起帮忙验证是否确实完成。</p>
<p>Desk checklist:<br>参与者：BA、QA、Dev 或者其他感兴趣的人</p>
<ul>
<li>故事卡测试覆盖率够吗？</li>
<li>自己本地测过功能么？</li>
<li>自己本地跑过全量的测试么？</li>
<li>所有的 AC 是否都满足了？</li>
<li>做故事卡的过程中是否遇到了理解上的问题？</li>
</ul>
<p><a href="https://www.thoughtworks.com/insights/blog/defect-prevention-using-agile-techniques">Defect Prevention Using Agile Techniques</a></p>
<h2 id="Tech-Huddle"><a href="#Tech-Huddle" class="headerlink" title="Tech Huddle"></a>Tech Huddle</h2><p>开发人员聚到一起就项目中遇到的技术展开讨论<br>前提条件：<br>会议之前确定并逐条列出会议讨论的技术主题<br>产出物：</p>
<ol>
<li>一个或多个行动方案，合并到用户故事</li>
<li>方案的优缺点</li>
<li>方案的责任人</li>
</ol>
<h2 id="迭代回顾会议"><a href="#迭代回顾会议" class="headerlink" title="迭代回顾会议"></a>迭代回顾会议</h2><p>在每个迭代结束时，Scrum Master会主持该会议，目的是为了确定哪些改变可以提升下个迭代的生产效率。在这个会议当中，每个人都可以开诚布公地提出自己的建议，有利于管理者从反馈中获取团队的现状。</p>
<p>最高指导原则 (Prime Directive)：</p>
<blockquote>
<p>Regardless of what we discover, we understand and truly believe that everyone did the best job he or she could, given what was known at the time, his or her skills and abilities, the resources available, and the situation at hand.<br>无论我们发现了什么，考虑到当时的已知情况、个人的技术水平和能力、可用的资源，以及手上的状况，我们理解并坚信：每个人对自己的工作都已全力以赴。</p>
</blockquote>
<p>内容包含：</p>
<ul>
<li>上个迭代中做的好的有哪些？</li>
<li>上个迭代中做的不好的有哪些？</li>
<li>我们可以做些什么改善哪些不好的地方？（改善建议）</li>
</ul>
<p>参与者包含：</p>
<ol>
<li>Product Owner</li>
<li>Scrum Master</li>
<li>开发团队</li>
<li>其他干系人</li>
</ol>
<p><a href="https://insights.thoughtworks.cn/7-step-agenda-effective-retrospective/">高效回顾会议的七步议程</a></p>
<h2 id="迭代review会议-Showcase"><a href="#迭代review会议-Showcase" class="headerlink" title="迭代review会议 (Showcase)"></a>迭代review会议 (Showcase)</h2><p>Showcase 就是开发团队把开发好的功能给客户的 Product Owner（以下简称PO）等业务相关人员演示，以获取他们对所开发系统的反馈，是敏捷开发流程中的一个实践，一般的频率是一个迭代一次，也可以根据项目具体情况做调整。</p>
<p>内容包含：</p>
<p><a href="https://insights.thoughtworks.cn/agile-showcase-se7en/">敏捷实践Showcase的七宗罪</a><br><a href="http://www.funretrospectives.com/category/energizer/">Retro 破冰游戏</a></p>
<h2 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h2><h2 id="故事基础"><a href="#故事基础" class="headerlink" title="故事基础"></a>故事基础</h2><p>用户故事是指在软件开发和项目管理中用日常语言或商务用语写成的句子。这个句子反映一个用户在其工作职责的范围内要达到的某个目的, 以及此目的所需要的功能。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><blockquote>
<p>为了避免遗漏附件延误工作<br>作为邮件发送者<br>我希望邮件系统能够在我忘记带附件的时候提醒我</p>
</blockquote>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了&lt;某个目的或价值&gt;, 作为&lt;某类利益相关者&gt;, 我想要&lt;某个功能&gt;</span><br><span class="line">作为&lt;某类利益相关者&gt;, 我想要&lt;某个功能&gt;, 以便&lt;达到某个目的或获得某种价值&gt;</span><br></pre></td></tr></table></figure>

<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><h4 id="重点描述商业的价值不只是功能"><a href="#重点描述商业的价值不只是功能" class="headerlink" title="重点描述商业的价值不只是功能"></a>重点描述商业的价值不只是功能</h4><ul>
<li>帮助团队了解需求背后的意图，利于开发团队协同客户、业务部门设计出更好的解决方案</li>
</ul>
<h4 id="用业务语言描述"><a href="#用业务语言描述" class="headerlink" title="用业务语言描述"></a>用业务语言描述</h4><ul>
<li>利于客户、业务部门理解并区分优先级</li>
</ul>
<h4 id="利益相关者不仅包含用户"><a href="#利益相关者不仅包含用户" class="headerlink" title="利益相关者不仅包含用户"></a>利益相关者不仅包含用户</h4><ul>
<li>系统拥有者的角度也是需求的重要来源</li>
</ul>
<h2 id="CCC-组件-The-three-‘C’s"><a href="#CCC-组件-The-three-‘C’s" class="headerlink" title="CCC 组件 (The three ‘C’s)"></a>CCC 组件 (The three ‘C’s)</h2><h3 id="Card-卡片"><a href="#Card-卡片" class="headerlink" title="Card (卡片)"></a>Card (卡片)</h3><ul>
<li>业务价值 remainder</li>
<li>做计划和沟通业务时的 token</li>
</ul>
<h3 id="Conversation-交流"><a href="#Conversation-交流" class="headerlink" title="Conversation (交流)"></a>Conversation (交流)</h3><ul>
<li>用于在做计划和沟通业务时引发沟通，制造共同话题（收敛）</li>
<li>需求文档的生成方式</li>
</ul>
<h3 id="Confirmation-确认"><a href="#Confirmation-确认" class="headerlink" title="Confirmation (确认)"></a>Confirmation (确认)</h3><ul>
<li>将细节以验收测试的方式检测功能的完整性和准确性</li>
</ul>
<h2 id="划分原则-INVEST"><a href="#划分原则-INVEST" class="headerlink" title="划分原则 INVEST"></a>划分原则 INVEST</h2><h3 id="Independent-独立性"><a href="#Independent-独立性" class="headerlink" title="Independent (独立性)"></a>Independent (独立性)</h3><p>故事和故事之间尽量保持独立，互相依赖的故事对于估算工作量、确定优先级和安排计划都带来很多不便。通常我们可以通过组合和拆分的方式减少依赖性（去除重复）。<br>独立性更多的指的是实现要完整。前后端拆分通常不是很好的拆分方法</p>
<h3 id="Negotiated-可协商的"><a href="#Negotiated-可协商的" class="headerlink" title="Negotiated (可协商的)"></a>Negotiated (可协商的)</h3><p>一个故事是可以协商的，故事卡不是合同，它只是包含对一个需求的简短描述。具体的细节在沟通阶段产出，以验收测试的方式。如果带有太多的细节，反而限制了和用户的沟通。</p>
<h3 id="Valuable-有价值的"><a href="#Valuable-有价值的" class="headerlink" title="Valuable (有价值的)"></a>Valuable (有价值的)</h3><p>每个故事都必须对客户有价值（无论是用户还是客户）。一个让用户故事有价值的好办法就是客户写下它们。</p>
<h3 id="Estimable-可评估的"><a href="#Estimable-可评估的" class="headerlink" title="Estimable (可评估的)"></a>Estimable (可评估的)</h3><p>开发团队需要去估计一个用户故事以便确定优先级，工作量，安排计划。如果难以估计故事的时间, 意味着:</p>
<ul>
<li>领域知识的缺乏: 这种情况下需要更多的沟通</li>
<li>技术实现的模糊: 这种情况下要做试验, 做原型</li>
<li>或者故事太大了: 这时需要把故事切分成小些的</li>
<li>还有对其它团队的依赖…</li>
</ul>
<h3 id="Small-短小的"><a href="#Small-短小的" class="headerlink" title="Small (短小的)"></a>Small (短小的)</h3><p>一个好的故事在工作量上应该是尽量短小的，至少确保能在一个迭代或 Sprint 中能够完成。用户故事越大，在估算、计划安排等方面的风险就越大。</p>
<h3 id="Testable-可测试的"><a href="#Testable-可测试的" class="headerlink" title="Testable (可测试的)"></a>Testable (可测试的)</h3><p>一个用户的故事必须是可被测试的，以便它是可以完成的。如果一个故事无法测试，那么就无法知道它何时可以完成。一个不可测试的例子：为了节省时间，作为用户，我希望软件是易用的。</p>
<h3 id="判断标准-经验准则"><a href="#判断标准-经验准则" class="headerlink" title="判断标准 (经验准则)"></a>判断标准 (经验准则)</h3><ul>
<li>可以写在 Release Notes 里</li>
<li>值得讲给其它行业的人听</li>
<li>可以写在市场宣传材料中</li>
</ul>
<h2 id="验收条件"><a href="#验收条件" class="headerlink" title="验收条件"></a>验收条件</h2><h3 id="捕获预期的行为"><a href="#捕获预期的行为" class="headerlink" title="捕获预期的行为"></a>捕获预期的行为</h3><p>一般验收条件都会在开发之前准备好，用于捕获预期的系统行为，同时作为故事卡业务描述的一部分，定义了故事卡的 DoD（Definition of Done）。</p>
<h3 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h3><ul>
<li><strong>Given</strong> 前置条件，告诉我们在进行操作之前，需要设置和完成什么；</li>
<li><strong>When</strong> 触发结果的操作</li>
<li><strong>Then</strong> 操作之后的预期结果</li>
</ul>
<h3 id="最佳实践模式"><a href="#最佳实践模式" class="headerlink" title="最佳实践模式"></a>最佳实践模式</h3><h4 id="1-可读的"><a href="#1-可读的" class="headerlink" title="1. 可读的"></a>1. 可读的</h4><p>我们希望业务人员审阅和修正验收条件，如果写的内容只有开发人员能懂，我们就失去了获得反馈的机会。使用上述书写格式，可以提高可读性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that my mobile phone is switched on</span><br><span class="line"></span><br><span class="line">And: I have sufficient signal to make a call</span><br><span class="line"></span><br><span class="line">When: I dial a number</span><br><span class="line"></span><br><span class="line">Then: I am connected to the person I want to talk to</span><br><span class="line"></span><br><span class="line">And: incoming calls are diverted to my voicemail</span><br></pre></td></tr></table></figure>

<h4 id="2-可测试的"><a href="#2-可测试的" class="headerlink" title="2. 可测试的"></a>2. 可测试的</h4><h5 id="反模式1-模棱两可的陈述"><a href="#反模式1-模棱两可的陈述" class="headerlink" title="反模式1 - 模棱两可的陈述"></a>反模式1 - 模棱两可的陈述</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I have the search page loaded</span><br><span class="line"></span><br><span class="line">When: I perform a search</span><br><span class="line"></span><br><span class="line">Then: the search results come back within a reasonable period of time</span><br></pre></td></tr></table></figure>
<p>这里的 reasonable period of time 就是不可测试的，因为没有人可以决定什么才是 reasonable.</p>
<p>合理的改法是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I have the search page loaded</span><br><span class="line"></span><br><span class="line">When: I perform a search</span><br><span class="line"></span><br><span class="line">Then: the search results come back within 5ms</span><br></pre></td></tr></table></figure>
<p>5ms 之内，这是一个标量，完全可以衡量。</p>
<h5 id="反模式2-非系统输出"><a href="#反模式2-非系统输出" class="headerlink" title="反模式2 - 非系统输出"></a>反模式2 - 非系统输出</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the home page</span><br><span class="line"></span><br><span class="line">And: I am logged in</span><br><span class="line"></span><br><span class="line">When: I navigate to account preferences</span><br><span class="line"></span><br><span class="line">Then: I can see my account preferences</span><br></pre></td></tr></table></figure>
<p>这里的 I can see my account preferences 是无法进行断言的，因为这是系统无关的，说得极端些，假如用户闭上眼睛，这个功能就没法通过验收了。</p>
<p>合理的改法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the home page</span><br><span class="line"></span><br><span class="line">And: I am logged in</span><br><span class="line"></span><br><span class="line">When: I navigate to account preferences</span><br><span class="line"></span><br><span class="line">Then: my account preferences are displayed</span><br></pre></td></tr></table></figure>
<p>这个时候，我可以检查系统展示了我的用户页面。</p>
<h5 id="反模式3-when-隐藏到-given"><a href="#反模式3-when-隐藏到-given" class="headerlink" title="反模式3 - when 隐藏到 given"></a>反模式3 - when 隐藏到 given</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the homepage</span><br><span class="line"></span><br><span class="line">And: I navigate to the search</span><br><span class="line"></span><br><span class="line">When: I look at the page</span><br><span class="line"></span><br><span class="line">Then: the search options are displayed</span><br></pre></td></tr></table></figure>
<p>基本上，这是团队编写 AC 时最容易犯的错误，操作出现在前置条件中，<em>when</em> 反而不是系统行为了。</p>
<p>合理的改法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the homepage</span><br><span class="line"></span><br><span class="line">When: I navigate to the search</span><br><span class="line"></span><br><span class="line">Then: the search options are displayed</span><br></pre></td></tr></table></figure>

<h4 id="3-实现无关的"><a href="#3-实现无关的" class="headerlink" title="3. 实现无关的"></a>3. 实现无关的</h4><p>验收条件应该是实现无关的，它和用户故事一样，是给业务和开发人员提供交流凭证的一种工具，所以它应该聚焦于功能，而不是功能的展现形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the home page</span><br><span class="line"></span><br><span class="line">And: I am logged in</span><br><span class="line"></span><br><span class="line">When: I navigate to advanced search</span><br><span class="line"></span><br><span class="line">Then: the advanced search web page must be displayed</span><br><span class="line"></span><br><span class="line">And: a text box labelled &quot;Name&quot; is displayed</span><br><span class="line"></span><br><span class="line">And: a text box labelled &quot;Description&quot; is displayed</span><br><span class="line"></span><br><span class="line">And: a command button named &quot;Search&quot; is displayed</span><br></pre></td></tr></table></figure>
<p>这里已经框死了必须要使用 text box 实现展示功能，而实际上其背后真正的意图是通过属性字段进行搜索，隐藏了业务含义的验收条件是不可取的。</p>
<p>合理的改法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the home page</span><br><span class="line"></span><br><span class="line">And: I am logged in</span><br><span class="line"></span><br><span class="line">When: I navigate to advanced search</span><br><span class="line"></span><br><span class="line">Then: the advanced search is displayed</span><br><span class="line"></span><br><span class="line">And: an option to search by name is displayed</span><br><span class="line"></span><br><span class="line">And: an option search by description is displayed</span><br><span class="line"></span><br><span class="line">And: the advanced search is displayed in accordance with the attached wireframe</span><br></pre></td></tr></table></figure>
<p>换句话说，验收条件本身不应该关注于展现形式，当然，为了便于理解，wireframe 是提供直观素材的更好的方式。</p>
<h2 id="代码评审"><a href="#代码评审" class="headerlink" title="代码评审"></a>代码评审</h2><p>代码评审是团队针对今天一天<strong>提交过的</strong>代码的评审会议。这样做的目的是去除代码的坏味道，减少累积的技术债。</p>
<p>团队成员使用版本控制工具，轮流展示自己一天的编码成果并且说明代码的用途。这期间，其他的成员不仅要评审代码的逻辑是否正确（满足验收条件），还必须思考是否有更优雅的方式实现这段功能。大家可以随意表达自己对这些代码的好恶，代码所有者也可以据理力争，所有者一旦被说服就必须无条件地按意见修改。为防止遗忘，可以使用便笺纸记录下来。</p>
<h2 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h2><p>通俗地讲，结对编程就是两个人同时工作在同一个 Story 上，一起讨论 Story 的解决方案，并编写代码实现功能，一个人敲键盘，一个人看屏幕，穿插着进行。Pair的双方在快速敲击键盘的时候会伴随一些交流。能力相当的两人，可以一人写测试，一人写实现代码。</p>
<h2 id="测试驱动开发-TDD"><a href="#测试驱动开发-TDD" class="headerlink" title="测试驱动开发 (TDD)"></a>测试驱动开发 (TDD)</h2><p>TDD，即测试驱动开发，强调的是测试先行，跟我们先实现功能代码后添加测试的过程恰恰相反。测试驱动开发是一种驱动代码实现和设计的过程。我们说要先有测试，再去实现；保证实现功能的前提下，重构代码以达到较好的设计。整个过程就好比演绎推理，测试就是其中的证明步骤，而最终实现的功能则是证明的结果。</p>
<p>实践方法：</p>
<ul>
<li>Given：初始状态或前置条件</li>
<li>When：行为发生</li>
<li>Then：断言结果</li>
</ul>
<h2 id="单元测试和测试驱动开发"><a href="#单元测试和测试驱动开发" class="headerlink" title="单元测试和测试驱动开发"></a>单元测试和测试驱动开发</h2><p>测试的价值表现在两个方面：</p>
<ol>
<li>防止已有的功能被破坏</li>
<li>驱动出功能实现</li>
</ol>
<p>从测试金字塔描述的层级来看，单元测试是基座。这类测试数量应该是非常多的，而且还有一个显著特征——运行速度特别快。一般违反快速这个标准的，基本上可以肯定这不是单元测试。</p>
<p>基于以往带团队的经验，我给出一些写单元测试时常犯的错误和好的实践：</p>
<h3 id="常犯的错误"><a href="#常犯的错误" class="headerlink" title="常犯的错误"></a>常犯的错误</h3><ol>
<li>覆盖率100%，却没有任何断言</li>
<li>使用Java反射setAccessible(true)访问私有属性</li>
<li>依赖某些地方产生的数据才能运行</li>
<li>单元测试运行速度超级慢</li>
<li>开始测试之前，准备巨量的数据</li>
<li>测试之间必须以特定顺序运行</li>
<li>上帝类（God Object）导致数以千行的测试代码</li>
</ol>
<h3 id="好的实践"><a href="#好的实践" class="headerlink" title="好的实践"></a>好的实践</h3><ol>
<li>绝对不测试私有的方法</li>
<li>当方法没有返回值，可以通过测试异常或者其委托对象的方式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. @Test(expected = RuntimeException.class) </span><br><span class="line">2. Mockito.verify(mockObj).doSomething(args…)</span><br></pre></td></tr></table></figure>
3. 静态方法调用是强耦合的信号。需要重构待测类依赖新接口，新接口定义的方法由子类实现，实现方法中包装这些静态方法。</li>
</ol>
<h3 id="什么时候写单元测试？"><a href="#什么时候写单元测试？" class="headerlink" title="什么时候写单元测试？"></a>什么时候写单元测试？</h3><ol>
<li>新的需求，首先写单元测试（保证功能实现）</li>
<li>已经存在的代码，补充单元测试 （保证功能不被破坏）</li>
<li>发现Bug，首先加测试（保证缺陷不再出现）</li>
</ol>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>测试金字塔和 <a href="http://fabiopereira.me/blog/2012/03/18/introducing-depth-of-test-dot/">DOT</a>（Depth of Test)</p>
<h2 id="持续集成-持续交付"><a href="#持续集成-持续交付" class="headerlink" title="持续集成&#x2F;持续交付"></a>持续集成&#x2F;持续交付</h2><p><strong>再次强调一下，持续集成是一项团队务必遵守的实践。</strong></p>
<p>开发过程中，我们鼓励小步提交的代码控制方式。即当开发人员对story的部分功能编码完成之后，如果<strong>确认</strong>可以提交到代码仓库（如果是分布式的Git，可以考虑提交到本地仓库），应该尽早提交。开发人员的每日工作可以遵循7步提交法，如下：</p>
<ol>
<li>更新代码；</li>
<li>本地编码；</li>
<li>本地构建（使用<code>mvn test</code>）；</li>
<li>再次更新代码；</li>
<li>本地构建；</li>
<li>提交到代码仓库；</li>
<li>CI上构建。</li>
</ol>
<p>既然是实践（规矩），就有几项有效的纪律需要遵守：</p>
<ul>
<li>CI红的时候不能提交代码</li>
<li>CI红着不能过夜（不能等到第二天才去修复）</li>
<li>任何人提交后CI失败，无论原因，都有责任跟进修复</li>
<li>在提交代码前运行所有测试</li>
<li>不注释掉或删除失败的测试</li>
</ul>
<p>这也就意味着开发人员需要密切关注CI的状态。CI持续反馈着软件的可工作状态，所以团队应该把CI的健康状况列为项目的最高优先级，甚至高于开发新特性。</p>
<hr>
<h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><ol>
<li><a href="https://insights.thoughtworks.cn/thoughtworks-agile/">ThoughtWorks的敏捷开发-XR</a>)</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>agile</tag>
      </tags>
  </entry>
  <entry>
    <title>验收条件</title>
    <url>/2017/09/24/Acceptance-Criteria/</url>
    <content><![CDATA[<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ol>
<li>日常语言描述</li>
<li>捕获系统行为</li>
<li>个数有限</li>
</ol>
<p>在故事基础部分，我提到用户故事通常是日常或者商务语言写成的句子，这些句子描述了用户在其工作职责范围内想要达成的某个目的以及达成该目的需要的功能（手段）。所以书写用户的故事的句式一般都是：As（用户的角色）… I Want（功能或手段）… So That（目的）。根据用户故事的 INVEST 划分原则中 N (Negotiated 可协商的) 原则，故事包含的是对需求的简短描述，具体的细节需要沟通产出，产出物表现为验收条件。</p>
<p>换言之，验收条件是在开发前的分析阶段输出的，它的作用是补充需求细节。更进一步，验收条件其实有力地消除了用户和开发人员之间的沟通鸿沟。为什么这么说呢？因为验收条件具备两点很重要的特征：</p>
<ul>
<li>日常语言描述</li>
<li>捕获系统行为</li>
</ul>
<p>这两点特征促进了参与各方在需求点上快速反馈，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/217988-c3f6913b5098b359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验收条件-反馈环"><br>在敏捷活动中高效地沟通一直被反复强调，因为不高效的沟通造成的信息误导和返工是精益生产活动中应当极力消除的，所以任何能够促进沟通的方式方法都值得提倡。</p>
<p>除此之外，有限的个数 (2-8 ACs&#x2F;story) 也是验收条件的一个特征，这也是 INVEST 原则中 E (Estimable 可评估的) 所要求的。所以，也引出了验收条件的一个简明定义——用户故事的 DoD (Definition of Done)。也有人说，一组验收条件定义了用户故事的边界（Boundary）。如果任由用户故事自然“疯长”，范围无限放大，交付怕是遥遥无期。</p>
<p>验收条件会作为业务活动描述的一部分存在于用户故事中，一般会在开发之前准备就绪。在敏捷活动 kick-off 时，由业务分析师（BA）和开发人员（Dev），也可叫上质量保证师（QA）一起逐条澄清验收条件，以便保证开发之前达成共识，减少返工和浪费。在其它敏捷活动如：desk-checks, customer sign-off, UI testing, BDD 中也会重度参与。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="Given-When-Then"><a href="#Given-When-Then" class="headerlink" title="Given&#x2F;When&#x2F;Then"></a>Given&#x2F;When&#x2F;Then</h3><blockquote>
<p><strong>#Title</strong><br><strong>Given</strong> 用户触发操作之前处于的系统状态<br><strong>When</strong> 触发系统结果的操作<br><strong>Then</strong> 系统预期返回的结果</p>
</blockquote>
<h3 id="Verifiable-checklists"><a href="#Verifiable-checklists" class="headerlink" title="Verifiable checklists"></a>Verifiable checklists</h3><blockquote>
<p>e.g. [PhoneNumber] 只能包含0-9, +</p>
</blockquote>
<h2 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h2><h3 id="模棱两可的陈述"><a href="#模棱两可的陈述" class="headerlink" title="模棱两可的陈述"></a>模棱两可的陈述</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I have the search page loaded</span><br><span class="line"></span><br><span class="line">When: I perform a search</span><br><span class="line"></span><br><span class="line">Then: the search results come back within a reasonable period of time</span><br></pre></td></tr></table></figure>
<p>这里的 reasonable period of time 就是不可测试的，因为没有人可以决定什么才是 reasonable.</p>
<p>合理的改法是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I have the search page loaded</span><br><span class="line"></span><br><span class="line">When: I perform a search</span><br><span class="line"></span><br><span class="line">Then: the search results come back within 5ms</span><br></pre></td></tr></table></figure>
<p>5ms 之内，这是一个标量，完全可以衡量。</p>
<h3 id="非系统交互"><a href="#非系统交互" class="headerlink" title="非系统交互"></a>非系统交互</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given I have pulled my car up to the valet area</span><br><span class="line"></span><br><span class="line">When I hand over my keys to the valet person</span><br><span class="line"></span><br><span class="line">Then I receive a paper ticket from the valet person</span><br><span class="line"></span><br><span class="line">And I am instructed to hold on to it so I can use it to retrieve my car later.</span><br></pre></td></tr></table></figure>
<p>这里的所有描述都是对现实场景的描述，和系统并无关系，对于开发人员构建系统几乎没有丝毫帮助。这种反模式的修正方法是剔除那些非系统的验收条件，重新梳理用户故事。</p>
<h3 id="非系统输出"><a href="#非系统输出" class="headerlink" title="非系统输出"></a>非系统输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the home page</span><br><span class="line"></span><br><span class="line">And: I am logged in</span><br><span class="line"></span><br><span class="line">When: I navigate to account preferences</span><br><span class="line"></span><br><span class="line">Then: I can see my account preferences</span><br></pre></td></tr></table></figure>
<p>这里的 I can see my account preferences 是无法进行断言的，因为这是系统无关的，说得极端些，假如用户闭上眼睛，这个功能就没法通过验收了。</p>
<p>合理的改法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the home page</span><br><span class="line"></span><br><span class="line">And: I am logged in</span><br><span class="line"></span><br><span class="line">When: I navigate to account preferences</span><br><span class="line"></span><br><span class="line">Then: my account preferences are displayed</span><br></pre></td></tr></table></figure>
<p>这个时候，我可以检查系统展示了我的用户页面。</p>
<h3 id="非系统异常"><a href="#非系统异常" class="headerlink" title="非系统异常"></a>非系统异常</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given 我选择了一份图表模板</span><br><span class="line">When 我跳转到显示界面</span><br><span class="line">Then 我发现图表不是我想要的</span><br></pre></td></tr></table></figure>
<p>这里的问题涉及了非系统输出没法进行测试等问题，还有一个显著的毛病是误认为用户自身的误操作也必须反映到用户故事中。这里出错的点是用户自己选错了模板，发现产生的图表不是自己想要的格式，系统是自动无法判别选择模板的正确性的。</p>
<h3 id="when-隐藏到-given"><a href="#when-隐藏到-given" class="headerlink" title="when 隐藏到 given"></a>when 隐藏到 given</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the homepage</span><br><span class="line"></span><br><span class="line">And: I navigate to the search</span><br><span class="line"></span><br><span class="line">When: I look at the page</span><br><span class="line"></span><br><span class="line">Then: the search options are displayed</span><br></pre></td></tr></table></figure>
<p>基本上，这是团队编写 AC 时最容易犯的错误，操作出现在前置条件中，<em>when</em> 中反而不是系统行为了。</p>
<p>合理的改法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the homepage</span><br><span class="line"></span><br><span class="line">When: I navigate to the search</span><br><span class="line"></span><br><span class="line">Then: the search options are displayed</span><br></pre></td></tr></table></figure>
<h2 id="最佳模式"><a href="#最佳模式" class="headerlink" title="最佳模式"></a>最佳模式</h2><h3 id="1-可读的"><a href="#1-可读的" class="headerlink" title="1. 可读的"></a>1. 可读的</h3><p>我们希望业务人员审阅和修正验收条件，如果写的内容只有开发人员能懂，我们就失去了获得反馈的机会。使用上述书写格式，可以提高可读性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that my mobile phone is switched on</span><br><span class="line"></span><br><span class="line">And: I have sufficient signal to make a call</span><br><span class="line"></span><br><span class="line">When: I dial a number</span><br><span class="line"></span><br><span class="line">Then: I am connected to the person I want to talk to</span><br><span class="line"></span><br><span class="line">And: incoming calls are diverted to my voicemail</span><br></pre></td></tr></table></figure>
<h4 id="2-可测试的"><a href="#2-可测试的" class="headerlink" title="2. 可测试的"></a>2. 可测试的</h4><p>参见反模式中合理改法。</p>
<h4 id="3-实现无关的"><a href="#3-实现无关的" class="headerlink" title="3. 实现无关的"></a>3. 实现无关的</h4><p>验收条件应该是实现无关的，它和用户故事一样，是给业务和开发人员提供交流凭证的一种工具，所以它应该聚焦于功能，而不是功能的展现形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the home page</span><br><span class="line"></span><br><span class="line">And: I am logged in</span><br><span class="line"></span><br><span class="line">When: I navigate to advanced search</span><br><span class="line"></span><br><span class="line">Then: the advanced search web page must be displayed</span><br><span class="line"></span><br><span class="line">And: a text box labelled &quot;Name&quot; is displayed</span><br><span class="line"></span><br><span class="line">And: a text box labelled &quot;Description&quot; is displayed</span><br><span class="line"></span><br><span class="line">And: a command button named &quot;Search&quot; is displayed</span><br></pre></td></tr></table></figure>
<p>这里已经框死了必须要使用 text box 实现展示功能，而实际上其背后真正的意图是通过属性字段进行搜索，隐藏了业务含义的验收条件是不可取的。</p>
<p>合理的改法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given: that I am on the home page</span><br><span class="line"></span><br><span class="line">And: I am logged in</span><br><span class="line"></span><br><span class="line">When: I navigate to advanced search</span><br><span class="line"></span><br><span class="line">Then: the advanced search is displayed</span><br><span class="line"></span><br><span class="line">And: an option to search by name is displayed</span><br><span class="line"></span><br><span class="line">And: an option search by description is displayed</span><br><span class="line"></span><br><span class="line">And: the advanced search is displayed in accordance with the attached wireframe</span><br></pre></td></tr></table></figure>
<p>换句话说，验收条件本身不应该关注于展现形式，当然，为了便于理解，wireframe 是提供直观素材的更好的方式。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作为一名管理员</span><br><span class="line">我想要把一名员工加入系统中</span><br><span class="line">以便管理他们的权限</span><br></pre></td></tr></table></figure>
<h3 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤"></a>分析步骤</h3><h4 id="1-定义边界"><a href="#1-定义边界" class="headerlink" title="1. 定义边界"></a>1. 定义边界</h4><ul>
<li>触发添加员工操作</li>
<li>输入员工的详情</li>
<li>验证遗漏或者错误的字段</li>
<li>保存</li>
</ul>
<h4 id="2-提炼和细化"><a href="#2-提炼和细化" class="headerlink" title="2. 提炼和细化"></a>2. 提炼和细化</h4><ol>
<li>触发添加员工操作<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假如我进入了员工管理系统</span><br><span class="line">当我进入员工的浏览页</span><br><span class="line">之后添加员工的操作出现在页面上</span><br></pre></td></tr></table></figure>
2. 输入员工的详情<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假如添加员工的操作出现在浏览页</span><br><span class="line">当我调用了添加员工的操作</span><br><span class="line">那么我可以输入员工的姓名和出生日期</span><br><span class="line">并且出现了保存操作</span><br></pre></td></tr></table></figure>
3. 验证遗漏的字段<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假如我没有填写员工的姓名和/或生日</span><br><span class="line">当我尝试保存</span><br><span class="line">那么保存不会成功</span><br><span class="line">并且会有消息显示遗漏的字段</span><br></pre></td></tr></table></figure>
4. 验证错误的生日日期<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假如我正在添加一名员工的详情</span><br><span class="line">并且我输入了未来或者早于1900年的日期，或者错误的日期格式</span><br><span class="line">当我尝试保存</span><br><span class="line">那么保存不会成功</span><br><span class="line">并且会有消息显示输入的生日日期无效</span><br><span class="line"></span><br><span class="line">验证列表：</span><br><span class="line">[日期格式] yyyy/MM/dd</span><br></pre></td></tr></table></figure>
5. 保存<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假如我正在添加一名员工的详情</span><br><span class="line">并且我输入了有效的生日和姓名</span><br><span class="line">当我尝试保存</span><br><span class="line">那么会有消息显示保存成功</span><br><span class="line">并且包含该员工详情的页面会呈现</span><br><span class="line">并且详情中的生日和姓名和之前输入的一致</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>验收条件并不是唯一澄清和约束用户故事的方式！任何可以提升理解和降低沟通成本的方式方法都值得尝试。比如：用户偏好 —— 希望使用下拉框而不是复选框，往往可以通过添加一条记录在故事中补充这部分信息。另外，一个完整的故事最好能附上线框图，一图胜千言。</p>
<hr>
<p>进一步阅读<br>[1] <a href="/2017/09/19/agile-team-workflow/">敏捷团队工作流</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>agile</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree command 的多重实现</title>
    <url>/2018/04/29/multiple-implements-of-tree-command/</url>
    <content><![CDATA[<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>利用递归，将目录转换成 <code>&#123;:name: &quot;.&quot;, :children: []&#125;</code> 结构</li>
<li>对于第一层目录名，前缀装饰成 <code>T_branch = &quot;├── &quot; </code>或者 <code>L_branch = &quot;└── &quot;</code></li>
<li>对于子目录，前缀装饰成 <code>I_branch = &quot;│   &quot;</code>或者<code>SPACER   = &quot;    &quot;</code><br>举例如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── tree.py  # 不是最后一项，所以使用 T_branch 前缀</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md # 由于其父亲不是最后一项，所以使用 I_branch 前缀</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data    # 是最后一项，所以使用 L_branch 前缀</span><br><span class="line">    ├── output.txt # 由于其父亲是最后一项，所以使用 SPACE 前缀</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">list a directory in tree way.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">children(path):</span></span><br><span class="line"><span class="string">    map(lambda name: tree(path, name), listdir(path))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">tree(parent, dir_name):</span></span><br><span class="line"><span class="string">    if is_file(parent, dir_name):</span></span><br><span class="line"><span class="string">        return &#123;&#x27;name&#x27;: dir_name, &#x27;children&#x27;: []&#125;</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        children = children(join(parent, dir_name))</span></span><br><span class="line"><span class="string">        return &#123;&#x27;name&#x27;: dir_name, &#x27;children&#x27;: children&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> functools <span class="keyword">as</span> fp</span><br><span class="line"></span><br><span class="line">I_branch = <span class="string">&quot;│   &quot;</span></span><br><span class="line">T_branch = <span class="string">&quot;├── &quot;</span></span><br><span class="line">L_branch = <span class="string">&quot;└── &quot;</span></span><br><span class="line">SPACER = <span class="string">&quot;    &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_children</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> filename: tree_format(path, filename), os.listdir(path))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tree_format</span>(<span class="params">parent, dir_name</span>):</span><br><span class="line">    path = os.path.join(parent, dir_name)</span><br><span class="line">    is_file = os.path.isfile(path)</span><br><span class="line">    children = [] <span class="keyword">if</span> is_file <span class="keyword">else</span> _children(path)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;name&#x27;</span>: dir_name, <span class="string">&#x27;children&#x27;</span>: <span class="built_in">list</span>(children)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">render_tree</span>(<span class="params">tr</span>):</span><br><span class="line">    name = tr[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    children = tr[<span class="string">&#x27;children&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> [name] + fp.reduce(<span class="keyword">lambda</span> l, r: l + r,</span><br><span class="line">                              <span class="built_in">map</span>(<span class="keyword">lambda</span> arg: render(<span class="built_in">len</span>(children))(*arg),</span><br><span class="line">                                  <span class="built_in">enumerate</span>(children)),</span><br><span class="line">                              [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">render</span>(<span class="params">length</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prefix</span>(<span class="params">index, child</span>):</span><br><span class="line">        is_last = (index == length - <span class="number">1</span>)</span><br><span class="line">        prefix_first = L_branch <span class="keyword">if</span> is_last <span class="keyword">else</span> T_branch</span><br><span class="line">        prefix_rest = SPACER <span class="keyword">if</span> is_last <span class="keyword">else</span> I_branch</span><br><span class="line">        tr = render_tree(child)</span><br><span class="line">        head = prefix_first + tr[<span class="number">0</span>]</span><br><span class="line">        tail = [prefix_rest + t <span class="keyword">for</span> t <span class="keyword">in</span> tr[<span class="number">1</span>:]]</span><br><span class="line">        <span class="keyword">return</span> [head] + tail</span><br><span class="line">    <span class="keyword">return</span> prefix</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;\n&#x27;</span>.join(render_tree(tree(<span class="string">&#x27;&#x27;</span>, sys.argv[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">$ python3 tree.py . <span class="comment">#打印当前的目录的所有文件及子目录</span></span><br><span class="line">.</span><br><span class="line">├── tree.py</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data</span><br><span class="line">    ├── output.txt</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure>
<h2 id="Clojure-实现"><a href="#Clojure-实现" class="headerlink" title="Clojure 实现"></a>Clojure 实现</h2><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">ns</span></span> tree</span><br><span class="line">  (<span class="symbol">:require</span> [clojure.java.io <span class="symbol">:as</span> io]</span><br><span class="line">            [clojure.string <span class="symbol">:as</span> str]))</span><br><span class="line">(<span class="keyword">def</span> <span class="title">L-branch</span> <span class="string">&quot;└── &quot;</span>)</span><br><span class="line">(<span class="keyword">def</span> <span class="title">T-branch</span> <span class="string">&quot;├── &quot;</span>)</span><br><span class="line">(<span class="keyword">def</span> <span class="title">I-branch</span> <span class="string">&quot;│   &quot;</span>)</span><br><span class="line">(<span class="keyword">def</span> <span class="title">SPACE</span>    <span class="string">&quot;    &quot;</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">declare</span></span> tree)</span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">children</span> [path]</span><br><span class="line">  (<span class="name"><span class="built_in">map</span></span> #(<span class="name">tree</span> %) (<span class="name">.listFiles</span> path)))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">tree</span> [dir-name]</span><br><span class="line">  (<span class="name"><span class="built_in">let</span></span> [path (<span class="name">io/file</span> dir-name)</span><br><span class="line">        dir? (<span class="name">.isDirectory</span> path)]</span><br><span class="line">    &#123;<span class="symbol">:name</span> (<span class="name">.getName</span> path)</span><br><span class="line">     <span class="symbol">:children</span> (<span class="name"><span class="built_in">if</span></span> dir? (<span class="name">children</span> path))&#125;))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">render-tree</span> [&#123;name <span class="symbol">:name</span> children <span class="symbol">:children</span>&#125;]</span><br><span class="line">  (<span class="name"><span class="built_in">cons</span></span> name</span><br><span class="line">        (<span class="name"><span class="built_in">mapcat</span></span> (<span class="name"><span class="built_in">fn</span></span> [child index]</span><br><span class="line">                  (<span class="name"><span class="built_in">let</span></span> [last? (<span class="name"><span class="built_in">=</span></span> index (<span class="name"><span class="built_in">dec</span></span> (<span class="name"><span class="built_in">count</span></span> children)))</span><br><span class="line">                        prefix-first (<span class="name"><span class="built_in">if</span></span> last? L-branch T-branch)</span><br><span class="line">                        prefix-rest (<span class="name"><span class="built_in">if</span></span> last? SPACE I-branch)</span><br><span class="line">                        sub-tree (<span class="name">render-tree</span> child)]</span><br><span class="line">                    (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">str</span></span> prefix-first (<span class="name"><span class="built_in">first</span></span> sub-tree))</span><br><span class="line">                          (<span class="name"><span class="built_in">map</span></span> #(<span class="name"><span class="built_in">str</span></span> prefix-rest %) (<span class="name"><span class="built_in">rest</span></span> sub-tree)))))</span><br><span class="line">                children</span><br><span class="line">                (<span class="name"><span class="built_in">range</span></span>))))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">-main</span> [&amp; args]</span><br><span class="line">  (<span class="name"><span class="built_in">-&gt;&gt;</span></span> </span><br><span class="line">      (<span class="name">tree</span> (<span class="name"><span class="built_in">first</span></span> args))</span><br><span class="line">      (<span class="name">render-tree</span>)</span><br><span class="line">      (<span class="name">str/join</span> <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">      (<span class="name">println</span>)))</span><br><span class="line">$ lein run -m tree .</span><br><span class="line">.</span><br><span class="line">├── tree.py</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data</span><br><span class="line">    ├── output.txt</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure>
<h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;io/ioutil&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;path&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	I_branch = &quot;│   &quot;</span><br><span class="line">	T_branch = &quot;├── &quot;</span><br><span class="line">	L_branch = &quot;└── &quot;</span><br><span class="line">	SPACER   = &quot;    &quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type entry struct &#123;</span><br><span class="line">	name     string</span><br><span class="line">	children []entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e entry) String() string &#123;</span><br><span class="line">	if len(e.children) == 0 &#123;</span><br><span class="line">		return e.name</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		s := e.name</span><br><span class="line">		for _, child := range e.children &#123;</span><br><span class="line">			s += child.String()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return s</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Children(path string) []entry &#123;</span><br><span class="line">	result := []entry&#123;&#125;</span><br><span class="line">	files, _ := ioutil.ReadDir(path)</span><br><span class="line">	for _, f := range files &#123;</span><br><span class="line">		result = append(result, Tree(path, f.Name()))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Tree(parent, dirName string) entry &#123;</span><br><span class="line">	realPath := path.Join(parent, dirName)</span><br><span class="line">	theChildren := []entry&#123;&#125;</span><br><span class="line">	if f, ok := os.Stat(realPath); ok == nil &#123;</span><br><span class="line">		if f.IsDir() &#123;</span><br><span class="line">			theChildren = Children(realPath)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return entry&#123;name: dirName, children: theChildren&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RenderTree(e entry) []string &#123;</span><br><span class="line">	name := e.name</span><br><span class="line">	children := e.children</span><br><span class="line">	result := []string&#123;name&#125;</span><br><span class="line"></span><br><span class="line">	for index, child := range children &#123;</span><br><span class="line">		subTree := RenderTree(child)</span><br><span class="line">		prefixFirst := T_branch</span><br><span class="line">		prefixRest := I_branch</span><br><span class="line">		if index == len(children)-1 &#123;</span><br><span class="line">			prefixFirst = L_branch</span><br><span class="line">			prefixRest = SPACER</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		result = append(result, prefixFirst+subTree[0])</span><br><span class="line"></span><br><span class="line">		for _, sub := range subTree[1:] &#123;</span><br><span class="line">			result = append(result, prefixRest+sub)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(strings.Join(RenderTree(Tree(&quot;&quot;, os.Args[1])), &quot;\n&quot;))</span><br><span class="line">&#125;</span><br><span class="line">$ go run tree.go .</span><br><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── data.txt</span><br><span class="line">│   └── output.txt</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── recursion.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── tree.py</span><br><span class="line">└── tuples.py</span><br></pre></td></tr></table></figure>
<h2 id="NodeJS-实现"><a href="#NodeJS-实现" class="headerlink" title="NodeJS 实现"></a>NodeJS 实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const I_branch = &#x27;│   &#x27;</span><br><span class="line">const T_branch = &#x27;├── &#x27;</span><br><span class="line">const L_branch = &#x27;└── &#x27;</span><br><span class="line">const SPACER   = &#x27;    &#x27;</span><br><span class="line"></span><br><span class="line">function children(path) &#123;</span><br><span class="line">    return fs.readdirSync(path).map(filename =&gt; tree(path, filename))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tree(parentDir, dirName) &#123;</span><br><span class="line">    let realPath = path.join(parentDir, dirName)</span><br><span class="line">    let isDir = fs.statSync(realPath).isDirectory()</span><br><span class="line">    return &#123;name: dirName, children: isDir ? children(realPath) : []&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prefix(len) &#123;</span><br><span class="line">    return (tr, index) =&gt; &#123;</span><br><span class="line">        let isLast = len == index + 1</span><br><span class="line">        let prefixFirst = isLast ? L_branch : T_branch</span><br><span class="line">        let prefixRest = isLast ? SPACER : I_branch</span><br><span class="line">        let [head, ...tail]= renderTree(tr)</span><br><span class="line"></span><br><span class="line">        return [prefixFirst + head].concat(tail.map(name =&gt; prefixRest + name))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderTree(&#123;name: name, children: children&#125;) &#123;</span><br><span class="line">    return [name]</span><br><span class="line">        .concat(children</span><br><span class="line">            .map(prefix(children.length))</span><br><span class="line">            .reduce((l, r) =&gt; l.concat(r), []))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(renderTree(tree(&#x27;&#x27;, process.argv[2])).join(&#x27;\n&#x27;))</span><br><span class="line"></span><br><span class="line">$ node tree.js .</span><br><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── data.txt</span><br><span class="line">│   └── output.txt</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── recursion.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── tree.py</span><br><span class="line">└── tuples.py</span><br></pre></td></tr></table></figure>
<h2 id="Kotlin-script"><a href="#Kotlin-script" class="headerlink" title="Kotlin script"></a>Kotlin script</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.File</span><br><span class="line"></span><br><span class="line">val I_branch = &quot;│   &quot;</span><br><span class="line">val T_branch = &quot;├── &quot;</span><br><span class="line">val L_branch = &quot;└── &quot;</span><br><span class="line">val SPACER   = &quot;    &quot;</span><br><span class="line"></span><br><span class="line">data class Entry (val name: String, val children: List&lt;Entry&gt;)</span><br><span class="line"></span><br><span class="line">fun children(path: File): List&lt;Entry&gt; &#123;</span><br><span class="line">    return path.listFiles().map &#123;tree(it)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun tree(path: File): Entry &#123;</span><br><span class="line">    val isDir = path.isDirectory()</span><br><span class="line">    return Entry(path.getName(), if(isDir) children(path) else listOf&lt;Entry&gt;())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun renderTree(tree: Entry): List&lt;String&gt; &#123;</span><br><span class="line">    val name = tree.name</span><br><span class="line">    val children = tree.children</span><br><span class="line"></span><br><span class="line">    return listOf(name) + children.mapIndexed &#123; i, e -&gt; prefix(children.size)(i, e) &#125;.fold(listOf&lt;String&gt;()) &#123;l, r -&gt; l + r&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun prefix(size: Int): (Int, Entry) -&gt; List&lt;String&gt; &#123;</span><br><span class="line">    return &#123;index, entry -&gt;</span><br><span class="line">        val isLast = index + 1 == size</span><br><span class="line">        val prefixFirst = if(isLast) L_branch else T_branch</span><br><span class="line">        val prefixRest = if(isLast) SPACER else I_branch</span><br><span class="line">        val subTree = renderTree(entry)</span><br><span class="line"></span><br><span class="line">        listOf(prefixFirst + subTree.first()) + subTree.drop(1).map &#123;t -&gt; prefixRest + t&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(renderTree(tree(File(args[0]))).joinToString(&quot;\n&quot;))</span><br><span class="line"></span><br><span class="line">$ kotlinc -script tree.kts .</span><br><span class="line">.</span><br><span class="line">├── tree.py</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data</span><br><span class="line">    ├── output.txt</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure>
<h2 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io._</span><br><span class="line">val I_branch = &quot;│   &quot;</span><br><span class="line">val T_branch = &quot;├── &quot;</span><br><span class="line">val L_branch = &quot;└── &quot;</span><br><span class="line">val SPACER   = &quot;    &quot;</span><br><span class="line"></span><br><span class="line">case class Entry(name: String, children: List[Entry])</span><br><span class="line"></span><br><span class="line">def children(path: File): List[Entry] = path.listFiles().toList.map((it: File) =&gt; tree(it))</span><br><span class="line"></span><br><span class="line">def tree(path: File): Entry = Entry(path.getName(), if(path.isDirectory()) children(path) else List[Entry]())</span><br><span class="line"></span><br><span class="line">def prefix(size: Int) = (index: Int, entry: Entry) =&gt; &#123;</span><br><span class="line">    val isLast = index + 1 == size</span><br><span class="line">    val prefixFirst = if(isLast) L_branch else T_branch</span><br><span class="line">    val prefixRest = if(isLast) SPACER else I_branch</span><br><span class="line">    val subTree = renderTree(entry)</span><br><span class="line">    List(prefixFirst + subTree.head) ++ subTree.tail.map(t =&gt; prefixRest + t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def renderTree(tree: Entry): List[String] = &#123;</span><br><span class="line">    val name = tree.name</span><br><span class="line">    val children = tree.children</span><br><span class="line"></span><br><span class="line">    return List(name) ++ children</span><br><span class="line">      .zipWithIndex</span><br><span class="line">      .map(&#123;case (e: Entry, i: Int) =&gt; prefix(children.size)(i, e)&#125;)</span><br><span class="line">      .fold(List[String]())((l, r) =&gt; l ++ r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(renderTree(tree(new File(args(0)))).mkString(&quot;\n&quot;))</span><br><span class="line"></span><br><span class="line">$ scala tree.scala .</span><br><span class="line">.</span><br><span class="line">├── tree.py</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data</span><br><span class="line">    ├── output.txt</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure>
<h2 id="Elixir"><a href="#Elixir" class="headerlink" title="Elixir"></a>Elixir</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env elixir</span><br><span class="line"></span><br><span class="line">defmodule Tree do</span><br><span class="line">  def main([dir | _]) do</span><br><span class="line">    dir |&gt; tree_format |&gt; render_tree |&gt; Enum.join(&quot;\n&quot;) |&gt; IO.puts</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  defp children(path) do</span><br><span class="line">    if (path |&gt; File.dir?) do</span><br><span class="line">      File.ls!(path) |&gt; Enum.map(fn f -&gt; tree_format(path, f) end)</span><br><span class="line">    else</span><br><span class="line">      []</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  defp tree_format(parent_dir \\ &quot;.&quot;, dir_name) do</span><br><span class="line">    %&#123;:name =&gt; dir_name, :children =&gt; Path.join(parent_dir, dir_name) |&gt; children&#125;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  defp decorate(is_last?, [parent | children]) do</span><br><span class="line">    prefix_first = (if (is_last?), do: &quot;└── &quot;, else: &quot;├── &quot;)</span><br><span class="line">    prefix_rest = (if (is_last?), do: &quot;    &quot;, else: &quot;│   &quot;)</span><br><span class="line">    [prefix_first &lt;&gt; parent | children |&gt; Enum.map(fn child -&gt; prefix_rest &lt;&gt; child end)]</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  defp render_tree(%&#123;name: dir_name, children: children&#125;) do</span><br><span class="line">    [dir_name </span><br><span class="line">     | children </span><br><span class="line">     |&gt; Enum.with_index(1)</span><br><span class="line">     |&gt; Enum.map(fn &#123;child, index&#125; -&gt; decorate(length(children) == index, render_tree(child)) end) </span><br><span class="line">     |&gt; List.flatten]</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Tree.main(System.argv)</span><br><span class="line"></span><br><span class="line">$ elixir tree.exs .</span><br><span class="line">.</span><br><span class="line">├── tree.py</span><br><span class="line">├── files.py</span><br><span class="line">├── lists.py</span><br><span class="line">├── tuples.py</span><br><span class="line">├── resources</span><br><span class="line">│   └── README.md</span><br><span class="line">├── recursion.py</span><br><span class="line">└── data</span><br><span class="line">    ├── output.txt</span><br><span class="line">    └── data.txt</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>代数定义- idris</title>
    <url>/2018/05/13/learn-idris/</url>
    <content><![CDATA[<h2 id="关于环境和数据类型"><a href="#关于环境和数据类型" class="headerlink" title="关于环境和数据类型"></a>关于环境和数据类型</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li>Emacs集成 Idris 开发环境</li>
<li>Idris repl 使用说明</li>
<li>Idris 代数类型定义</li>
</ol>
<h3 id="1-Emacs-安装-idris-mode"><a href="#1-Emacs-安装-idris-mode" class="headerlink" title="1. Emacs 安装 idris-mode"></a>1. Emacs 安装 idris-mode</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(use-package idris-mode</span><br><span class="line">  :mode ((&quot;\\.idr$&quot; . idris-mode)</span><br><span class="line">         (&quot;\\.lidr$&quot; . idris-mode))</span><br><span class="line">  :ensure t</span><br><span class="line">  :defer t)</span><br><span class="line"></span><br><span class="line">(provide &#x27;init-idris)</span><br></pre></td></tr></table></figure>
<p>emacs 打开任何以<code>*.idr</code>和<code>*.lidr</code>作为后缀的文件，都可以启用idris-mode.<br>另外，使用<code>C-c C-l</code>可以在<code>*idris-repl*</code>中加载当前文件并启用 type check 进行检查，出现的错误会打印在<code>*idris-notes* buffer</code>中。</p>
<p><strong>注意</strong><br>关于 IO 的调用问题，经典 <code>Hello World</code> 程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module Main</span><br><span class="line"></span><br><span class="line">main : IO ()</span><br><span class="line">main = putStrLn &quot;Hello World&quot;  </span><br></pre></td></tr></table></figure>
<p>当需要在repl中调用 main 方法时，需要通过<code>:x main</code> 执行，才能看到执行结果，<code>Hello World</code> 会显示在<code>*idris-process* buffer</code> 中。原因是 repl 会返回一个 IO action，这个 IO action 只会在 idris 之外 hook 的 terminal 中才会执行。<a href="https://github.com/idris-lang/Idris-dev/issues/3152">https://github.com/idris-lang/Idris-dev/issues/3152</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:x  &lt;expr&gt;  Execute IO actions resulting from an expression using the interpreter</span><br></pre></td></tr></table></figure>

<h3 id="2-自定义数据类型"><a href="#2-自定义数据类型" class="headerlink" title="2. 自定义数据类型"></a>2. 自定义数据类型</h3><p>我们先定义一下自然数：自然数就是从0开始，后面的数都比前一个自然数多1的数列。我们从小知道的自然数0, 1, 2,…,100,… 看上去只是一系列割裂开的一组符号，但是事实上，数列本身必然存在一些属性，数与数之间必然存在规律。</p>
<p>基于前面提到的自然数的属性，我们定义自然数如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data Natural = Z | S Natural</span><br></pre></td></tr></table></figure>
<p>读作：自然数要么是Z（零），要么是自然数的后继(S)</p>
<h4 id="2-1-定义加法"><a href="#2-1-定义加法" class="headerlink" title="2.1 定义加法"></a>2.1 定义加法</h4><p>接下来，我们定义自然数的加法运算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plus : Natural -&gt; Natural -&gt; Natural</span><br><span class="line">plus Z     m = m            -- 模式1</span><br><span class="line">plus (S n) m = S (plus n m) -- 模式2</span><br></pre></td></tr></table></figure>
<p>首先定义出了 plus 函数的类型，它是接收两个自然数，然后返回一个自然数的函数，这里使用了柯里化的表现方式。<br><code>plus Z m = m</code> 表示任何自然数加上零，都得自然数本身；<br><code>plus (S n) m = S (plus n m)</code> 表示任何两个自然数相加，都等于其中一个自然数的前趋和另一个自然相加结果的后继。这句话说起来比较绕，但是只要展开之后就比较容易理解了。</p>
<p>考察<code>1 + 1 = 2</code>，可以表达如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(S Z) # 1 是 0 的后继</span><br><span class="line">plus (S Z) (S Z) -- 1 + 1</span><br><span class="line">S (plus Z (S Z)) -- 根据模式2展开上面的式子</span><br><span class="line">(S (S Z))      -- 根据模式1展开上面的式子</span><br></pre></td></tr></table></figure>
<p><code>(S (S Z))</code> 就是自然数2</p>
<h4 id="2-2-定义乘法"><a href="#2-2-定义乘法" class="headerlink" title="2.2 定义乘法"></a>2.2 定义乘法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mult : Natural -&gt; Natural -&gt; Natural</span><br><span class="line">mult Z     m = Z</span><br><span class="line">mult (S n) m = plus m (mult n m)</span><br></pre></td></tr></table></figure>
<p><code>mult Z m = Z</code>表示任何自然数乘以零，都得零；<br><code>mult (S n) m = plus m (mult n m)</code>表示任何两个自然相乘，都等于其中一个自然数和另一个自然数的前趋相乘结果再加上这个自然数。</p>
<hr>
<p>学习资料<br>[1] <a href="https://github.com/idris-hackers/idris-mode">Idris mode</a><br>[2] <a href="http://fieldstrength.org/learn-idris/">Learn idris</a><br>[3] <a href="http://docs.idris-lang.org/en/latest/">Idris docs</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>idris</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程简介</title>
    <url>/2018/02/17/The-Simple-Summary-of-FP/</url>
    <content><![CDATA[<h3 id="函数式编程是什么"><a href="#函数式编程是什么" class="headerlink" title="函数式编程是什么"></a>函数式编程是什么</h3><blockquote>
<p>函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 – wiki</p>
</blockquote>
<h3 id="例子一-累加运算"><a href="#例子一-累加运算" class="headerlink" title="例子一 累加运算"></a>例子一 累加运算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum</span></span><br><span class="line">List&lt;Integer&gt; nums = Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">sum</span><span class="params">(List&lt;Integer&gt; nums)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Integer num : nums) &#123;</span><br><span class="line">		result += num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(nums); <span class="comment">// -&gt; 46</span></span><br></pre></td></tr></table></figure>
<p>同样的代码用 Java8 Stream 实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 10).stream().reduce(0, Integer::sum);</span><br></pre></td></tr></table></figure>
<p>同样的代码用 Clojure 实现</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">apply</span></span> + [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">10</span>]) <span class="comment">; -&gt; 46</span></span><br><span class="line">#_(<span class="name"><span class="built_in">reduce</span></span> + [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">10</span>])</span><br></pre></td></tr></table></figure>
<h3 id="例子二-fabonacci数列"><a href="#例子二-fabonacci数列" class="headerlink" title="例子二 fabonacci数列"></a>例子二 fabonacci数列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (number == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(number == <span class="number">2</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">3</span>; cnt &lt;= number; cnt++) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">		a = b;</span><br><span class="line">		b = c;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// java8</span><br><span class="line">Stream.iterate(new int[]&#123;1, 1&#125;, s -&gt; new int[]&#123;s[1], s[0] + s[1]&#125;)</span><br><span class="line">				.limit(10)</span><br><span class="line">				.map(n -&gt; n[1])</span><br><span class="line">				.collect(toList())</span><br><span class="line">// -&gt; [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">// clojure</span><br><span class="line">(<span class="name"><span class="built_in">-&gt;&gt;</span></span> (<span class="name"><span class="built_in">iterate</span></span> (<span class="name"><span class="built_in">fn</span></span> [[a b]] [b (<span class="name"><span class="built_in">+</span></span> a b)]) [<span class="number">1</span> <span class="number">1</span>])</span><br><span class="line">     (<span class="name"><span class="built_in">map</span></span> second)</span><br><span class="line">     (<span class="name"><span class="built_in">take</span></span> <span class="number">10</span>))</span><br><span class="line"><span class="comment">; -&gt; (1 2 3 5 8 13 21 34 55 89)  </span></span><br></pre></td></tr></table></figure>
<p>比起命令式的语言，函数式语言更加关注执行的结果，而非执行的过程。</p>
<h2 id="函数式编程的历史"><a href="#函数式编程的历史" class="headerlink" title="函数式编程的历史"></a>函数式编程的历史</h2><h3 id="从Hilbert-23个数学难题谈起"><a href="#从Hilbert-23个数学难题谈起" class="headerlink" title="从Hilbert 23个数学难题谈起"></a>从Hilbert 23个数学难题谈起</h3><p>1900年，Hilbert 提出了数学界悬而未决的10大问题，后续陆续添加成了23个问题，被称为著名的 Hilbert 23 Problem。针对其中第2个决定数学基础的问题——算术公理之相容性，年轻的哥德尔提出了哥德尔不完备定理，解决了这个问题形式化之后的前两点，即数学是完备的吗？数学是相容的吗？哥德尔用两条定理给出了否定的回答。所谓不完备，即系统中存在一个为真，但是无法在系统中推导出来的命题。比如：U说：“U在PM中不可证”。虽然和说谎者很类似，但其实有明显的差异。我们可以假设U为可证，那么可以推出PM是矛盾（不相容）的；但是假设U不可证，却推导不出PM是矛盾的。U的含义是在M中不可证，而事实上，它被证明不可证，所以U是PM中不可证的真命题。基于第一条不完备定理，又可以推导出第二条定理。如果一个（强度足以证明基本算术公理的）公理系统可以用来证明它自身的相容性，那么它是不相容的。</p>
<p>而最后一个问题，数学是确定的吗？也就是说，存在一个算法判定一个给定的命题是否是不确定的吗（Entscheidungsproblem 确定性问题）？这个问题引起了阿隆佐·邱奇和年轻的阿兰·图灵的兴趣。阿隆佐·邱奇的lambda calculus和图灵的图灵机构造出了可计算数，图灵的那篇论文  <em>ON COMPUTABLE NUMBERS, WITH AN APPLICATION TO THE ENTSCHEIDUNGSPROBLEM</em>  的意义不在于证明可计算数是否可数，而在于证明可判定性是否成立。在1936年他们对判定性问题分别独立给出了否定的答案。也就是现在被我们熟知的图灵停机问题：不存在这样一个程序（算法），它能够计算任何程序（算法）在给定输入上是否会结束（停机）。图灵借此发明了通用图灵机的概念，为后来的冯·诺依曼体系的计算机体系提供了理论基础。</p>
<h3 id="Lambda-Calculus"><a href="#Lambda-Calculus" class="headerlink" title="Lambda Calculus"></a>Lambda Calculus</h3><p><img src="http://upload-images.jianshu.io/upload_images/217988-bd2f325f4578f4c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lambda Calculus"></p>
<p>Lambda 表达式包含三个要素</p>
<ol>
<li>变量</li>
<li>lambda 抽象</li>
<li>lambda 应用<br>据此我们可以用函数给出布尔值的定义<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data BOOL = FALSE | TRUE</span><br><span class="line">TRUE = λx.λy.x</span><br><span class="line">FALSE = λx.λy.y</span><br><span class="line"></span><br><span class="line">not = λb.b FALSE TRUE</span><br><span class="line">and = λb1.λb2.b1 b2 FALSE</span><br><span class="line">or  = λb1.λb2.b1 TRUE b2</span><br><span class="line">xor = λb1.λb2.b1 (not b2) b2</span><br></pre></td></tr></table></figure>
自然数的定义<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data NAT = Z | S NAT</span><br><span class="line">0 = λf.λs.s</span><br><span class="line">1 = λf.λs.f s</span><br><span class="line">2 = λf.λs.f f s</span><br><span class="line"></span><br><span class="line">succ n = λf.λs.f (n f s)</span><br><span class="line">zero? n = n (λb.FALSE) TRUE</span><br><span class="line">add = succ n1 n2</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="函数式编程语言的发展"><a href="#函数式编程语言的发展" class="headerlink" title="函数式编程语言的发展"></a>函数式编程语言的发展</h3><p>在这之后，随着通用计算机的产生，人们发觉使用机器码写程序太没有效率。所以1956年左右，John Buckus发明了Fortran（FORmula TRANslating 的缩写）语言，如果对编译原理有了解，那么对BNF范式就不陌生了。与此同时，John McCarthy 发明了Lisp语言，现代的Clojure就是Lisp的方言之一。1966年，Niklaus Wirth发明了Pascal。1969年，Ken Thompson和Dennis Ritchie发明了C语言，过程式语言由于其高效和可移植性迅速崛起。1973年，Robin Milner 发明了ML（Meta Language），后来演变成了OCaml和Stardard ML。1977年，John Buckus在其图灵奖的演讲中创造了 Functional Programming 这个词。1990年，惰性求值的函数式编程语言 Haskell 1.0 发布。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-b32e43ff96d620f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编程语言发展历史"></p>
<h3 id="神奇的-Y-Combinator"><a href="#神奇的-Y-Combinator" class="headerlink" title="神奇的 Y Combinator"></a>神奇的 Y Combinator</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def Y (fn [f]</span><br><span class="line">         ((fn [x] (x x))</span><br><span class="line">          (fn [x]</span><br><span class="line">            (f (fn [y]</span><br><span class="line">                 ((x x) y)))))))</span><br></pre></td></tr></table></figure>

<h3 id="Lisp、ML以及Haskell的关系"><a href="#Lisp、ML以及Haskell的关系" class="headerlink" title="Lisp、ML以及Haskell的关系"></a>Lisp、ML以及Haskell的关系</h3><p>Lisp是动态语言，使用S表达式<br>ML和Haskell都是静态强类型函数式语言<br>ML是第一个使用Hindley-Milner type inference algorithm的语言<br>Lisp和ML都是call-by-value，但是Haskell则是call-by-name<br>Lisp和ML都是不纯的编程语言，但是Haskell是side effect free的</p>
<h2 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h2><p>函数是一等公民，指的是你可以将函数作为参数、返回值、数据结构存在，而且不仅可以用函数名引用，甚至可以匿名调用。</p>
<h3 id="1-作为参数"><a href="#1-作为参数" class="headerlink" title="1. 作为参数"></a>1. 作为参数</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">map</span></span> inc [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]) <span class="comment">;-&gt; (2 3 4 5 6) ;; inc is an argument</span></span><br></pre></td></tr></table></figure>
<h3 id="2-作为返回值"><a href="#2-作为返回值" class="headerlink" title="2. 作为返回值"></a>2. 作为返回值</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">defn</span> <span class="title">add</span> [num] </span><br><span class="line">    (<span class="name"><span class="built_in">fn</span></span> [other-num] (<span class="name"><span class="built_in">+</span></span> num other-num))) <span class="comment">;; as return-value</span></span><br><span class="line">(<span class="keyword">def</span> <span class="title">add-one</span> (<span class="name">add</span> <span class="number">1</span>))</span><br><span class="line">(<span class="name">add-one</span> <span class="number">2</span>) <span class="comment">;-&gt; 3</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">defn</span> <span class="title">flip</span> [f]  <span class="comment">;; as argument and return-value</span></span><br><span class="line">  (<span class="name"><span class="built_in">fn</span></span> [x y]</span><br><span class="line">    (<span class="name">f</span> y x)))</span><br></pre></td></tr></table></figure>
<h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3. 数据结构"></a>3. 数据结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def dictionary &#123;:a &quot;abandon&quot;&#125;) ;; map is also a function, data is code.</span><br><span class="line">(dictionary :a) ;-&gt; &quot;abandon&quot;</span><br><span class="line">(:a dictionary) ;-&gt; &quot;abandon&quot;</span><br></pre></td></tr></table></figure>
<h3 id="4-匿名函数"><a href="#4-匿名函数" class="headerlink" title="4. 匿名函数"></a>4. 匿名函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((fn [x] (* x x))</span><br><span class="line">        2) ;-&gt; 4</span><br><span class="line">    </span><br><span class="line">(map </span><br><span class="line">    (fn [num] (+ 1 num)) ;; anonymous function</span><br><span class="line">    [1 2 3 4 5]) ;-&gt; (2 3 4 5 6)</span><br></pre></td></tr></table></figure>
<h3 id="5-模块化"><a href="#5-模块化" class="headerlink" title="5. 模块化"></a>5. 模块化</h3><p>在面向对象中，对象是一等公民。所以我们处处要从对象的角度去考虑计算问题，然后产生一种共识——数据应该和它相关的操作放到一起，也就是我们所说的封装。确实没错，但是我们得知道封装的意义在哪里？功能内聚好理解（分块）和局部性影响（控制可变性）。函数式编程同样考虑这些，功能内聚不一定要用类的方式（考虑一下JS的prototype，也是一种面向对象），只要模块做得好，一样能达到效果。局部性影响，其本质是封装可变因素以避免其扩散到代码各处。函数式给出了自己的答案，消除可变因素。</p>
<p>高阶函数和惰性求值也非常有利于模块化。</p>
<h2 id="纯函数和不可变性"><a href="#纯函数和不可变性" class="headerlink" title="纯函数和不可变性"></a>纯函数和不可变性</h2><p>纯函数是指执行过程中没有副作用的函数，所谓副作用是说超出函数控制的操作，比如在执行过程中操作文件系统、数据库等外部资源。纯函数还具有引用透明性的特点，也就是同样的输入导致同样的输出，以至于完全可以用函数的值代替对函数的调用。</p>
<h3 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h3><p>举个例子：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">inc</span></span> <span class="number">1</span>) <span class="comment">; -&gt; 2</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">inc</span></span> (<span class="name"><span class="built_in">inc</span></span> <span class="number">1</span>)</span><br><span class="line">   (<span class="name"><span class="built_in">inc</span></span> <span class="number">2</span>))) <span class="comment">; -&gt; true</span></span><br></pre></td></tr></table></figure>
<p>你们可能就会问，这种东西究竟有什么用呢？纯函数可以很方便地进行缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn fibonacci [number]</span><br><span class="line">  (if (or (zero? number) (= 1 number)) 1</span><br><span class="line">      (+</span><br><span class="line">       (fibonacci (dec number))</span><br><span class="line">       (fibonacci (- number 2)))))</span><br><span class="line">(fibonacci 30) ; -&gt; &quot;Elapsed time: 185.690208 msecs&quot;</span><br><span class="line"></span><br><span class="line">(def fibonacci</span><br><span class="line">  (memoize (fn [number] ;;</span><br><span class="line">             (if (or (zero? number) (= 1 number)) 1</span><br><span class="line">                 (+</span><br><span class="line">                  (fibonacci (dec number))</span><br><span class="line">                  (fibonacci (- number 2)))))))</span><br><span class="line">(fibonacci 30) ; -&gt; &quot;Elapsed time: 0.437114 msecs&quot;</span><br></pre></td></tr></table></figure>
<h3 id="不可变计算"><a href="#不可变计算" class="headerlink" title="不可变计算"></a>不可变计算</h3><p>谈到不可变性，我们做个游戏。统计在座的一共有多少人数。我们都知道从某个人开始依次报数，最后得到的数字就是总人数，其实这就是一种不可变计算的游戏，为什么这么说呢？因为报数其实一个计算的过程，第一个人计算出1这个数，传递给第二个人。然后第二个人拿着前面的1进行加一操作，然后把结果2传递给后面的人做加法，以此类推。为了提高统计的效率，我也可以进行分组，然后每组自行报数，最后统计结果。但是如果我在白板上写个数字1，然后让大家来过来该这个数字，很大可能会出现错误，因为这个数字成为了竞态条件。在多并发的情况下，就得用读写锁来控制。所以不可变性特别利于并发。<br><img src="http://upload-images.jianshu.io/upload_images/217988-83061fa854cfadf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不可变性"></p>
<h3 id="不可变的链式结构"><a href="#不可变的链式结构" class="headerlink" title="不可变的链式结构"></a>不可变的链式结构</h3><p>好了，现在我们有个新的需求，设计一个不可变列表收集大家的名字。每个节点存储一个姓名的字符串，并且有个指针指向下一个节点。但是这也打破了列表的不可变性。怎么办？我们可以把新的节点指向旧有的列表，然后返回一个新的列表。这就是不可变列表实现的机制。随便一提，这也是区块链不可变特征的由来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-f83728f3beea90e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不可变的链式结构"></p>
<p>Clojure的创造者Rich Hickey扩展了Ideal Hash Tree数据结构，实现了Persistent Vector。由于此处的叶子节点可以扩展成32个，所以可以大量存储数据。利用Ideal Hash Tree的特点可以快速索引出数据，与此同时，数据的“增删改”也能做到近常数化的时间，并且总是产生新的数据结构替换原有的数据结构，即一种不可变的链式存储结构。<br><img src="http://upload-images.jianshu.io/upload_images/217988-db581f0f87265914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Clojure Persistent Vector"></p>
<h3 id="不可变的树状结构"><a href="#不可变的树状结构" class="headerlink" title="不可变的树状结构"></a>不可变的树状结构</h3><p>Zipper数据结构类似于文本编辑器中的 gap buffer，编辑文本时，光标左边和右边分别是独立的buffer，光标处也是单独的buffer，这样便可以方便地添加文字，也很方便删除左右buffer中的文字；移动光标会涉及buffer之间的拷贝。基本上能在常数时间内完成编辑。Zipper数据结构模仿了这种方式，能在常数时间内完成树的编辑工作，也能很快地重新构建一棵树。<br><img src="http://upload-images.jianshu.io/upload_images/217988-6017ad15b573ab02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不可变的树状结构"></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>可计算很大问题就是得实现递归功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn reverse-seq [coll]</span><br><span class="line">  (when-let [elem (first coll)]</span><br><span class="line">    (concat (reverse-seq (rest coll)) [elem])))</span><br><span class="line">(reverse-seq [1 2 3]) ; -&gt; (3 2 1)</span><br></pre></td></tr></table></figure>
<p>和循环无异的尾递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn gcd [&amp; nums]</span><br><span class="line">  (reduce #(if (zero? %2)</span><br><span class="line">                %</span><br><span class="line">                (recur %2 (mod % %2))) nums))</span><br><span class="line">(gcd 8 16) ; -&gt; 8                </span><br></pre></td></tr></table></figure>
<h2 id="生成式测试"><a href="#生成式测试" class="headerlink" title="生成式测试"></a>生成式测试</h2><p>生成式测试会基于输入假设输出，并且生成许多可能的数据验证假设的正确性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn add [a b]</span><br><span class="line">  (+ a b))</span><br><span class="line">;; 任取两个整数，把a和b加起来的结果减去a总会得到b。</span><br><span class="line">(def test-add</span><br><span class="line">  (prop/for-all [a (gen/int)</span><br><span class="line">                 b (gen/int)]</span><br><span class="line">                (= (- (add a b) a) b)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(tc/quick-check 100 test-add)</span><br><span class="line">; -&gt; &#123;:result true, :num-tests 100, :seed 1515935038284&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果表明，刚才运行了100组测试，并且都通过了。理论上，程序可以生成无数的测试数据来验证add方法的正确性。即便不能穷尽，我们也获得一组统计上的数字，而不仅仅是几个纯手工挑选的用例。</p>
<h2 id="抽象是什么"><a href="#抽象是什么" class="headerlink" title="抽象是什么"></a>抽象是什么</h2><p>抽取共性，封装细节，忘记不重要的差异点。这样的好处是可以做到局部化影响和延迟决策。<br><img src="http://upload-images.jianshu.io/upload_images/217988-f9b16b9dc18ba66c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="抽象屏障"></p>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>命名就是一种抽象，重构中最重要的技法就是重命名和提取小函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(* 3 3 3)</span><br><span class="line">(* x x x)</span><br><span class="line">(* y y y)</span><br><span class="line">-&gt;</span><br><span class="line">(defn cube [x]</span><br><span class="line">  (* x x x))</span><br></pre></td></tr></table></figure>
<h3 id="延迟决策"><a href="#延迟决策" class="headerlink" title="延迟决策"></a>延迟决策</h3><p>例如：我们定义数对 pair</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair:: (cons x y)</span><br><span class="line">first pair -&gt; x</span><br><span class="line">second pair -&gt; y</span><br></pre></td></tr></table></figure>
<p>那么它的具体实现会是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn cons [x y]</span><br><span class="line">  (fn [m]</span><br><span class="line">    (cond (= m 0) x</span><br><span class="line">          (= m 1) y)))</span><br><span class="line">(defn first [z]</span><br><span class="line">  (z 0))</span><br><span class="line">(defn second [z]</span><br><span class="line">  (z 1))</span><br></pre></td></tr></table></figure>
<p>也可以是这样的，还可以是其它各种各样的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn cons [x y]</span><br><span class="line">  (fn [b]</span><br><span class="line">    (b x y))</span><br><span class="line">(defn first [z]</span><br><span class="line">    (z (fn [x y] x)))</span><br><span class="line">(defn second [z]</span><br><span class="line">    (z (fn [x y] y)))</span><br></pre></td></tr></table></figure>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数就是可以接收函数的函数，高阶函数提供了足够的抽象，屏蔽了很多底层的实现细节。比如Clojure中的<code>map</code>高阶函数，它接收<code>(fn [v] ...)</code>，把一组数据映射成另外一组数据。</p>
<h3 id="过程抽象"><a href="#过程抽象" class="headerlink" title="过程抽象"></a>过程抽象</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">map</span></span> inc [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]) <span class="comment">; -&gt; (2 3 4 5 6)</span></span><br></pre></td></tr></table></figure>
<p>这些函数抽象出映射这样语义，除了容易记忆，还能很方便地重新编写成高效的底层实现。也就是说，一旦出现了更高效的<code>map</code>实现算法，现有的代码都能立刻从中受益。</p>
<h2 id="函数的组合"><a href="#函数的组合" class="headerlink" title="函数的组合"></a>函数的组合</h2><p>函数组合之后会产生巨大的能量</p>
<h3 id="神奇的加法"><a href="#神奇的加法" class="headerlink" title="神奇的加法"></a>神奇的加法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(((comp (map inc) (filter odd?)) +) 1 2) ; -&gt; 4</span><br></pre></td></tr></table></figure>
<p>怎么去理解这个函数的组合？我们给它取个好听的名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def special+ ((comp (map inc) (filter odd?)) +))</span><br><span class="line">(special+ 1 2) ; -&gt; 4</span><br><span class="line"></span><br><span class="line">; &lt;=&gt; 等价于</span><br><span class="line">(if (odd? (inc 2))</span><br><span class="line">    (+ 1 3))</span><br><span class="line">    1)</span><br></pre></td></tr></table></figure>
<p>这个未必是个好的组合方式，但是不可否认的是，我们可以用这些随意地将这些函数组合到一起，得到我们想要的结果。</p>
<h3 id="transducer"><a href="#transducer" class="headerlink" title="transducer"></a>transducer</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(def xf (comp (filter odd?) (take 10)))</span><br><span class="line">(transduce xf conj (range))</span><br><span class="line">;; [1 3 5 7 9 11 13 15 17 19]</span><br></pre></td></tr></table></figure>
<p>这里直接将求值延迟到了<code>transduce</code>计算的时候，换句话说，<code>xf</code>定义了一种过程：filter出奇数并取出前10个元素。同等的代码，如果用表达式直接书写的话，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(-&gt;&gt; (range)</span><br><span class="line">     (filter odd?)</span><br><span class="line">     (take 10))</span><br></pre></td></tr></table></figure>
<p>这里的问题就是我们没能使用高阶函数抽象出过程，如果把 conj 换成其他的reduce运算，现在的过程无法支撑，但是tranducers可以！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(transduce xf + (range)) ;-&gt; 100</span><br></pre></td></tr></table></figure>
<p>我们再看一个tranducer的神奇使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn log [&amp; [idx]]</span><br><span class="line">  (fn [rf]</span><br><span class="line">    (fn</span><br><span class="line">      ([] (rf))</span><br><span class="line">      ([result] (rf result))</span><br><span class="line">      ([result el]</span><br><span class="line">        (let [n-step (if idx (str &quot;Step: &quot; idx &quot;. &quot;) &quot;&quot;)]</span><br><span class="line">          (println (format &quot;%sResult: %s, Item: %s&quot; n-step result el)))</span><br><span class="line">        (rf result el)))))</span><br><span class="line"></span><br><span class="line">(def ^:dynamic *dbg?* false)</span><br><span class="line"></span><br><span class="line">(defn comp* [&amp; xforms]</span><br><span class="line">  (apply comp</span><br><span class="line">         (if *dbg?*</span><br><span class="line">           (-&gt;&gt; (range)</span><br><span class="line">                (map log)</span><br><span class="line">                (interleave xforms))</span><br><span class="line">           xforms)))</span><br><span class="line"></span><br><span class="line">(binding [*dbg?* true]</span><br><span class="line">  (transduce</span><br><span class="line">   (comp*</span><br><span class="line">    (map inc)</span><br><span class="line">    (filter odd?))</span><br><span class="line">   +</span><br><span class="line">   (range 5))) ;; -&gt; 9</span><br><span class="line">   </span><br><span class="line">Step: 0. Result: 0, Item: 1</span><br><span class="line">Step: 1. Result: 0, Item: 1</span><br><span class="line">Step: 0. Result: 1, Item: 2</span><br><span class="line">Step: 0. Result: 1, Item: 3</span><br><span class="line">Step: 1. Result: 1, Item: 3</span><br><span class="line">Step: 0. Result: 4, Item: 4</span><br><span class="line">Step: 0. Result: 4, Item: 5</span><br><span class="line">Step: 1. Result: 4, Item: 5</span><br></pre></td></tr></table></figure>
<p>之所以会出现上述的结果，是因为<code>interleave xforms</code>将<code>(map inc)</code>以及<code>(filter odd?)</code>和logs进行了交叉，得到的结果是<code>(comp (map inc) (log) (filter odd?) (log))</code>，所以如果是偶数就会被filter清除，看不见log了。</p>
<p>首先一定得理解：每个tranducer函数都是同构的！<br>形式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defn m [f]</span><br><span class="line">    (fn [rf] </span><br><span class="line">        (fn [result elem]</span><br><span class="line">            (rf result (f elem)))))</span><br></pre></td></tr></table></figure>
<p>这意味着<code>(m f)</code>的函数都是可以组合的，组合的形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(comp (m f) (m1 f1) ...)</span><br></pre></td></tr></table></figure>
<p>展开之后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((m f) </span><br><span class="line">    ((m1 f1) </span><br><span class="line">        ((m2 f2) ...)))</span><br><span class="line">-&gt;</span><br><span class="line">(fn [result elem]</span><br><span class="line">    (((m1 f1) </span><br><span class="line">        ((m2 f2) ...)) result (f elem)))</span><br></pre></td></tr></table></figure>
<p>所以可以看到第一个执行的一定是 comp 的首个 reducing function 参数。故：</p>
<ol>
<li>xform 作为组合的前提</li>
<li>执行顺序从左到右；</li>
<li><code>+</code> 作为 reducing function 最后执行；</li>
</ol>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p>什么是<a href="https://www.jianshu.com/p/324c9ce77317">Monad</a>呢？A monad is just a monoid in the category of endofunctors.</p>
<ol>
<li>Identity—For a monad m, m flatMap unit &#x3D;&gt; m </li>
<li>Unit—For a monad m, unit(v) flatMap f &#x3D;&gt; f(v) </li>
<li>Associativity—For a monad m, m flatMap g flatMap h &#x3D;&gt; m flatMap {x &#x3D;&gt; g(x) flatMap h} <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// java8 实现的 9*9 乘法表</span><br><span class="line">public class ListMonad&lt;T&gt; &#123;</span><br><span class="line">    private List&lt;T&gt; elements;</span><br><span class="line"></span><br><span class="line">    private ListMonad(T elem) &#123;</span><br><span class="line">        this.elements = singletonList(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ListMonad(List&lt;T&gt; elems) &#123;</span><br><span class="line">        this.elements = elems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;U&gt; ListMonad&lt;U&gt; flatmap(Function&lt;T, ListMonad&lt;U&gt;&gt; fn) &#123;</span><br><span class="line">        List&lt;U&gt; newElements = new ArrayList&lt;&gt;();</span><br><span class="line">        this.elements.forEach(elem -&gt; newElements.addAll(fn.apply(elem).elements));</span><br><span class="line">        return new ListMonad&lt;&gt;(newElements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;X&gt; ListMonad&lt;X&gt; uint(X elem) &#123;</span><br><span class="line">        return new ListMonad&lt;&gt;(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;U&gt; ListMonad&lt;U&gt; apply(ListMonad&lt;Function&lt;T, U&gt;&gt; m) &#123;</span><br><span class="line">        return m.flatmap(this::map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;U&gt; ListMonad&lt;U&gt; map(Function&lt;T, U&gt; fn) &#123;</span><br><span class="line">        return flatmap(t -&gt; uint(fn.apply(t)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ListMonad&lt;Integer&gt; m = new ListMonad&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9));</span><br><span class="line">        ListMonad&lt;Integer&gt; m1 = new ListMonad&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9));</span><br><span class="line"></span><br><span class="line">        ListMonad&lt;Integer&gt; list = m.apply(m1.map(x -&gt; y -&gt; x * y));</span><br><span class="line">        // [1...81]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="表达式优于语句"><a href="#表达式优于语句" class="headerlink" title="表达式优于语句"></a>表达式优于语句</h2><h3 id="S表达式"><a href="#S表达式" class="headerlink" title="S表达式"></a>S表达式</h3><ol>
<li>原子，或者；</li>
<li>形式为 (x • y) 的表达式，其中x和y也是S表达式。</li>
</ol>
<p>举个例子，递增一组数据，过滤奇数，然后进行排序，最终取出第一个。如果取不到，返回<code>:not-found</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(-&gt; [1 2 3] </span><br><span class="line">    (-&gt;&gt; (map inc) </span><br><span class="line">         (filter odd?) </span><br><span class="line">         (sort) </span><br><span class="line">         (first)) </span><br><span class="line">    (or :not-found))</span><br><span class="line">; -&gt; 3 </span><br><span class="line">(-&gt; [1 1 3] </span><br><span class="line">    (-&gt;&gt; (map inc) </span><br><span class="line">         (filter odd?) </span><br><span class="line">         (sort) </span><br><span class="line">         (first)) </span><br><span class="line">    (or :not-found)</span><br><span class="line">; -&gt; :not-found    </span><br></pre></td></tr></table></figure>
<p>当然你也可以写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if-let [r (first (sort (filter odd? (map inc [1 1 1]))))] </span><br><span class="line">    r </span><br><span class="line">    :not-found)</span><br><span class="line">; -&gt; :not-found    </span><br></pre></td></tr></table></figure>
<p>其实两者都是S表达式，但是下面的写法更加偏向于语句。从串联起来读来讲，前者明显是由于后者的。这要是放在其他函数式语言上，效果更加显著。比如下面重构if-else控制语句到Optional类型。</p>
<h3 id="if-else-Optional"><a href="#if-else-Optional" class="headerlink" title="if-else -&gt; Optional"></a>if-else -&gt; Optional</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Rule&gt; rule = ruleOf(id);</span><br><span class="line"><span class="keyword">if</span>(rule.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">return</span> transform(rule.get());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Rule <span class="title function_">transform</span><span class="params">(Rule rule)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Rule.builder()</span><br><span class="line">                .withName(<span class="string">&quot;No.&quot;</span> + rule.getId())</span><br><span class="line">                .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是典型的语句可以重构到表达式的场景，关键是怎么重构呢？<br>第一步，调转<code>if</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Optional</span> <span class="variable">rule</span> <span class="operator">=</span> ruleOf(id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!rule.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> transform(rule.get());</span><br></pre></td></tr></table></figure>
<p>第二步，<code>Optional.map</code>函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">return</span> rule.map(r -&gt; transform(r)).get();</span><br></pre></td></tr></table></figure>
<p>第三步，<code>inline transform</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">rule.map(r -&gt; Rule.builder()</span><br><span class="line">                    .withName(&quot;No.&quot; + r.getId())</span><br><span class="line">                    .build()).get();</span><br></pre></td></tr></table></figure>
<p>第四步，<code>Optional.orElseThrow</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">rule.map(r -&gt; Rule.builder()</span><br><span class="line">                    .withName(&quot;No.&quot; + r.getId())</span><br><span class="line">                    .build())</span><br><span class="line">    .orElseThrow(() -&gt; new RuntimeException());</span><br></pre></td></tr></table></figure>
<p>第五步，注<code>if</code>释语句中的<code>throw new RuntimeException()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!rule.isPresent()) &#123;</span><br><span class="line">   // throw new RuntimeException();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这时候发现语句中为空，即可将整个语句删除。可以考虑<code>inline rule</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ruleOf(id).map(r -&gt; Rule.builder()</span><br><span class="line">                    .withName(&quot;No.&quot; + r.getId())</span><br><span class="line">                    .build())</span><br><span class="line">    .orElseThrow(() -&gt; new RuntimeException());</span><br></pre></td></tr></table></figure>
<p>完毕。</p>
<h2 id="我们认识事物的方式"><a href="#我们认识事物的方式" class="headerlink" title="我们认识事物的方式"></a>我们认识事物的方式</h2><ol>
<li>把几个简单的想法合并成一个复合概念，从而创造出所有复杂的概念。</li>
<li>简单的或复杂的两种思想融合在一起，并立即把它们联系起来，不要把它们统一起来，从而得到它所有的关系思想。</li>
<li>把他们与其他所有陪伴他们的真实存在的想法分开：这就是所谓的抽象，因此所有的一般想法都是被提出来的。</li>
</ol>
<h2 id="推荐的书籍"><a href="#推荐的书籍" class="headerlink" title="推荐的书籍"></a>推荐的书籍</h2><ol>
<li><a href="https://book.douban.com/subject/1391740/">逻辑的引擎</a></li>
<li><a href="https://book.douban.com/subject/26587213/">函数式编程思维</a></li>
<li><a href="https://book.douban.com/subject/1148282/">算机程序的构造和解释</a><br><img src="http://upload-images.jianshu.io/upload_images/217988-8bb6c8f3354a5640.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="推荐的书籍"></li>
</ol>
<hr>
<p>参考资料</p>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98">图灵停机问题</a></li>
<li><a href="http://blog.csdn.net/pongba/article/details/1336028">康托尔、哥德尔、图灵 - 永恒的金色对角线</a></li>
<li><a href="http://blog.klipse.tech/lambda/2016/08/07/pure-y-combinator-clojure.html">Y combinator in Clojure</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%9A%8423%E4%B8%AA%E9%97%AE%E9%A2%98">希尔伯特的23个问题</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28112037">再谈哥德尔不完备定理</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">wiki 函数式编程</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97">lambda 演算</a></li>
<li><a href="http://athena.ecs.csus.edu/~csc135fp/project/history.html">History of functional programming</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24648375">函数式编程的早期历史</a></li>
<li><a href="http://www.sohu.com/a/164321809_136745">走进计算机文化史</a></li>
<li><a href="https://sarabander.github.io/sicp/html/index.xhtml">SICP</a></li>
<li><a href="http://www.math.cmu.edu/~wgunther/talks/gsLambdaCalculus.pdf">Lambda Calculus and the Decision Problem</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>FP</tag>
      </tags>
  </entry>
  <entry>
    <title>我是怎样学习新编程语言的</title>
    <url>/2018/07/18/the-joy-of-learning-new-programming-language/</url>
    <content><![CDATA[<p><img src="/images/Elixir.webp" alt="Elixir"></p>
<h2 id="说服自己"><a href="#说服自己" class="headerlink" title="说服自己"></a>说服自己</h2><p>学习新的编程语言的最终目的是解决实际问题。掌握编程语言的过程，在某种程度上近似学习一种新的工程实践。不仅解决问题固然可乐，学习的过程也同样充满了新鲜感，不过需要谨防的是新鲜感带来的胜任力错觉。</p>
<p>胜任力错觉指的是反复接触新东西，发现不用花费什么气力就理解了其中所有的内容。说的简单点，就是自以为是。这种胜任力错觉导致最常见的后果是以为掌握了某种技能，真正开始解决问题时，要么是半天摸不着头绪，要么就是处处掣肘。所以我始终相信，阅读是一码事，理解是一码事，掌握还是另一码事，所谓一码归一码，大抵就是这么回事。</p>
<p><del>以终为始，方得始终。老子（真·老子，非我）也说，慎终如始，则无败事。这里的“终”就是目标，在软件工程中，有一种实践很好得反映了这种做事方式——测试驱动开发。借我司的一位牛人的原话：看一个人会不会测试驱动开发，不是看他的测试写得好不好，而是要看他是不是始终从测试出发去解决问题。脑子里条件反射的就是测试该怎么测？这种才是测试驱动开发的实质。</del></p>
<p>学习，说白了就是一个不会到会的过程，这里头最难的是学会了什么？在学习方法上，我们很多时候喜欢遵循前人的套路，美其名曰知识体系化。我承认体系是前人经验和群体智慧的积累，但是学习体系不代表你具备形成体系的能力，就像你学习了著名开发框架（Spring or Rails）也不会说你能开发这套框架一样。学习的关键还是发散、收敛和再发散、再收敛的渐进过程，感性的定性分析到理性的定量分析，在不断丰富和修正认知，处处用实践检验认知。这种过程坚持下来，得到就不单单是知识，可能是元知识（方法论）或者智慧。</p>
<p>看书抄代码是个学习的好方法，不过书中的例子一般都被加工（简化）过，我们很容易陷入套路中，谨记胜任力陷阱。比较推荐的方式，自己认准一段有用的程序，反复练习（也可以每次增加些体系化的功能）直到娴熟。在接触新语言时，不去看一套完整的语言体系，而是事先把这段程序可能用到的基本类型、数据结构、流程控制结构、模块化和功能组件列出来，然后去找它们在这门语言中对应的实现。</p>
<h2 id="有目的地试错"><a href="#有目的地试错" class="headerlink" title="有目的地试错"></a>有目的地试错</h2><p>我常用的练手程序叫<code>tree</code>，功能是<em>list contents of directories in a tree-like format.</em> 这个程序需要用到的基本构件有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本类型（basic type)</span><br><span class="line">1. str</span><br><span class="line"> </span><br><span class="line">数据结构（data structure）</span><br><span class="line">1. list</span><br><span class="line">2. map</span><br><span class="line"></span><br><span class="line">流程控制结构（control flow structure）</span><br><span class="line">1. if, else</span><br><span class="line">2. recursion</span><br><span class="line"></span><br><span class="line">模块化（modulize）</span><br><span class="line">1. function</span><br><span class="line">2. module/namspace/package</span><br><span class="line"></span><br><span class="line">功能组件（function components）</span><br><span class="line">1. IO</span><br><span class="line">2. File</span><br><span class="line">3. Path</span><br></pre></td></tr></table></figure>

<p>分类清晰之后，对应找起来很方便，有的基本不用找，经验足矣。现在的编程语言基本都有<em>repl</em>，多尝试几遍就有了感性认识。我说的很轻松，但是如果不去尝试，一样会难住。Elixir中有<code>iex</code>命令作为<em>repl</em>，而且这门语言深受Clojure的影响，尤其是文档和例子方面很充足，对于初学者再友好不过。</p>
<h3 id="换种思维"><a href="#换种思维" class="headerlink" title="换种思维"></a>换种思维</h3><p>在编写<code>tree</code>的过程中，我会时不时停下来思考Elixir在某个功能点上应该怎么用才好？因为历史上，把Java的代码写成C风格的人不在少数，这足以让人警惕。再说，学会用新语言的思维方式编程是我初始的目的之一。</p>
<p>这里举个例子，map的key使用哪种基本类型会比较合适？Clojure中有keyword，如<code>&#123;:name &quot;clojure&quot;&#125;</code>，而Python中并没有这样的数据类型，我只好使用<code>&#123;&#39;name&#39;: &quot;python&quot;&#125;</code>，那么Elixir呢？它推荐的是atom&#x2F;symbol，<code>%&#123;:name =&gt; &quot;elixir&quot;&#125; #or %&#123;name: &quot;elixir&quot;&#125;</code></p>
<p>遇到需要join path的时候，凭借原来的经验，我会去寻找<code>Path</code>模块。具体可以去问谷歌，也可以问<em>repl</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iex&lt;1&gt; h Path.join</span><br><span class="line">or</span><br><span class="line">iex&lt;1&gt; Path.join &lt;TAB&gt; #用tab键</span><br><span class="line">join/1    join/2</span><br></pre></td></tr></table></figure>
<p>看到<code>join/1 join/2</code>的时候，我有些许迷茫，但是很快就变成了欣喜。我们知道，在动态类型语言中，arity指的是方法参数的个数，这里的<code>1和2</code>其实表明的就是join有两个重载的方法，分别接受一个参数和两个参数。更进一步，arity是方法（函数）实现静态多态的依据之一。再进一步，多态是函数的特性，而非OO中固化下来的概念——类的特性。</p>
<h3 id="组织代码"><a href="#组织代码" class="headerlink" title="组织代码"></a>组织代码</h3><p>上面的验证只需要<em>repl</em>就足够了。但是，真正编写还是得有组织和结构。软件工程中，控制复杂度（复杂度从来不会被消除）的基本法则就是模块化。这就引出了module和function，还有对模块可见性（private, public etc.）的修饰。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defmodule Tree do</span><br><span class="line">  defp tree_format(parent_dir, dir_name) do</span><br><span class="line">    %&#123;:name =&gt; dir_name, :children =&gt; []&#125;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><code>defp</code>定义了一个私有的方法<code>tree_format</code>，它是用来格式化目录的。目录结构是树形结构，所以很容易递归实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defp children(path) do</span><br><span class="line">  if (path |&gt; File.dir?) do</span><br><span class="line">    File.ls!(path) |&gt; Enum.map(fn f -&gt; tree_format(path, f) end)</span><br><span class="line">  else</span><br><span class="line">    []</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">defp tree_format(parent_dir \\ &quot;.&quot;, dir_name) do</span><br><span class="line">  %&#123;:name =&gt; dir_name, :children =&gt; Path.join(parent_dir, dir_name) |&gt; children&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>在利用递归的过程中，我使用<code>File.ls!</code>（查文档，注意!号）列出子目录，然后递归地格式化。这些都比较好理解，不过这里其实出现了两个新的玩意（当然也不是一蹴而就的，认识之后才重构成这样）。一个是<code>\\ &quot;.&quot;</code>，还有一个是<code>|&gt;</code>。第一个比较容易猜，叫做默认参数（default arguments）；第二个有Clojure基础的也手到擒来，叫做管道操作符（pipe operator），用来将左边表达式的结果传入右边方法的首个参数。这里就是<code>children(path)</code>的<code>path</code>.</p>
<h3 id="结构，解构"><a href="#结构，解构" class="headerlink" title="结构，解构"></a>结构，解构</h3><p>完成目录结构的格式化，接下来需要做的是渲染这组树状的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defp decorate(is_last?, [parent | children]) do</span><br><span class="line">  prefix_first = (if (is_last?), do: &quot;└── &quot;, else: &quot;├── &quot;)</span><br><span class="line">  prefix_rest = (if (is_last?), do: &quot;    &quot;, else: &quot;│   &quot;)</span><br><span class="line">  [prefix_first &lt;&gt; parent | children |&gt; Enum.map(fn child -&gt; prefix_rest &lt;&gt; child end)]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">defp render_tree(%&#123;name: dir_name, children: children&#125;) do</span><br><span class="line">  [dir_name </span><br><span class="line">   | children </span><br><span class="line">   |&gt; Enum.with_index(1)</span><br><span class="line">   |&gt; Enum.map(fn &#123;child, index&#125; -&gt; decorate(length(children) == index, render_tree(child)) end) </span><br><span class="line">   |&gt; Enum.flat_map(fn x -&gt; x end)]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>到这里，我学到的是参数解构（arguments destructing），<code>map-indexed</code>的新实现，字符串的拼接（string concatenation）还有列表元素的前置操作。</p>
<p>Elixir和所有函数式编程语言一样，具备强大的模式匹配（Pattern matching）的功能，参数解构其实就是其中的一个应用场景。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;name: dir_name, children: children&#125;</span><br><span class="line">matching</span><br><span class="line">%&#123;:name =&gt; &quot;.&quot;, :children =&gt; [&quot;tree.exs&quot;]&#125;</span><br><span class="line"># -&gt;</span><br><span class="line">dir_name == &quot;.&quot;</span><br><span class="line">children == [&quot;tree.exs&quot;]</span><br></pre></td></tr></table></figure>

<p>渲染的过程也是递归的。最终返回的是一个加上分支标识前缀的列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[dir_name | children]</span><br></pre></td></tr></table></figure>
<p>这是一种将<code>dir_name</code>前置到<code>children</code>列表头部，形成新列表的做法。和Clojure（绝大数Lisp）中的<code>(cons dir_name children)</code>类似。</p>
<p>操作符<code>|</code>除了可以前置列表元素，递归解构也是一把好手。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defp decorate(is_last?, [parent | children]) do</span><br><span class="line">  ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>参数列表中的<code>[parent | children]</code>，解构出了列表的head和rest，这对于递归简直就是福音。</p>
<p>在添加前缀的步骤<code>[prefix_first &lt;&gt; parent...]</code>中，经验里字符串的拼接常用符号<code>+</code>不起作用了，换成了<code>&lt;&gt;</code>，这个是靠试错得出来的。</p>
<p>除了说到的这部分内容，我还运用了<code>Enum.map, Enum.with_index, Enum.flat_map</code>等函数式语言的标配。这些零散的知识点，可以添加到基本构件中，以便持续改进。</p>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>程序要执行，就需要一个入口。每次我都会猜猜<code>argv</code>会在哪里出现呢？是<code>sys</code>(Python)，<code>os</code>(Go)，还是<code>process</code>(Node.js)，这回又猜错了，Elixir管这个叫做<code>System</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  def main([dir | _]) do</span><br><span class="line">    dir |&gt; tree_format |&gt; render_tree |&gt; Enum.join(&quot;\n&quot;) |&gt; IO.puts</span><br><span class="line">  end</span><br><span class="line"># ---</span><br><span class="line">Tree.main(System.argv)</span><br><span class="line"># ---</span><br><span class="line">$ elixir tree.exs .</span><br></pre></td></tr></table></figure>

<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>这里重构的目的是让程序更加贴近Elixir的表达习惯，那么哪里不是很符合Elixir风格呢？我注意到了<code>if...else</code>，可以考虑模式匹配实现多态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defp children(path) do</span><br><span class="line">  if (path |&gt; File.dir?) do</span><br><span class="line">    File.ls!(path) |&gt; Enum.map(fn f -&gt; tree_format(path, f) end)</span><br><span class="line">  else</span><br><span class="line">    []</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><code>File.ls!</code>中的<code>!</code>表示如果指定目录有问题，函数会抛出error或者异常。然而，Elixir还给出了一个<code>File.ls</code>方法，即便出错，也不会有抛出的动作，而是返回<code>&#123;:error, ...&#125;</code>的元组，至于正常结果，则是<code>&#123;:ok, ...&#125;</code>. 这恰恰可以使用模式匹配做动态分派了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defp children(parent) do</span><br><span class="line">  children(parent |&gt; File.ls, parent)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">defp children(&#123;:error, _&#125;, parent) do</span><br><span class="line">  []</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">defp children(&#123;:ok, sub_dir&#125;, parent) do</span><br><span class="line">    sub_dir |&gt; Enum.map(fn child -&gt; tree_format(parent, child) end)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>一旦<code> children(parent |&gt; File.ls, parent)</code>中的<code>parent</code>不是目录，<code>File.ls</code>返回的就会是<code>&#123;:error, ...&#125;</code>元组，它会被分派到对应的方法上，这里直接返回一个空的列表。反之，我们就可以拿到解构之后的子目录<code>sub_dir</code>进行交互递归，实现全部子目录的格式化。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在学习Elixir的过程中我收获了很多乐趣，不过，这离掌握Elixir还有很远的距离。我曾经看过一部科幻电影“降临”，剧情受到了萨丕尔-沃夫假说（语言相对性原理）的影响，这个假说提到：人类的思考模式受到其使用语言的影响，因而对同一事物时可能会有不同的看法。既然如此，那么自然语言也好，编程语言也罢，如果能换种思维方式解决同一种问题，说不定能收获些奇奇怪怪的东西，编程之路，道阻且长，开心就好。 – 2018-06-08</p>
<hr>
<p><a href="https://www.jianshu.com/p/c65cbbbd2826">如何高效地学习编程语言</a><br><a href="https://www.jianshu.com/p/0bc3f56500ef">怎样才算学会Python</a><br><a href="https://elixir-lang.org/">Elixir</a><br><a href="https://zh.wikipedia.org/wiki/%E8%96%A9%E4%B8%95%E7%88%BE-%E6%B2%83%E5%A4%AB%E5%81%87%E8%AA%AA">萨丕尔-沃夫假说</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>elixir</tag>
      </tags>
  </entry>
  <entry>
    <title>维多利亚时代的互联网</title>
    <url>/2018/02/04/the-victorian-internet/</url>
    <content><![CDATA[<blockquote>
<p>人类互相交流的欲望从未减弱过。</p>
</blockquote>
<h2 id="作者和书"><a href="#作者和书" class="headerlink" title="作者和书"></a>作者和书</h2><p>这本书是汤姆·斯坦迪奇（Tom Standage）于1997年完成，1998年9月第一次出版。中文版是后浪|江西出版社于2017-8年出版。作者毕业于牛津大学，主修工程学和电脑科技，在《经济学人》杂志科技版担任主编。出版过的图书作品有《从莎草纸到互联网》、《六个瓶子里的世界史》等，本书是其代表作和畅销之作，已被拍成纪录片。</p>
<h2 id="电报简史"><a href="#电报简史" class="headerlink" title="电报简史"></a>电报简史</h2><p>脑图见文末。本书的概述请见简友<a href="https://www.jianshu.com/u/9595e1cb4e70">半目李</a> 的<a href="https://www.jianshu.com/p/07f5c2ca5672">《当时的明月换拨人看》</a></p>
<p>我们沿着时间之线溯回到故事源头。1746年法国著名科学家、修道院院长诺莱做了一个电流传导的实验，成功证明了电流可以完成长距离即时传播。可是在那之后漫长的一百年，电流传播信息却并未得到发展，反而是查普发明了感观电报（一种通过望远镜观察电报塔机械臂获取信息的技术）和“电报”（telegraphe 远方的书写者）这个词。1793年法国建成第一座电报塔。次年，法国国家电报系统的第一条支线巴黎-里尔落成，法国的观感电报网由此形成。</p>
<p>时势造英雄。1832年，从欧洲回美国的萨利号船上，塞缪尔·F.B.摩尔斯听到同船的科学家提到了电流可以即时传播，灵感之下，想到了电报的无限可能，短短数日，就创造出摩尔斯电码，而这，几乎是整个电报行业的基石。四年之后，1836年，大洋彼岸的威廉姆·福塞吉尔·库克同样意识到电报的巨大前景。随后的两年，两个人在电学科学家的帮助下，都独立解决了流量远距离传导的难题。而摩尔斯更进一步改进了摩尔斯电码，让它可以直接编码字母。技术难题攻克后，1837年，库克和惠斯通合作建立第一条依附于铁路公司的电报线；1844年，摩尔斯说服政府建立了一条华盛顿-巴尔的电报线。1845年，几乎同时，摩尔斯和库克各自建立了磁力电报公司和电力电报公司。自此欧洲各国和北美的电报网日益发达起来。</p>
<p>各国自家的电报网四通八达之后，国与国之间沟通的诉求日益迫切。1849年3月份，普鲁士和奥地利签订了第一个国际电报互联协议，虽然基于类似香港海关的别扭形式，但是维也纳和柏林这两座城市终于可以互通电报了。随着水下铺设电报线技术的成熟，隔着英吉利海峡相望的英国和法国于1852年完成第一封从伦敦到巴黎的电报通信。而随之富贵的是那些生产古塔胶的公司，因为水下铺设的电线需要古塔胶的保护。1858年8月5日，历史性的时刻来临了。长约3280公里的大西洋海底电缆铺设完成，这意味着欧洲和北美洲的电报网络第一次连接成功。尽管由于技术问题，这条线路服役不到一个月就完全瘫痪。1866年，经过充分科学的试验和前车之鉴的经验积累，跨大西洋电报网络再次连接。这次，它真的可以在两个大洲之间传递各色信息，包括商业贸易，军事情报还有新闻等。</p>
<p>不过很快，电报在超载的信息面前开始显露出疲态。由于需要发送的电报太多，发报员根本忙不过来，导致大量电报堆积，以至于人们惊讶地发现在同城使用电报，通信的速度竟然不如信差。为了节省电报的带宽，英国的发明家克拉克发明了基于蒸汽的气动传送管，利用蒸汽的推力将装有电报卡的小盒子快速地发射到目的电报中心。这看似滑稽的设计，却实实在在地解决了电报带宽不足的问题。19世纪70年代，全世界都在兴建电报网络。维多利亚时代（1837-1901）的互联网在这段时间里初具规模，它混杂着各国的电报网络，海底光缆，气动管和跑腿信差。</p>
<p>英雄时代也会落幕的。1871年10月，美国举办了摩尔斯电报大游行，庆祝这位80岁高龄的老人为全人类通信所做的贡献。我们的电报之父——摩尔斯庄严地用摩尔斯电码敲下了自己的名字，正式告别电报界。次年逝世。</p>
<p>大师的陨落，宛若宣告一个时代的终结。电报以及整个电报行业开始退出历史的舞台。1872年，波士顿的约瑟夫·B.斯特恩斯发明了双工器，可以用一条电报线完成收和发的动作。1874年，博多机将一条线路的容量扩展到原来的12倍。同年，爱迪生发明了四工电路。1876年，亚历山大·格雷厄姆·贝尔通过对谐波电报的研究，发明了电话机并申请了专利。19世纪80年代，电学热持续升温，电报行业以肉眼可见的速度衰退。1903年，英国发明家唐纳德·莫里发明了电传打字机，这几乎宣判了电报员的“死刑”。自此之后，电报就消失在了人们的视野里。2006年，美国的西部联合公司宣布停止办理一切电报业务，以后恐怕只能在博物馆里才能追忆到那段辉煌的历史。</p>
<h2 id="电报的思考"><a href="#电报的思考" class="headerlink" title="电报的思考"></a>电报的思考</h2><h3 id="到底是技术带来了社会范式的改变，还是人类的诉求本身？"><a href="#到底是技术带来了社会范式的改变，还是人类的诉求本身？" class="headerlink" title="到底是技术带来了社会范式的改变，还是人类的诉求本身？"></a>到底是技术带来了社会范式的改变，还是人类的诉求本身？</h3><p>开篇提到过人类总是渴望互相交流，查普发明感观电报绝非偶然，本质上是察觉到人想和远距离的其他人即时交流的诉求。所以是诉求本身带动了技术创新。当技术创新成功发展之后，首先是富人阶层最先享受到成果，资本的罪恶本质是压榨了普罗大众的劳动时间得来了剩余价值。这些剩余价值让富人免去工作，把自己的时间消耗在这些技术创新激发的原始诉求上。然后，商人出于无利不起早的心态，会极力追求更低成本的技术创新，在市场竞争下，用低廉的价格吸引穷人进入资本家新一轮的资本累积当中。商业从根本上就是趋利避害的。</p>
<p>当技术的创新在一些方面节约了人们的时间，人们必然会将这部分时间浪费在其它方面或者干脆全部沉浸式地浪费原来那部分事情上，比如：网上聊天。我们之所以会有社会范式改变的感觉，就是由于我们自己原来的生活节奏被打乱了。以前是不得已而为之，现在是得已而不为之或者为之，突然一下拥有了选择的自由，算是很合情合理的设定。用系统性思考模式，人类及其活动是个大系统，本身就具有自组织的特征，所谓自组织就是让自己变得复杂的能力。远距离的交流变得快捷，意味着系统内部的信息连接更多更紧密，原因是速度变快了，同样的时间内可以和更多人建立关系，同时交流也会更加频繁。这样的带来的影响是什么呢？那就是人类群体变得更加复杂，外在行为更加诡异，也越发难以被消灭。</p>
<p>回到问题本身，这个问题就不应该用线性思考方式思考。人类的诉求激发了技术创新，技术创新又改变了人类的生活，激发了更进一步的诉求。说到底就是形成了一种增强回路，社会范式不过是增强回路自然而然表现出的群体的一致的外在行为模式。</p>
<h3 id="电报网络和20世纪末的互联网有什么关系？"><a href="#电报网络和20世纪末的互联网有什么关系？" class="headerlink" title="电报网络和20世纪末的互联网有什么关系？"></a>电报网络和20世纪末的互联网有什么关系？</h3><p>抛开技术本身不谈，电报网络和互联网都承载了同样的目标——让人类交流更加便利，本质上没有区别。常说电子邮件是互联网上的杀手级应用，我看不见得，170年前的电报早就具备了这样的能力，甚至“邮箱地址”这种也早就出现了。我觉的互联网真正的厉害之处，在于极大地丰富了信息的表现方式，利用超媒体链接技术，实现了多种类型信息（文本，照片和视频）的互联，还有基于这些信息上层抽象——服务（保险，云服务等等）。再加上计算机和移动设备这类载体的普及，用户群暴增。时下，如果不用互联网可能会被归为异类。</p>
<h3 id="下一个爆发的是什么网呢？"><a href="#下一个爆发的是什么网呢？" class="headerlink" title="下一个爆发的是什么网呢？"></a>下一个爆发的是什么网呢？</h3><p>我们分析一下互联网是个什么东西。互联网的要素有虚拟的人，虚拟的团体或公司，信息，网络，数字货币等。互联网上除了通讯和智库这些基本的要素外，还有由此构建的各种商业服务，如：阿里巴巴的电子商务帝国。当然还有游戏这种天然电子消费品。信息交互的速度足够快了，信息的载体也非常丰富，设备也在不断革新贴近人类。那么还有什么可以改善的呢？从历史发展的角度看问题，真正革新的技术从来都不是拿着颠覆什么商业模式的口号打出名声的，它的出发点一定是帮助解决人类的原始诉求。</p>
<p>思考中…</p>
<p>答案会是区块链吗？</p>
<p>于2018年2月4日</p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><img src="http://upload-images.jianshu.io/upload_images/217988-d82ebdc89f1a73c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="维多利亚时代的互联网"></p>
<hr>
<p>[1]<a href="https://book.douban.com/subject/25924608/">从莎草纸到互联网：社交媒体2000年</a><br>[2]<a href="https://book.douban.com/subject/1874086/">六个瓶子里的世界史</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/217988-ce973aa35194f1ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="维多利亚时代的互联网.png"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>技术简史</title>
    <url>/2018/05/01/ruling-the-waves/</url>
    <content><![CDATA[<h2 id="太长不读篇"><a href="#太长不读篇" class="headerlink" title="太长不读篇"></a>太长不读篇</h2><p>《技术简史》原著*Ruling the wave, From the Compass to the Internet, a History of Business and Politics along the Technological Frontier)*。依书中的视角，从15世纪的地理大发现到21世纪的网络音乐，每一次技术的创新和商业发展都大致遵循4个阶段规律：</p>
<ol>
<li>创新</li>
<li>市场化</li>
<li>创造性的混乱</li>
<li>制定规则</li>
</ol>
<p>而<strong>制定规则者为王</strong>就是本书的核心观点。引用1993年获得诺贝尔经济学奖的Douglass North的研究：市场刚出现时，稍大的组织可以通过行会或协会来规范市场的交易，但这些早期的市场如果想要最终发展成为高效的大型企业的话，就需要国家介入，制定各种规章制度以保证贸易顺畅。用他的话来说就是，<strong>巩固市场所需的财产所有权必须由政治制度和司法体制通过保证签订契约的成本最小化来落实。</strong></p>
<p>不过，这里的问题是政府就能保证签订契约的成本最小化么？如果出现一种新的技术，它可以让这个成本小于政府的监管和司法投入，那么它就不仅是一种技术的革新，同时是对技术发展既定规律的革新。答案是区块链？没有产权和交易的规则，市场一定不会发展。这里的产权对应区块链应用中资产转账，而交易规则对应的是智能合约。那么答案可能真是区块链了。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>Debora. spa，女，哈佛大学博士，哈佛商学院教授。著有《The baby business》和《Ruling the waves》（译本：技术简史）。这本《Ruling the waves》最早出版于2001年，中文译本于2017年4月由中信出版社出版。主要描述了从15世纪的大航海到21世纪的互联网时代，创新技术的发展规律，得出制定规则者为王的结论。</p>
<p>配合<a href="https://book.douban.com/subject/27078260/">《维多利亚时代的互联网》</a>一起读，对电报带来的社会变革会更有切身感受，通过时间线串联起来理解效果更佳。</p>
<h2 id="历史在一遍遍重演"><a href="#历史在一遍遍重演" class="headerlink" title="历史在一遍遍重演"></a>历史在一遍遍重演</h2><p>“没文化，真可怕！”<br>回到中世纪那黑暗的1000年间，教会的僧侣掌握着知识的生产和传播，未曾开化的愚民既没有能力也没有渠道获取知识，其中就包括圣经抄本及其解释权。这些愚民只能听从教会宣扬的神祗和信仰，怀疑者统统被审判为异教徒和魔女，火烧异教徒和魔女狩猎甚嚣尘上，一切都是没有文化的恶果。但是压迫必然遭遇反抗，活字印刷术的出现让知识出版变得开放和自由并且廉价，知识的生产和传播开始规模化，人们可以直接获取知识而不再依赖教会，解读圣经的权利得以回归，随之稀释的是教会的控制权。但是教会也不会坐以待毙，他们建立自己的天主教印刷工厂推动反宗教改革，印制大量《圣经》和核心书刊，并且知道如何争取有读写能力的追随者，进而掌握了知识的核心传播形式，其统治地位并没有被动摇。虽然如此，但是世界的规则已经改变，权力发生了转移。</p>
<p>印刷术将物理世界中这些以前需要手抄的竞争性资源变得廉价，让知识持久化下来，打破了时间的侵蚀，但是知识的传播却还是受限于距离，行进缓慢。每当这时，总有英雄出现。19世纪，电报的发明以及历经坎坷的商业化进程，彻底改变信息传播的形式，加速了全球的信息互联。再加上19世纪末，电话和无线电通讯的发明，整个世界宛若突然缩小成一体，信息的传递变得不可思议得快速和廉价。20世纪计算机的发明奠定了20世纪末的互联网诞生的基础，信息传递不仅变得快速，其内容还异彩纷呈。这个时代，没有哪个组织和团体可以垄断信息及其传播形式。</p>
<h2 id="第一次浪潮"><a href="#第一次浪潮" class="headerlink" title="第一次浪潮"></a>第一次浪潮</h2><p>15-17世纪的大航海时代，航海技术的大发展开启了一个新的商业世界。<br>葡萄牙亨利王子，获得“航海家”亨利的称号，1460去世，大航海时代来临。</p>
<p>技术创新<br>14世纪，欧洲的船运贸易无法远离海岸，受制于变幻莫测的天气和有限的航海技术。威尼斯的商人只敢在亚得里亚海和爱奥尼亚海（地中海）航运，不敢穿越直布罗陀海峡（西班牙和北非摩洛哥）来到北大西洋。英国商人也只敢航行到法国西部的比斯开湾。<br><img src="https://upload-images.jianshu.io/upload_images/217988-3dbe0683eb40eec3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="西欧"></p>
<p>14世纪初，船舶工艺升级，厚重的船让位于轻快的帆船，这些船比原来的更大也更轻。另外，13世纪中期，《图解海航手册》可让航海员可以估算地理位置。15世纪早期，指南针等技术也等到了广泛应用。</p>
<p>先驱<br>葡萄牙的亨利王子，为了实际的目的——西非的黄金，基督教布道等，沿着非洲的西海岸航行，并且记录下了航海活动的信息收集。在这过程中，改良了地图绘制和造船工艺，让很少的人就能操作很大的船。早期的船只能顺风航行，但是亨利王子的轻快的小船在逆风时也能航行，这样远航的船只也能顺利返航。</p>
<p>亨利王子与1460年去世，新一代的探险者正式开启了大航海的时代。葡萄牙海员率先南下到达非洲的最南端，并且来到了印度洋的西海岸。1484年，哥伦布得到了西班牙国王费迪南的资助，发现了美洲新大陆；1521年，麦哲伦绕过了南美洲最南端，进入太平洋，然后到达亚洲。这证明了世界是圆的。</p>
<p>1569年，比利时的绘图者墨卡托（Mercator）发明了一种新式的地图绘制方法，墨卡托投影，把地球沿着经线分割开然后展开成一个矩形，这样的绘制技巧在精度上有了质的飞跃。普通的航海员也可以远航了。</p>
<p>创新性的混乱<br>海盗。16-18世纪，伴随着大海航时代的到来，海盗猖獗。主要原因一个是海上并没有很好的法律约束，还有一个最重要的原因是国家在维护自己的权益。这个时代大部分的欧洲国家都在从事私掠活动。给海盗授予掠夺的权利是最经济的打压敌国贸易的政治手段。</p>
<p>大海盗弗朗西斯德雷克（Francis Drake）的故事<br><img src="https://upload-images.jianshu.io/upload_images/217988-a893b072883b535f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="弗朗西斯·德雷克"></p>
<p>德雷克大半个人生都是海盗。早年间，他在英国精英的支持下，做起了“三角贸易”。从非洲俘获奴隶，然后卖到加勒比海的西班牙殖民者，再从他们手上换取毛皮等货物，然后再带回英国。不过，在一次返回英国的航行中，他的船遭到了来自西班牙军队的袭击死里逃生。复仇的怒火在心里燃烧。自从被英国赋予掠夺权之后，他开始袭击美洲的西班牙殖民地，掠夺海上的丝绸和黄金。1581年，伊丽莎白一世女王授予他爵位。一以贯之的海盗生存法则——“在合适的时候，跳上正确的船”。</p>
<p>制定规则<br>1701年，英国政府公开绞死了著名的海盗之一的威廉·基德<br>1721年，当罗杰斯离开拿骚岛，加勒比海最猖狂的“黑胡子”艾华德·蒂奇和“白棉布”杰克也已经绝迹。</p>
<p>1730年，海盗的黄金时代结束了，但是知道1830年才算几乎根除。</p>
<p>为何原本受到国家暗中保护的海盗突然遭到了所有政府的封杀？因为规则改变了。海盗这个团体不再是政府的政治手段，反而成为了问题。1588年，西班牙无敌舰队在和英国的海战中战败，伴随而来的是西班牙在大西洋垄断时代的没落。而且原来的大海航时代的先驱逐渐占领了海洋贸易这些商人，他们为了维护自己的利益，也开始要求政府打击海盗。1856年，欧洲7个国家的代表在巴黎会面，签署了《巴黎宣言》，正式宣布任何海上的私掠行为都被禁止。</p>
<h2 id="电报时代"><a href="#电报时代" class="headerlink" title="电报时代"></a>电报时代</h2><p>技术创新<br>1791年法国的查普兄弟通过铜锅和同步的2倍速时钟传递信息。法国的查普发明了感观电报，1793年，法国建立起第一个观感电报塔。1837年，摩尔斯发明了摩尔斯电码和电报，并将电报推出实验室。</p>
<p>电报先驱<br>库克，菲尔德，奥莱利，彭德这些电报先驱们看到了电报的商业潜力，然后发展起了新的市场。</p>
<p>创新性混乱<br>电报市场发展起来之后，遇到了和其它技术一样的问题。最大的问题就是如何合作：电报的线路是分离的，同时使用的code book（代码本）也不同。</p>
<p>如果电报网络互不兼容，那么每条线路的价值都会被降低。电报先驱们开始制定标准和规则。</p>
<p>制定规则<br>欧洲和美国一开始介入市场的方式不同。欧洲各国都有自己的电报线路和标准，因为当时大部分的电报公司都和政府有关系，为了能够实现国际间的通讯，欧洲大陆共同推行相同的标准和技术规范，这要归功于成立的国际电报联盟。</p>
<p>不过美国恰好相反，政府在早期就退出了电报市场。然后私营企业强强联合，建立起了一套共同遵守的规则。不过市场竞争的本质就是消除竞争，在各自利益的驱使下，短暂建立起的联盟是脆弱。这表现在电报市场就是西部联合公司一家独大，而这实质上就是垄断。最后，政府颁布了公共规则。1910年，美国国会通过一项法案，授予州际商业委员会调查电报收费的权利。1934年，通过通信法案，正式把规范电报业的任务交给了联邦通信委员会。</p>
<h2 id="无线电时代"><a href="#无线电时代" class="headerlink" title="无线电时代"></a>无线电时代</h2><p>技术创新<br>19世纪20年代末，电磁感应让无线电的研究向前一步。1865年，苏格兰数学家麦克斯韦证明了电和光可以以相同的速度在空气中传播。最终在1887年，德国科学家赫兹成功地用实验证明了麦克斯韦用数学说明的现象。</p>
<p>马可尼发明了无线电装置，并成功将它进行了商业化应用。</p>
<p>无线电先驱<br>马可尼无线电报公司和德国德律风根公司，那时候还只是能够传递电码；1918年美国的RCA（美国无线电公司）诞生，已经可以进行声音广播了。</p>
<p>创新性混乱<br>1910年左右，传播信号开始互相干扰。1912年4月12日，豪华巨轮”泰坦尼克号“撞到冰山沉没，因为信号阻塞特别严重，导致家属迟迟得不到救援信息。因为这件事，美国政府要求业余无线电操作员需要取得营业执照，而且无线电频谱变为离散状态。</p>
<p>自从广播播放音乐火了之后，人们开始私自搭设电台，同时混乱使用频道的方式开始发生。</p>
<p>制定规则<br>1927年，美国出台了《无线电法案》，大公司相当统一，无线电行业在这个时候”可能是全美唯一一个全体一致要求管制自身的行业“了。究其缘由，有线电报的所有者和财产所有权是明确的，但是无线电波是无形的，因为没有一个成形的财产所有权分配系统，所以建立频段划分系统除了政府没有人可以胜任。</p>
<h2 id="卫星电视和数字电视时代"><a href="#卫星电视和数字电视时代" class="headerlink" title="卫星电视和数字电视时代"></a>卫星电视和数字电视时代</h2><p>1983年，鲁伯特·默多克（Rupert Murdoch）的新闻集团购买了一家英国的卫星电视SATV（卫星电视）并更名为 Sky，他们想在英国的电视市场努力地开创出一片卫星电视的天地。因为卫星电视在后期的维护以及远距离传播上有天然的优势。而且，BBC电视只为政府代言，播放充满精英文化的正经说道题材也确实让民众难以下咽。以丘吉尔为代表的保守党重新掌权（二战期间）之后，开始稳步地将竞争引入电视市场。</p>
<p>英国的无线电视技术的历史久远。早在1926年，一名叫做约翰·贝尔德（John Baird)的企业家，说服了英国广播公司（BBC）发展广播可视图画的技术，进而演化成了BBC电视业务。经历过一段时间的国有垄断之后，由于政策的允许，各大商业独立电视台也开始进入电视市场，并且在市场份额上形成了势均力敌的局面。当然，政府的监管机制从来没有落下，ITA（独立电视局，类似广电总局）负有监管和审核独立电视节目的责任。只不过这个还只是地面上的无线电视广播，压根没有卫星电视什么事儿。</p>
<p>时间来到了1977年，世界无线电管理委员会分配了已知的卫星空间，同时规定参与国可以得到当时广播卫星所有频道中5个频道。英国将其中的2个频道分配给了老牌的BBC，剩下的3个频道通过竞标的方式分配给了BSB（英国卫星广播公司）。Sky公司却在竞标的过程中失败了，但却不一定是坏事。当BSB调用大量精英研发新技术（D-MAC）标准的时候，Sky公司租了位于法国，比利时和德国三国交界处，一个叫做卢森堡大公国的通讯卫星。这个决策的厉害之处是恰逢欧洲委员会规定：对任何广播卫星的制裁只能由来源国发起。Sky公司绕过了英国的法律约束，同时发动和推出了上门推销技能和免费的售后服务，这些举措成功地吸引了客户，并最终帮助Sky公司占领了市场。在这场商业角逐当中，Sky成功扭转局势，打败了主要竞争对手BSB。1990年，两家公司达成协议，合并成一家公司，并取名为BSkyB公司。同时默多克的新闻集团获得了50%的股份，并拥有绝对的控制权。</p>
<p>BSkyB的故事并没有结束，因为有一位创奇的人物还没有登场。</p>
<p>由于商业模式和原来那些独立电视没有太大区别，导致BSkyB没有足够的订单来获得广告收入，再加上合并之后内部摩擦不断，BSkyB在起飞阶段的日子并不好过。于是，默多克私下邀请萨姆·克里泽木（Sam Chisholm）加入了Sky。在那之前，克里木泽就以果敢和成就而闻名。</p>
<p>克里泽木迅速采取了行动。他首先抢占先机控制电视内容，飞去美国和好莱坞的影片公司签约，这其中就包含默多克自己的福克斯公司（21 Century FOX）。非常意外的，他应好莱坞影片公司对产权的保护要求，发展出了一种全新的商业模式——通过加密技术保护产权，并引导顾客为片源付费，从而建立起来一种关联影片提供商和顾客的全新收费模式。除此之外，他也和体育赛事联盟签约，将原来处于公共领域的体育赛事直播转化成了私营方式。虽然这种方式遭到各方质疑和控诉，但是最终还是安然无事，并获得了巨额回报。</p>
<p>其次运用准入控制手段，他联合以色列的Adi Shamir（RSA加密方式中A指的就是他）建立了一家专门为BSkyB公司提供加密服务的NDC（News datacom）公司。同时积极开发包含加解密、内容管理功能的机顶盒。在稳固新建立的商业模式的同时，还通过市场份额的优势，迫使其它内容供应商加入自己的系统。这种做法巩固了BSkyB的生态环境，也为后来其它竞争手对其垄断的控诉提供了证据。</p>
<p>回顾Sky公司的一路辉煌，就会发现挺符合辩证法中的否定之否定的规律。卫星电视技术，因为其创新的特征，让Sky公司绕过了英国的法律和规则，以一种“海盗式”的手段，打开了顽固的英国电视市场。当竞争者开始用反垄断法为自己发言的时候，它又用自创的商业模式——付费电视，把自己隐藏到整个电视市场这个大背景下，躲过了制裁。貌似一切规则都失效了——这就是创新的力量。但是中国有句老话“成也萧何败也萧何”，技术界从来不缺乏新闻。</p>
<p>数字电视时代扑面而来。由于数字信号比模拟信号具有可压缩，可降噪的优势，很快得到政府的重视。1996年，英国推出了《广播法》并统一建立6个新的数字频道。在过渡到数字电视的阶段，英国政府提供了很多对私营企业十分友好的条件。一开始混有BSkyB血统的BDB（英国数字广播电视，后改名为ONdigital）在政治和商业利益的驱使下，将BSkyB从联盟中踢出，并获得了政府划拨的近一半的地面数字波段。</p>
<p>BDB因为有了数字许可证，便开始和BSkyB展开了合作和竞争。一方面BSkyB依赖于BDB的许可证；另一方面，BDB又依赖BSkyB提供的影片服务。这期间BDB更名为ONdigital。1999年末，BSkyB和ONdigital公司成为了英国数字电视市场的两大巨头。经过这轮技术洗牌之后，政治方向也开始朝着不利于BSkyB公司的方向倾斜，表现在BSkyB对足球俱乐部曼彻斯特连队接管被禁止。另外，政府颁布了新一轮的电视标准中，要求提供一种标准的接口，而BSkyB公司从未使用过，而且这相当于打破了BSkyB的生态闭环，也意味着它不得不和其它电视公司展开公开竞争。</p>
<p>这一波数字技术的截胡操作，让BSkyB失去了垄断的地位。否定之否定同样作用到了BSkyB自己的身上。不管如何，电视技术还在持续发展中。</p>
<h2 id="密码朋克"><a href="#密码朋克" class="headerlink" title="密码朋克"></a>密码朋克</h2><p>密码朋克（crypherpunk）指的是一帮倡导使用强加密技术保护个人隐私的活动家，他们的敌人是企图剥夺民众使用加密技术的政府。触发密码朋克组织形成的导火索是1993年美国政府企图在所有的计算机和手机植入一种Clipper芯片，这种芯片会包含一个私钥，当设备被卖出后，对应的私钥会被存储在第三方的契约账户中。一旦政府获得许可就会取出私钥查看传输的情报。然而，这种措施无疑刺激到了密码朋克们的神经，对于他们而言，这是政府企图建立“网络极权国家”的阴谋，必须反抗！结果白宫方面放弃了这一方案。这是属于密码朋克的胜利。</p>
<p>加密技术的发展有自己鲜明的特征。首先是制定标准的过程，几乎不存在混沌的状态。新的加密技术出现，旧的就随之淘汰，顺应自然；其次它也不存在拥塞状态，毕竟它分明就不是一种通讯技术，相比于电报、无线电、互联网以及区块链在初期遇到的拥塞问题，加密技术几乎不存在需要分割的稀缺资源，也就无需外部力量维持所有权的分配秩序；最后，纵观加密技术的历史，这项技术从诞生之初就很少申请过专利。当然现代加密技术倒是申请了不少专利，但是加密界有自己独特的一套共识——闭源的加密算法是不安全的。这或许不能构成对所有权混乱的理由，不过，由于政府最初对加密技术的封闭，所以它在发展过程中没有出现创造性的混乱状态，所以对于加密技术所有权的任何保护措施也就不太重要了。</p>
<h2 id="微软托拉斯"><a href="#微软托拉斯" class="headerlink" title="微软托拉斯"></a>微软托拉斯</h2><h3 id="微软帝国的崛起和侵权案件"><a href="#微软帝国的崛起和侵权案件" class="headerlink" title="微软帝国的崛起和侵权案件"></a>微软帝国的崛起和侵权案件</h3><p>1968年，比尔·盖茨接触到计算机的世界。他和保罗·艾伦（Paul Allen）一起为DEC（数字设备公司）编写程序。1975年7月，艾伦在Altair机器上成功地演示了改良过的BASIC语言五个月之后，微软（MicroSoft）公司成立了。这时候的微软靠卖BASIC语言的光盘获取版权收入，即便彼时的软件所有权概念还很模糊。</p>
<p>微软的将BASIC语言据为己有的做法在当时引起了轩然大波，而争论的中心发生在一家业余爱好者俱乐部——家酿计算机俱乐部最初的理念是“通过共享经验和相互交流构想，我们促进了这门艺术的发展，使更多的人用低价的计算机成为可能”。成员复制了微软的BASIC代码，并开始随意分发，在他们看来，微软的BASIC代码本来就属于公众。这种做法影响了微软的版权收入，同时也惹恼了比尔·盖茨。盖茨批判这帮人是强盗，但是这些人认为比尔·盖茨把几百人花了几年做出来的软件占为己用的行为才是强盗行径。</p>
<p>虽然盖茨在这次争论中缓和了态度，但是软件的版权问题迟迟没有定论。直到Altair公司被出售给加利福尼亚的一家较大的公司，这个公司声称BASIC语言归自己所有，并且禁止其他生产商使用。这回盖茨没有怂，微软同这家公司进行了长达6个月的诉讼大战，最终赢得了胜利。这个案件不仅仅宣告了微软对BASIC语言的所有权，也意味着一种定论：软件是私有财产。</p>
<p>1983-1986年，苹果公司和微软的达成合作，微软将Word等常用办公软件提供给了苹果，而苹果通过销售Macintosh电脑帮助微软销售软件。但是微软发布了Windows2.03，抢占了苹果公司在PC的市场份额，苹果公司这时冷静不下去了，以盗用Macintosh界面所有权的理由将微软告上法庭。虽然最终对于微软的所有控诉都被法院解除了，苹果公司也因此遭受了巨大的打击，但是微软也因为反托斯拉法案受到了美国联邦贸易委员会（FTC）的调查，并且在1994年签署一项包含了若干义务的法律协议，其中规定了微软不得在操作系统中捆绑销售自家的软件，同时微软也承诺不再使用任何许可协议。</p>
<h3 id="浏览器战争中的反托斯拉"><a href="#浏览器战争中的反托斯拉" class="headerlink" title="浏览器战争中的反托斯拉"></a>浏览器战争中的反托斯拉</h3><p>时间来到了1995年，这是互联网商业化的元年。这一年，如今已经是两大世界级电子商务巨头的eBay和Amazon上线运营，在中国，杭州的大学英语老师马云和宁波的电信员工丁磊离开公职，分别创办了阿里巴巴和网易。Jim clark和Mark Anderson成立的公司Netscape凭借Navigator（前身是Mosaic）这款网络浏览器迅速横扫互联网市场。在CERN（欧洲粒子研究院）研究员Tim Berners-Lee发明了HTML、HTTP协议和URL之后，信息通讯发生了变革，这让非技术用户上网成为了可能。这时候，Anderson等人就想着如何把图像和多媒体引入网络，最后的答案便是通过浏览器。</p>
<p>大公司总是习惯后知后觉，微软也不例外。在Netscape公司的Navigator浏览器迅速占领了超过90%的浏览器市场份额后，微软按捺不住了——以卖自家软件见长的微软很害怕Navigator成为网络的入口，用户便可以下载任何产商的软件。所以微软开始行动了，首先它成立了一个互联网平台和工具部门，其次通过威逼利诱的手段限制和控制Netscape公司，最后通过“行贿”的方式联合AOL推广自己的IE浏览器。当然，这些措施生效了，Netscape在浏览器市场上的份额迅速缩减了一半以上。然而，微软这种行为最终还得诉诸法律。</p>
<p>当商业利益上竞争不过巨头的时候，留给这些创业公司最后的武器就是反垄断法。在这场旷日持久的诉讼案件中，法院确定了微软的反垄断行为，但是并没有接受Jackson法官拆分微软的命令。2001年11月2日，联邦司法部与微软就案件达成了<a href="https://zh.wikipedia.org/wiki/%E5%90%88%E4%BC%97%E5%9B%BD%E8%AF%89%E5%BE%AE%E8%BD%AF%E6%A1%88">和解</a>，但是这次和解既没有要求微软修改源码从Windows中剥离IE浏览器，也没有限制微软未来在Windows中捆绑其它软件，所以令很多人感到不满。</p>
<p>微软的故事告诉我们，当进入一个崭新的领域时，原先社会上比较分明的所有权和反托拉斯的界定问题变得模棱两可起来。大公司可以很快地在新兴的市场之上建立起法则这时候法律监管是滞后的。但是一旦新兴企业创造出自己的市场之后，原先的大公司还想要入场并部署自己的规则，那么不论是企业、用户还是政府都会介入进来反对垄断和维护秩序。</p>
<h2 id="网络音乐"><a href="#网络音乐" class="headerlink" title="网络音乐"></a>网络音乐</h2><p>1999年，19岁的Shawn Fanning辍学创建了Napster这个革命性的网站，它允许用户在网站上自由地交换歌曲，这种免费的上传和分发的模式很快就颠覆了传统的唱片行业。传统的唱片行业掌控了音乐录制，分发渠道，前期宣传和明星包装，也同时形成了对音乐制作人的“奴役”和压榨。随着数字音乐技术（MP3）的成熟，有些歌手直接将自己的音乐上传到如Naspter这样的网站上，听众就可以自由地下载和分发了。</p>
<p>随着Napster网站上用户数的不断增加，盗版的问题也日益严重起来。原本歌手将音乐上传到网上，是想脱离唱片公司根深蒂固的体系，但是后果是歌手也没法获得相应的报酬了。于是，围绕网络空间中的知识产权保护也引来了大量的讨论。有人说“未来将会胜利，在网络世界中不存在所有权”，也有人说“知识产权的整个结构和价值都在改变……技术性障碍将几乎为零……法律本身变得无所适从或遭到削弱”。</p>
<p>但是从历史中走过来，我们发现网络世界的版权还是保留了下来。苹果公司的Jobs开创的iTunes和iPod从某种程度上，拯救了数字音乐的版权和唱片公司。早在2004年，iTunes store 在合法数字音乐市场的份额就超过了70%，2011年数字音乐的市场份额更是超过了实体音乐（刻录在唱片等载体上的音乐）。当正版商开始用资本发展网络商业模式时，它也会收购那些盗版的公司，自己也得到进一步发展。从这些方面看，不难得出数字版权更像是在唱片公司、数字音乐公司以及公众参与下共同制定的一项行业标准，然后由政府强制执行。所以最终胜利还是属于那些制定行业标准的家伙，尽管总有人存在一种理想国的幻想。</p>
<p>– 于 2018-05-01</p>
<hr>
<p>[1] <a href="https://book.douban.com/subject/26767590/">技术简史</a><br><img src="https://upload-images.jianshu.io/upload_images/217988-4b70b752956cb5f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="技术简史核心观点"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>架构整洁之道导读（一）编程范式</title>
    <url>/2018/10/28/Guide-to-Clean-Architecture-1/</url>
    <content><![CDATA[<p>我是《架构整洁之道》(<em>Clean Architecture</em>) 中文版的技术审校者，在审校的过程当中略有感悟，所以希望通过撰写导读的方式分享给大家。</p>
<h2 id="书名的由来"><a href="#书名的由来" class="headerlink" title="书名的由来"></a>书名的由来</h2><p>《架构整洁之道》是<em>Clean Architecture</em>的中文译名。看似简单地延续了《代码整洁之道》(<em>Clean Code</em>)的翻译传统，但事实上，对于取中文名字这件事，我们还是花了不少气力的。拿到译文初稿时，编辑提供了几个备选的译名：《架构简洁之道》，《架构至洁》和《Clean Architecture》，这些名字各有各的考量，在没有了解这本书的核心思想之前，我也没有办法给出恰当的判断。所以在通读了原作和译作之后，我在ThoughtWorks咨询群里发起提案，讨论的过程很精彩，最终在骨灰级架构师新哥的建议下，结果大致趋向了整洁架构。</p>
<p>新哥说：“整本书在说依赖治理（管理），也就是如果降低依赖复杂度，和DDD中分离子域分层架构等想法是一致的；如同你整理你的房间，把东西分门别类放好，从这个角度，整齐比简单更合适，或者清晰也可。”</p>
<p>除此之外，对于《架构至洁》这个候选项，大魔头的态度是不要至洁，总感觉脏脏的。言下之意，自行体会。而读MBA的岳岳和XR（XR说他没读过MBA）从用户思维出发，认为《代码整洁之道》和《架构整洁之道》可以相互增强记忆，更容易激发用户的购买行为。</p>
<p>即便敲定了“整洁架构”，大家对“之道”也有不同的看法。《代码整洁之道》对应的原标题和副标题分别是<em>Clean Code - A handbook of Agile Software Craftsmanship</em>，而《架构整洁之道》对应的原标题和副标题分别是<em>Clean Architecture - A Craftsman’s Guide to Software Structure and Design</em>。我们知道“道”是一种形而上的精神层面，老实讲，把<em>Craftsman</em>（手艺人）译做“道”是有点夸张的。</p>
<blockquote>
<p>形而上是精神方面的宏观范畴，用抽象（理性）思维，形而上者道理，起于学，行于理，止于道，故有形而上者谓之道；形而下是物质方面的微观范畴，用具体（感性）思维，形而下者器物，起于教，行于法，止于术，故有形而下者谓之器。</p>
</blockquote>
<p>道法术器择其一？其实凡事总有权衡，遵循前人的译法往往不会太坏。就像鲍勃大叔书中总结的稳定依赖原则，当我们依赖一种译法次数越多，它就更加稳定，这种稳定先不说能否形成品牌效应，单是SEO就能省去不少功夫，那么何乐而不为呢？</p>
<p>鲍勃大叔的文字平铺直叙、浅显易懂，尤其喜欢用他自己生活中的经验做例子。而且这本书是没有知识断层的，即便是初级程序员，也能在鲍勃大叔的循循善诱下，完成对软件架构认知的转变。因为他总是从最基础的知识点切入，自下而上，一步步地搭起架构的形状。</p>
<h2 id="范式的实质是约束"><a href="#范式的实质是约束" class="headerlink" title="范式的实质是约束"></a>范式的实质是约束</h2><p>编程范式是程序员喜闻乐见的话题，就像Vim和Emacs编辑器地位的旷日之争。它们的沉浮过往俨然就是风云诡谲的江湖。结构化编程英雄迟暮逐渐淡出程序员的视野，觊觎已久的面向对象编程（OOP）以迅雷之势称霸武林，独居一隅的函数式编程（FP）隐忍多年终于等来了一次机会。2012-2014年，江湖唱衰OOP的声音不绝于耳，FP就像一名拯救程序员于水火的侠士想要撼动这片天地。硝烟过后，眼前却不是你死我亡的惨状，而是你中有我、我中有你的大团圆结局。当Java这位OOP的保守党融汇了FP的特性lambda表达式，这场范式的冲突之争也算落下了帷幕。</p>
<p>程序员谈编程范式，喜欢党同伐异，作为FP的拥趸，我也不例外。可是鲍勃大叔却娓娓道来，所谓编程范式不过是约束程序的执行，告诉我们什么不能做而已。</p>
<ol>
<li>结构化编程是对程序控制权的直接转移的规范和限制</li>
<li>面向对象编程是对程序控制权的间接转移的规范和限制</li>
<li>函数式编程是对程序赋值操作的规范和限制</li>
</ol>
<h3 id="Goto-considered-harmful"><a href="#Goto-considered-harmful" class="headerlink" title="Goto considered harmful"></a>Goto considered harmful</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-187abed98d4896de.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GotoConsideredHarmful"></p>
<p>学习C语言编程的第一天，老师就告诉我们不要在程序中使用<code>goto</code>语句，因为<code>goto</code>会破坏程序的结构化。Dijkstra在论文<em>Go To Statement Considered Harmful</em>中证明了<code>goto</code>语句阻止了将大程序递归分解成更小的可证明的单元，这意味着大量使用<code>goto</code>语句的程序是不能被证明的。这里，不能被证明的语义是不可判定，类似说谎者悖论——“我在说谎”这句话不能被证明和证伪，所以不用<code>goto</code>其实是在保证小的程序单元可判定。可惜的是，Dijkstra并没有证明程序单元，这项工作被科学方法——测试取代了。在保证程序单元可判定的前提下，测试是一种可以对其可证伪的科学方法。命题“天下乌鸦一般黑”就是可以证伪的，我们不可能枚举天下所有的乌鸦，等到哪天找到了一只白乌鸦，我们就可以说这个命题是错误的，这就是证伪。Dijkstra说的“测试只能说明bug存在，而不能证明不存在。”是同样的道理。</p>
<p>测试可以保证，在当前已知情况下，程序单元是正确的。一旦有新的测试用例导致程序单元出错，那么我们就可以修正程序，让程序更加接近真相。这或许就是TDD（测试驱动开发）的妙处所在吧。</p>
<p>去除了<code>goto</code>语句之后，我们发现具备顺序，循环和分支判断能力的计算过程还是图灵完备的，也就是说<code>goto</code>的有无并不会影响计算能力。那么<code>goto</code>的在程序中的作用便是弊大于利的。再加上<code>goto</code>的滥用会导致程序结构容易混乱，不利于程序员理解，这更得尽力避免。所以结构化编程限制了对程序直接转移的控制权。</p>
<h3 id="Pointer-considered-harmful"><a href="#Pointer-considered-harmful" class="headerlink" title="Pointer considered harmful"></a>Pointer considered harmful</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-1b98c5fe49bd4ed4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PointerConsideredHarmful"></p>
<p>人人都知道面向对象编程有三大特征：封装，继承和多态。</p>
<p>封装是为了构造抽象屏障（Abstract Barrier），到达隐藏信息的目的。任何编程范式都不会缺少封装，因为这是人的需求，是人类简化问题认知的方式。</p>
<p>继承是一种函数（过程或者API）复用的方式，以前我们想在多个结构相似的数据上使用同样的函数，需要通过强制转换到函数可接收的数据类型（结构体指针）上，这必然存在风险。面向对象的世界里，我们不再需要手动强制转换，只要通过显式地表明继承关系，编程语言就能在运行时自动做到这点。</p>
<p>多态（polymorphism）是<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29">一种将不同的特殊行为和单个泛化记号相关联的能力</a>，和多态概念对应的参考实现——运行哪段代码的决策叫做分派，大部分分派基于类型，也可以基于方法参数的个数及其类型，而分派的具体执行过程则仰仗函数指针。当作为单个泛化记号的函数被声明出来，它的具体实现可以多样化。通过这样的记号，事实上，我们解耦声明和实现，而这种解耦的过程恰恰是通过函数指针间接地找到目标函数完成的。所以面向对象编程限制了对程序间接转移的控制权。</p>
<h3 id="Mutability-considered-harmful"><a href="#Mutability-considered-harmful" class="headerlink" title="Mutability considered harmful"></a>Mutability considered harmful</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-a19539fe44c20bba.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MutabilityConsideredHarmful"></p>
<p>Neal Ford在《函数式编程思想》（<em>Functional Thinking</em>）中提到面向对象编程是通过封装可变因素控制复杂性（makes code understandable），而函数式编程是通过消除可变因素控制复杂性的。函数式的一个显著的特点就是不可变性。不可变性意味着更多的内存消耗，更差的性能？其实不尽然。像Scala，Clojure这些基于JVM上的函数式编程语言大量使用了持久化结构（如：Persistent Vector，见脚注1)，在不损失效率的前提下，实现了不可变的数据结构。这样的数据结构在高并发的环境下具有非常巨大的优势，尤其相对于面向对象编程中为人所诟病的临界区和竞态条件。</p>
<p>不可变的数据结构是无法重复赋值的，所以函数式编程限制了对程序的赋值操作。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>鲍勃大叔一针见血地指出，我们过去50年学到的东西主要是——<strong>什么不应该做</strong>。这等于给全书奠定了基调。可以类比，良好的架构也在传达同样的道理。</p>
<p>为什么从编程范式开始谈起？在审阅完整本书之后，我慢慢发现鲍勃大叔其实在传递一种设计理念：架构设计里，自顶向下的设计往往是不靠谱的。就像本书的目录，从程序的基础构件，谈到组件，最后谈到架构，这个过程非常符合系统自组织的特征。</p>
<p>为什么自顶向下的设计往往不靠谱？本书的第4部分“组件构建原则”会有答案，有需要，且听下回分解。</p>
<hr>
<p>[1] <a href="https://www.jianshu.com/p/1aa9f717366c">函数式编程简介</a><br>于 2018-10-21</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-442a08009a47db30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="架构整洁之道"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样才算学会Python</title>
    <url>/2018/07/18/the-way-to-python/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/217988-4e2f808562ea3f78.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Python inside the door"></p>
<h1 id="Python-实践基础"><a href="#Python-实践基础" class="headerlink" title="Python 实践基础"></a>Python 实践基础</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>假如你已经有了编程基础，那么学习一门新语言的困难点绝对不在语法、语义和风格等代码层面上的，而在于语言范式（OO，FP还是Logic），语言的生态（如：依赖管理和包发布等）和工具（编辑器，编译器或者解释器）这些方面，请参看<a href="https://www.jianshu.com/p/c65cbbbd2826">如何高效地学习编程语言</a>。再假如你已经对各类语言范式都有一定的了解，那么最后的困难之处就是…细节，它是魔鬼。</p>
<p>我相信真正拥抱一门新语言，花在工具和语言生态上的时间一定很多。庞大的社区利用群体智慧构筑的生态圈充满了各种零碎的知识点，这些知识点可能是前人趟过的陷阱（Common Gotchas），基于局部共识经由经典项目实践过之后的约定（Convention）和惯用法（Idioms），也可能是总结出的概念模式（Pattern），甚至是审美（Aesthetic）和禅（Zen）或道（Dao）。这些知识点作用到了工具和语言生态之中，意味着你需要使用合适工具、遵循生态的玩法才能从中受益。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>工欲善其事必先利其器，对于程序员而言，这个器是编辑器…吗？Emacs, Vim, VS Code or PyCharm?</p>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>当然不是，这个器应当是让你能立马运行程序并立刻看到结果的工具，在Python的上下文中，它是Python的解释器。一般情况下，我们会选择最新版的解释器或者编译器，但是Python有一点点例外，因为Python3和2并不兼容，那么该选择哪个版本呢？寻找这类问题的答案其实就是融入Python社区的过程。幸运的是，社区出版了一本书 *<a href="http://docs.python-guide.org/en/latest/">The Hitchhiker’s Guide to Python</a>*，里面诚恳地给出了建议。所以不出意外，Python3是比较合适的选择。</p>
<p>因为Python安装起来很简单，我们跳过…吧？不过，大侠留步，你可知道Python其实只是一个语言标准，它的实现程序不止一个，其中官方的实现是CPython，还有Jython和IronPython等。不过，CPython作为使用最为广泛的解释器当然是开发之首选。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python 3.6.5 (default, Jun 17 2018, 12:13:06)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 9.1.0 (clang-902.0.39.2)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; print(&quot;hello world&quot;)</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>虽然面向REPL编程（Repl-Oriented Programming）是一种比单元测试的反馈速度更快的编程方式，但是在REPL中编写应用程序并不合适，不合适的地方表现在代码不易组织（分模块）和代码没法记录（存盘）。所以我们需要可以编辑的源代码、目录和其它相关文件，这个时候就需要挑选趁手的编辑器。</p>
<p>神之编辑器Emacs中内置了<a href="https://www.emacswiki.org/emacs/PythonProgrammingInEmacs">python-mode</a>，如果已经是Emacs用户，这款编辑器当是写Python的不二之选。编辑器之神的Vim排第二，如果你比较喜欢折腾Vim8.0的插件，或者想自己构建NeoVim的话。其它的编辑器，我不知道，不想用。不过PyCharm是Jetbrains家的IDE，靠谱。</p>
<p>有功夫在Terminal中装一个<code>emacsclient</code>，然后下载一个oh-my-zsh的插件<code>emacsclient</code>，就可以很愉悦地在Terminal中使用Emacs编辑文件了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ te hello_world.py # te: aliased to /Users/qianyan/.oh-my-zsh/plugins/emacs/emacsclient.sh -nw</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">hello_world.py</span><br><span class="line">Ctrl+x+c 退出emacs :)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(&quot;hello world&quot;)</span><br><span class="line"></span><br><span class="line">$ python3 hello_world.py</span><br><span class="line">hello world</span><br><span class="line">$ python3 -m hello_world #注意没有.py的后缀</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><p>基本工具比较好把握，但是何时选择什么工具做什么样的事情就不好拿捏了，而且如何把事情做成Pythonic的模样也是对经验和能力的考验。</p>
<p>如果我们不是编程小白的话，就需要充分利用迁移学习的能力了。学习的最好方法就是解决问题。不得不承认，在动手实践的过程，时间走得是最快的，在同一件事上花的时间越多也就越熟悉。</p>
<p>我们尝试用Python编写一个<code>tree</code>命令行（Command-Line Application），顾名思义，打印目录层级结构的程序，详细描述参看这篇<a href="https://www.jianshu.com/p/eb12371e7768">命令行中 tree 的多重实现</a>。</p>
<h3 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h3><p>怎么写测试呢？多年养成的TDD习惯让我首先想要了解什么是Python中常用的测试工具。答案不难寻找，unittest是Python内置的测试模块，而<a href="https://pytest.org/">pytest</a>是比unittest更简洁和强大的选择，所以我选择后者。</p>
<p>这个程序的测试我使用pytest，但是它并不是所有项目测试的唯一选择，所以最好能局部安装，尤其是限制在当前工程目录里。搜索查找的结果是，Python3内置的虚拟环境（Virtual Environment)模块可以做到这点。</p>
<hr>
<p>虚拟环境<br>在当前创建venv目录(python3 -m venv venv)，然后用<code>tree</code>命令查看该目录的结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 -m venv venv</span><br><span class="line">$ tree -L 4 venv</span><br><span class="line">venv</span><br><span class="line">├── bin</span><br><span class="line">│   ├── activate</span><br><span class="line">│   ├── activate.csh</span><br><span class="line">│   ├── activate.fish</span><br><span class="line">│   ├── easy_install</span><br><span class="line">│   ├── easy_install-3.6</span><br><span class="line">│   ├── pip</span><br><span class="line">│   ├── pip3</span><br><span class="line">│   ├── pip3.6</span><br><span class="line">│   ├── python -&gt; python3</span><br><span class="line">│   └── python3 -&gt; /usr/local/bin/python3</span><br><span class="line">├── include</span><br><span class="line">├── lib</span><br><span class="line">│   └── python3.6</span><br><span class="line">│       └── site-packages</span><br><span class="line">│           ├── __pycache__</span><br><span class="line">│           ├── easy_install.py</span><br><span class="line">│           ├── pip</span><br><span class="line">│           ├── pip-9.0.3.dist-info</span><br><span class="line">│           ├── pkg_resources</span><br><span class="line">│           ├── setuptools</span><br><span class="line">│           └── setuptools-39.0.1.dist-info</span><br><span class="line">└── pyvenv.cfg</span><br></pre></td></tr></table></figure>
<p>进入虚拟环境，然后使用pip3安装pytest测试模块，会发现venv目录多了些东西。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$  . venv/bin/activate</span><br><span class="line">venv ❯ pip3 install pytest</span><br><span class="line">Collecting pytest</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ tree -L 4 venv</span><br><span class="line">venv</span><br><span class="line">├── bin</span><br><span class="line">│   ├── py.test</span><br><span class="line">│   ├── pytest</span><br><span class="line">├── include</span><br><span class="line">├── lib</span><br><span class="line">│   └── python3.6</span><br><span class="line">│       └── site-packages</span><br><span class="line">│           ├── __pycache__</span><br><span class="line">│           ├── _pytest</span><br><span class="line">│           ├── atomicwrites-1.1.5.dist-info</span><br><span class="line">│           ├── attr</span><br><span class="line">│           ├── attrs-18.1.0.dist-info</span><br><span class="line">│           ├── more_itertools</span><br><span class="line">│           ├── more_itertools-4.2.0.dist-info</span><br><span class="line">│           ├── pluggy</span><br><span class="line">│           ├── pluggy-0.6.0.dist-info</span><br><span class="line">│           ├── py</span><br><span class="line">│           ├── py-1.5.3.dist-info</span><br><span class="line">│           ├── pytest-3.6.2.dist-info</span><br><span class="line">│           ├── pytest.py</span><br><span class="line">│           ├── six-1.11.0.dist-info</span><br><span class="line">│           └── six.py</span><br></pre></td></tr></table></figure>
<p>此时，虚拟环境会在<code>PATH</code>变量中前置<code>./bin</code>目录，所以可以直接使用<code>pytest</code>命令进行测试。根据约定，测试文件的名称必须以test_开头，如test_pytree.py，测试方法也必须如此，如test_fix_me。遵循约定编写一个注定失败的测试如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">test_pytree.py</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def test_fix_me():</span><br><span class="line">    assert 1 == 0</span><br><span class="line"></span><br><span class="line">$ pytest</span><br><span class="line">...</span><br><span class="line">    def test_fix_me():</span><br><span class="line">&gt;       assert 1 == 0</span><br><span class="line">E       assert 1 == 0</span><br><span class="line">test_pytree.py:5: AssertionError</span><br></pre></td></tr></table></figure>
<p>测试失败了，说明测试工具的打开方式是正确的。在进入测试、实现和重构（红-绿-黄）的心流状态之前，我们需要考虑测试和实现代码该放在哪里比较合适。</p>
<p>假设我们会把pytree作为应用程序分发出去供别人下载使用，那么标准的目录结构和构建脚本是必不可少的，Python自然有自己的一套解决方案。</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>在<a href="https://packaging.python.org/tutorials/packaging-projects/">Packaging Python Projects</a>的指导下，我们略作调整，创建和源代码平级的测试目录（tests），得到的完整目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGES</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── docs</span><br><span class="line">├── pytree</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── __version__.py</span><br><span class="line">│   ├── cli.py</span><br><span class="line">│   └── core.py</span><br><span class="line">├── setup.cfg</span><br><span class="line">├── setup.py</span><br><span class="line">├── tests</span><br><span class="line">│   ├── fixtures</span><br><span class="line">│   └── test_pytree.py</span><br><span class="line">└── venv</span><br></pre></td></tr></table></figure>
<p>这样的目录结构不仅可以清晰地模块化，隔离测试和实现，提供使用指导和版本更新记录，还可以很方便地做到包依赖管理和分发，这得归功于setup.py，它是Python项目中事实标准（de facto standard）上的依赖和构建脚本，pytree下的setup.py内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># setup.py</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from setuptools import setup, find_packages</span><br><span class="line">from codecs import open</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">here = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"></span><br><span class="line">about = &#123;&#125;</span><br><span class="line">with open(os.path.join(here, &#x27;pytree&#x27;, &#x27;__version__.py&#x27;), &#x27;r&#x27;, &#x27;utf-8&#x27;) as f:</span><br><span class="line">    exec(f.read(), about)</span><br><span class="line">    </span><br><span class="line">with open(&#x27;README.md&#x27;) as f:</span><br><span class="line">    readme = f.read()</span><br><span class="line"></span><br><span class="line">with open(&#x27;LICENSE&#x27;) as f:</span><br><span class="line">    license = f.read()</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=&#x27;pytree&#x27;,</span><br><span class="line">    version=about[&#x27;__version__&#x27;],</span><br><span class="line">    description=&#x27;list contents of directories in a tree-like format.&#x27;,</span><br><span class="line">    long_description=readme,</span><br><span class="line">    author=&#x27;Yan Qian&#x27;,</span><br><span class="line">    author_email=&#x27;qianyan.lambda@gmail.com&#x27;,</span><br><span class="line">    url=&#x27;https://github.com/qianyan/pytree&#x27;,</span><br><span class="line">    license=license,</span><br><span class="line">    packages=find_packages(exclude=(&#x27;tests&#x27;, &#x27;docs&#x27;)),</span><br><span class="line">    classifiers=(</span><br><span class="line">        &quot;Programming Language :: Python :: 3&quot;,</span><br><span class="line">        &quot;License :: OSI Approved :: MIT License&quot;,</span><br><span class="line">        &quot;Operating System :: OS Independent&quot;,</span><br><span class="line">    ),</span><br><span class="line">    setup_requires=[&#x27;pytest-runner&#x27;],</span><br><span class="line">    tests_require=[&#x27;pytest&#x27;],</span><br><span class="line">    entry_points = &#123;</span><br><span class="line">        &#x27;console_scripts&#x27;: [</span><br><span class="line">            &#x27;pytree = pytree.cli:main&#x27;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    install_requires=[]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>setup.py能帮助我们解决测试中依赖模块的问题，这样我们把pytree作为一个package引入到测试代码中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">venv ❯ python3</span><br><span class="line">Python 3.6.5 (default, Jun 17 2018, 12:13:06)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 9.1.0 (clang-902.0.39.2)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import sys, pprint</span><br><span class="line">&gt;&gt;&gt; pprint.pprint(sys.path)</span><br><span class="line">[&#x27;&#x27;,</span><br><span class="line"> &#x27;/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&#x27;,</span><br><span class="line"> &#x27;/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6&#x27;,</span><br><span class="line"> &#x27;/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload&#x27;,</span><br><span class="line"> &#x27;/Users/qianyan/Projects/personal/public/pytree/venv/lib/python3.6/site-packages&#x27;,</span><br><span class="line"> &#x27;/Users/qianyan/Projects/personal/public/pytree/venv/lib/python3.6/site-packages/docopt-0.6.2-py3.6.egg&#x27;,</span><br><span class="line"> &#x27;/Users/qianyan/Projects/personal/public/pytree&#x27;]</span><br></pre></td></tr></table></figure>
<p>然后运行<code>pytest</code>或者<code>python3 setup.py  pytest</code>，此时pytest会把<code>.pytree/tests</code>前置到<code>PATH</code>变量中，验证如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># test_pytree.py</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def test_path():</span><br><span class="line">    assert sys.path == &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">venv ❯ pytest</span><br><span class="line">-&gt; AssertionError: assert [&#x27;/Users/qianyan/Projects/personal/public/pytree/tests&#x27;, </span><br><span class="line">&#x27;/Users/qianyan/Projects/personal/public/pytree/venv/bin&#x27;, ...] == &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">venv ❯ python3 setup.py pytest</span><br><span class="line">-&gt; AssertionError: assert [&#x27;/Users/qianyan/Projects/personal/public/pytree/tests&#x27;, </span><br><span class="line">&#x27;/Users/qianyan/Projects/personal/public/pytree&#x27;, ...] == &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p>这里<code>python3 setup.py pytest</code>可以通过setup.cfg设置别名（alias）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># setup.cfg</span><br><span class="line">[aliases]</span><br><span class="line">test=pytest</span><br></pre></td></tr></table></figure>
<p><code>python3 setup.py test</code>的效果和前面的命令等同。</p>
<p>使用TDD的方式实现了pytree核心的功能（<a href="https://github.com/qianyan/pytree">源代码</a>），然后考虑如何把它变成真正的命令行程序。首先要解决的问题是如何以用户友好的方式显示需要哪些传入参数，我们期待<code>pytree -h</code>能提供一些帮助信息，为了不重复造轮子，挑选现成的Option解析库比较轻松。Python内置的argparse已经足够用了，不过docopt值得尝试。</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>setup.py提供了依赖管理功能，声明依赖及其版本号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># setup.py</span><br><span class="line">...</span><br><span class="line">install_requires=[docopt==0.6.2]</span><br></pre></td></tr></table></figure>
<p>然后运行<code>python3 setup.py develop</code>安装。就绪之后，编写cli.py作为命令行程序的入口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin env python3</span><br><span class="line">&quot;&quot;&quot;list contents of directories in a tree-like format.</span><br><span class="line">  Usage: </span><br><span class="line">    pytree &lt;dir&gt;</span><br><span class="line">    pytree -h | --help | --version</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import pytree.core as pytree</span><br><span class="line">import pytree.__version__ as version</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    from docopt import docopt</span><br><span class="line">    arguments = docopt(__doc__, version=version.__version__)</span><br><span class="line">    dir_name = arguments[&#x27;&lt;dir&gt;&#x27;] </span><br><span class="line">    print(&#x27;\n&#x27;.join(pytree.render_tree(pytree.tree_format(&#x27;&#x27;, dir_name))))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>通过打印help信息的方式验证是否符合预期：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 pytree/cli.py --help</span><br><span class="line">list contents of directories in a tree-like format.</span><br><span class="line">  Usage:</span><br><span class="line">    pytree &lt;dir&gt;</span><br><span class="line">    pytree -h | --help | --version</span><br></pre></td></tr></table></figure>
<p>当然理想的结果是直接可以运行<code>pytree --help</code>，setup.py的<code>console_scripts</code>刚好派上用场。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># setup.py</span><br><span class="line">    entry_points = &#123;</span><br><span class="line">        &#x27;console_scripts&#x27;: [</span><br><span class="line">            &#x27;pytree = pytree.cli:main&#x27; #以pytree作为命令行程序的调用名</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此时查看<code>which pytree</code>显示<code>/Users/qianyan/Projects/personal/public/pytree/venv/bin/pytree</code>，说明pytree已经在路径变量当中，可以直接执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pytree tests/fixtures</span><br><span class="line">tests/fixtures</span><br><span class="line">└── child</span><br></pre></td></tr></table></figure>
<p>完成了命令行程序并通过测试，我们尝试发布到测试仓库（TestPyPI）供其他人下载使用。</p>
<h3 id="包发布"><a href="#包发布" class="headerlink" title="包发布"></a>包发布</h3><p>依照<a href="https://packaging.python.org/tutorials/packaging-projects/">文档描述</a>，先去TestPyPI注册用户，本地打包成发行版，然后安装twine工具发布。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 -m pip install --upgrade setuptools wheel</span><br><span class="line">$ python3 setup.py sdist bdist_wheel</span><br><span class="line">$ pytree dist # pytree查看dist目录</span><br><span class="line">dist</span><br><span class="line">├── pytree-1.0.2-py3-none-any.whl</span><br><span class="line">└── pytree-1.0.2.tar.gz</span><br><span class="line">$ python3 -m pip install --upgrade twine</span><br><span class="line">$ twine upload --repository-url https://test.pypi.org/legacy/ dist/* #or twine upload --repository testpypi dist/* 如果你配置了~/.pypirc</span><br></pre></td></tr></table></figure>
<p>上传成功需要一段时间，等待服务完成同步才可以下载，我们在另一个虚拟环境中进行验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 -m venv test</span><br><span class="line">$ . test/bin/activate</span><br><span class="line">test &gt; python3 -m pip install --index-url https://test.pypi.org/simple/ pytree==1.0.2</span><br><span class="line">test &gt; ls venv/lib/python3.6/site-packages/</span><br><span class="line">...</span><br><span class="line">pytree</span><br><span class="line">pytree-1.0.2.dist-info</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>确保site-packages目录下有这两个目录：pytree和pytree-1.0.2.dist-info，然后我们就可以完成最后的验证阶段了，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test &gt; pytree tests/fixtures</span><br><span class="line">tests/fixtures</span><br><span class="line">└── child</span><br></pre></td></tr></table></figure>

<p>这里版本号之所以是1.0.2，是因为已经上传过了0.0.1, 1.0.0, 1.0.1 等版本，TestPyPI不允许同名同版本的文件重复上传，即使删除原来的文件也不行。前面的版本都有一定的错误，错误的根因在于<code>find_packages</code>以及<code>package_dir</code>的配置项文档说明很模糊，而且只有到上传到TestPyPI然后下载下来，才能验证出来，这种缓慢的反馈是Python的应该诟病的地方。</p>
<hr>
<p><strong>注意</strong><br>find_package()也是一个深坑，第一个参数如果写成<code>find_packages(&#39;pytree&#39;, exclude=...)</code>，那么pytree下的所有Python文件都会被忽略。原因是pytree已经是package，所以不应该让setup去这个目录找其他的packages. </p>
<p>这个<code>package_dir</code>也是如此，我们如果设置<code>package_dir=&#123;&#39;&#39;: &#39;pytree&#39;&#125;</code>，setup.py就会将<code>/Users/qianyan/Projects/personal/public/pytree/pytree</code>前置到<code>PATH</code>中，这会导致<code>console_scripts&#39;: [&#39;pytree = pytree.cli:main&#39;]</code>抛出错误 ModuleNotFoundError: no module named ‘pytree’，究其原因是<code>pytree/pytree</code>导致setup尝试在<code>pytree/pytree</code>这个package里头找自己（pytree），自然找不到。但是如果改成<code>console_scripts&#39;: [&#39;pytree = cli:main&#39;]</code>，因为cli在<code>pytree/pytree</code>底下，所以就能成功执行。当然这是一种<strong>错误</strong>的写法。</p>
<h2 id="如果遇到了-ModuleNotFoundError-no-module-named-‘pytree’-的错误，最好的方式就是import-sys-pprint然后pprint-pprint-sys-path-，很容易发现Python运行时的执行路径，这有助于排查潜在的配置错误。"><a href="#如果遇到了-ModuleNotFoundError-no-module-named-‘pytree’-的错误，最好的方式就是import-sys-pprint然后pprint-pprint-sys-path-，很容易发现Python运行时的执行路径，这有助于排查潜在的配置错误。" class="headerlink" title="如果遇到了  ModuleNotFoundError: no module named ‘pytree’  的错误，最好的方式就是import sys, pprint然后pprint.pprint(sys.path)，很容易发现Python运行时的执行路径，这有助于排查潜在的配置错误。"></a>如果遇到了  ModuleNotFoundError: no module named ‘pytree’  的错误<br>，最好的方式就是<code>import sys, pprint</code>然后<code>pprint.pprint(sys.path)</code>，很容易发现Python运行时的执行路径，这有助于排查潜在的配置错误。</h2><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ol>
<li><a href="https://github.com/qianyan/pytree/">Pytree Source Code</a></li>
<li><a href="http://docs.python-guide.org/en/latest/">The Hitchhiker’s Guide to Python</a></li>
<li><a href="https://www.emacswiki.org/emacs/PythonProgrammingInEmacs">Emacs python-mode</a></li>
<li><a href="https://pytest.org/">Python Test Tool</a></li>
<li><a href="https://packaging.python.org/tutorials/packaging-projects/">Packaging Python Projects</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型编程</title>
    <url>/2018/09/18/the-generic-programming/</url>
    <content><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>泛型编程是一种编程风格，其中算法以尽可能抽象的方式编写，而不依赖于将在其上执行这些算法的数据形式。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-2bfc87e93ae5b6c6.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="泛型编程的提出者"></p>
<p>泛型这个词并不是通用的，在不同的语言实现中，具有不同的命名。在Java&#x2F;Kotlin&#x2F;C#中称为泛型（Generics），在ML&#x2F;Scala&#x2F;Haskell中称为Parametric Polymorphism，而在C++中被叫做模板（Template），比如最负盛名的C++中的STL。任何编程方法的发展一定是有其目的，泛型也不例外。泛型的主要目的是加强类型安全和减少强制转换的次数。</p>
<h2 id="Java中的泛型编程"><a href="#Java中的泛型编程" class="headerlink" title="Java中的泛型编程"></a>Java中的泛型编程</h2><p>在Java中有泛型类和泛型方法之分，这些都是表现形式的改变，实质还是将算法尽可能地抽象化，不依赖具体的类型。</p>
<blockquote>
<p>generics add a way to specify concrete types to general purposes classes and methods that operated on Object before</p>
</blockquote>
<p>通用的类和方法，具有代表性的就是集合类。在Java1.5之前，Java中的泛型都是通过单根继承的方式实现的。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayList // before  Java SE 5.0</span><br><span class="line">&#123;</span><br><span class="line">    public Object get(int i)</span><br><span class="line">    public void add(Object o)</span><br><span class="line">    public boolean contains(Object o);</span><br><span class="line">    private Object[] elementData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然算法足够通用了，但是这样会带来两个问题。一个是类型不安全，还有一个是每次使用时都得强制转化。减少类型转换次数比较容易理解，在没有泛型（参数化类型）的时候，装进容器的数据，其类型信息丢失了，所以取出来的时候需要进行类型转换。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(1);</span><br><span class="line"></span><br><span class="line">assertThat(list.get(0), instanceOf(Integer.TYPE));</span><br><span class="line">assertThat((Integer)list.get(0), is(1)); //存在强制转换</span><br></pre></td></tr></table></figure>
<p>因为这个类里只有Object的声明，所以任意类型的对象都可以加入到这个集合当中，在使用过程中就会存在强制到具体的类型失败的问题，这将丧失编译器检查的好处。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(&quot;any type&quot;);</span><br><span class="line"></span><br><span class="line">assertThat(list.get(1), instanceOf(String.class));</span><br><span class="line">assertThat((Integer) list.get(1), is(1));//-&gt; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer</span><br></pre></td></tr></table></figure>
<p>2005 Java SE 5引入了泛型，不仅有效地提高了算法的通用程度，同时也保留强类型语言在编译期检查的好处。</p>
<blockquote>
<p>Generics This long-awaited enhancement to the type system allows a type or method to operate on objects of various types while providing compile-time type safety. It adds compile-time type safety to the Collections Framework and eliminates the drudgery of casting.</p>
</blockquote>
<p>所以上述的程序会写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(1);</span><br><span class="line">// list.add(&quot;no way&quot;); 编译出错</span><br><span class="line">assertThat(list.get(0), instanceOf(Integer.TYPE));</span><br><span class="line">assertThat(list.get(0), is(1)); // 不需要强制转换</span><br></pre></td></tr></table></figure>
<h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>在静态强类型语言中，编译期间的检查非常重要，因为它可以有效地避免低级错误。这些低级错误就是类型安全解决的问题。类型安全包含了赋值安全和调用安全。其底层实质上就是在某块内存中，始终存在被同种类型的指针指向。</p>
<ol>
<li>类型赋值检查<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long l_num = 1L;</span><br><span class="line">int i_num = l_num; // 编译错误</span><br></pre></td></tr></table></figure>
在强类型的语言当中，类型不一致是无法互相赋值的。</li>
</ol>
<p>2. 类型调用检查<br> Clojure就是一门强类型语言，而且还是一门函数式语言，所以重新赋值不被允许，它的类型安全表现在针对类型的调用安全。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user=&gt; (+ &quot;&quot; 1)</span><br><span class="line">...</span><br><span class="line">java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number</span><br></pre></td></tr></table></figure>
<p>这里存在一个隐式类型转化的过程，但是由于String无法转化成Number，所以方法调用失败。由于Clojure是动态语言，所以只有在运行时才会抛出错误。</p>
<p>另一个简单的例子，如果一个类型不存在某个方法，那就没法去调用它。在动态强类型语言中，运行时一定会报错。其实质是类型是内存堆上的一块区域，如果该区域之上没有想要调用的方法，那么调用在编译期或者运行期间一定会出错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Object().sayNothing() // 编译出错</span><br></pre></td></tr></table></figure>
<p>为什么说类型安全对于开发人员友好，这个特性对于编程语言很重要？其实这可以追溯到三次编程范式解决的根本问题上。Clean Architecture（架构整洁之道）一书中，对结构化，面向对象和函数式编程语言做了很透彻的分析。</p>
<p>首先我们得明确一点，这些范式从来没有扩展编程语言的能力，而是在不同方面对编程语言的能力进行了约束。</p>
<ol>
<li>结构化编程<br>对程序的直接控制进行约束和规范，goto considered harmful.</li>
<li>面向对象编程<br>对程序的间接控制进行约束和规范，pointer considered harmful.</li>
<li>函数式编程<br>对程序的赋值进行约束和规范，mutability considered harmful.</li>
</ol>
<p>按照这样的思路，泛型编程无非是对既有的范式做了进一步的约束。泛型编程旨在对程序的间接控制进一步进行约束和规范。它把类型安全放在第一位，而将类型转化限制在编译期间。</p>
<p>我们甚至可以遵循前面的定义方式，说：<br>2.1 泛型编程<br>对程序的间接控制<strong>进一步</strong>进行约束和规范，type casting considered harmful.</p>
<h2 id="Kotlin中的泛型编程"><a href="#Kotlin中的泛型编程" class="headerlink" title="Kotlin中的泛型编程"></a>Kotlin中的泛型编程</h2><p><img src="https://upload-images.jianshu.io/upload_images/217988-6d226cf160f832ba.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="variance - 变化"><br>和Java泛型中的泛型方法和泛型类概念类似，Kotlin将对应的概念称为参数化函数和参数化类型。</p>
<h3 id="parameterized-function-参数化函数"><a href="#parameterized-function-参数化函数" class="headerlink" title="parameterized function 参数化函数"></a>parameterized function 参数化函数</h3><p>假设我们要返回三个对象中任一一个对象，同时保证类型一致。参数化函数是很恰当的选择。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun &lt;T&gt; random(one: T, two: T, three: T): T</span><br></pre></td></tr></table></figure>
<h3 id="parameterized-type-参数化类型"><a href="#parameterized-type-参数化类型" class="headerlink" title="parameterized type 参数化类型"></a>parameterized type 参数化类型</h3><p>除了参数化函数，类型本身也可以定义自己的参数化类型。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Dictionary&lt;K, V&gt;</span><br></pre></td></tr></table></figure>
<h3 id="bounded-polymorphism-限定参数化类型"><a href="#bounded-polymorphism-限定参数化类型" class="headerlink" title="bounded polymorphism 限定参数化类型"></a>bounded polymorphism 限定参数化类型</h3><p>大部分情况下，参数化类型不会是无限抽象的，无限抽象往往不利于语言的表达性。所以限定的参数化类型应运而生。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun &lt;T : Comparable&lt;T&gt;&gt; min(first: T, second: T): T &#123;</span><br><span class="line">    val k = first.compareTo(second)</span><br><span class="line">    return if (k &lt;= 0) first else second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要用多个边界来限定类型，则需要用到<code>where</code>语句，表达<code>T</code>被多个边界类或者接口限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MultipleBoundedClass&lt;T&gt; where T : Comparable&lt;T&gt;, T : Serializable</span><br></pre></td></tr></table></figure>
<h3 id="invariance-不变"><a href="#invariance-不变" class="headerlink" title="invariance 不变"></a>invariance 不变</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-df2dfb855f6f9755.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invariance 不变"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open class Animal</span><br><span class="line">class Dog : Animal()</span><br><span class="line">class Cat : Animal()</span><br><span class="line">class Box&lt;T&gt;(val elements: MutableList&lt;T&gt;) &#123;</span><br><span class="line">    fun add(t: T) = elements.add(t)</span><br><span class="line">    fun last(): T = elements.last()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun foo(box: Box&lt;Animal&gt;)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val box = Box(mutableListOf(Dog()))</span><br><span class="line">// -&gt; val box: Box&lt;Dog&gt; = Box(mutableListOf(Dog()))</span><br><span class="line">box.add(Dog()) // ok</span><br><span class="line">box.add(Cat()) // 编译错误</span><br></pre></td></tr></table></figure>
<p>这里出现的编译错误，原因是box的真实类型是<code>Box&lt;Dog&gt;</code>，所以尝试向<code>Box&lt;Dog&gt;</code>中添加<code>Cat</code>对象是不会成功的。这样总能保证类型安全。</p>
<p><code>Dog</code>是<code>Animal</code>的子类型，那么编译器是否承认<code>Box&lt;Dog&gt;</code>是<code>Box&lt;Animal&gt;</code>的子类型，在使用时进行隐式转换呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val box: Box&lt;Animal&gt; = Box(mutableListOf(Dog())) // type inference failed. Expected type mismatch.</span><br></pre></td></tr></table></figure>
<p>编译器是不会允许这样行为发生。原因就是这样做会导致类型不安全。<br>我们试想一下，假如这种转换是允许的，那么我们就可以继续添加其它继承了<code>Animal</code>的子类对象，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val box: Box&lt;Animal&gt; = Box(mutableListOf(Dog())</span><br><span class="line">box.add(Cat())</span><br></pre></td></tr></table></figure>
<p>这样就导致<code>Box&lt;Animal&gt;</code>里面同时保存了<code>Dog</code>和<code>Cat</code>的对象，正如前面提到的，在运行时，调用可能就会抛出<code>ClassCastException</code>，所以这是非类型安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val box = Box(mutableListOf(Dog()))</span><br><span class="line">// val box: Box&lt;Dog&gt; = Box(mutableListOf(Dog()))</span><br><span class="line">val animalBox: Box&lt;Animal&gt; = box // 编译错误</span><br></pre></td></tr></table></figure>

<h3 id="covariance-协变"><a href="#covariance-协变" class="headerlink" title="covariance 协变"></a>covariance 协变</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-87c0b29318f7589d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="covariance 协变"></p>
<p>但是这种限制太过于严苛了，如果我们只需要从这个box读取元素，而不需要往里面添加，那么这种转换就是类型安全的。具体原因稍后再说。</p>
<p>当<code>Dog</code>是<code>Animal</code>的子类型，那么<code>Box&lt;Dog&gt;</code>也是<code>Box&lt;Animal&gt;</code>的子类型，这种继承关系就是协变。在Kotlin中，我们需要使用<code>out</code>关键字表示这种关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CovarianceBox&lt;out T : Animal&gt;(val elements: MutableList&lt;out T&gt;) &#123;</span><br><span class="line">    fun add(t: T) = elements.add(t) //编译错误</span><br><span class="line">    fun last(): T = elements.last()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于这种协变关系，我们可以这样调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val dogs: CovarianceBox&lt;Dog&gt; = CovarianceBox(mutableListOf(Dog(), Dog()))</span><br><span class="line">val animals: CovarianceBox&lt;Animal&gt; = dogs</span><br><span class="line">print(animals.last())</span><br></pre></td></tr></table></figure>
<p>我们注意上面的<code>CovarianceBox</code>的<code>add</code>方法出现了编译错误，原因就是在协变关系中，泛型参数只能作为输出参数，而不能作为输入参数。因为在拒绝了输入泛型参数的前提下，协变发生的时候，才不会出现强制转化的错误。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val dogs: CovarianceBox&lt;Dog&gt; = CovarianceBox(mutableListOf(Dog(), Dog()))</span><br><span class="line">val animals: CovarianceBox&lt;Animal&gt; = dogs</span><br><span class="line">dogs.add(Cat()) // add在这里禁止了</span><br></pre></td></tr></table></figure>
<p>如果<code>CovarianceBox</code>允许<code>add</code>方法，那么box里面就会同时存在多个子类型的实例，这样就会导致类型不安全，所以<code>out</code>修饰的参数化类型，只能在函数的返回值上出现。</p>
<p>不过，这种解决方式也不是万能的，属于杀敌一千，自损八百的战术。因为对于<code>Collection</code>而言，不可能做到任何泛型参数都不会出现在入参的位置上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; &#123;</span><br><span class="line">    public operator fun contains(element: @UnsafeVariance E): Boolean</span><br><span class="line">    public fun containsAll(elements: Collection&lt;@UnsafeVariance E&gt;): Boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，针对这种情况，我们知道某些方法其实并不会有添加的操作，可以在入参的位置上加上<code>@UnsafeVariance</code>，以此消除掉编译器的错误。</p>
<h3 id="contravariance-逆变"><a href="#contravariance-逆变" class="headerlink" title="contravariance 逆变"></a>contravariance 逆变</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-837beeffe65375fc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="contravariance 逆变"></p>
<p>当<code>Dog</code>是<code>Animal</code>的子类型，那么<code>Box&lt;Animal&gt;</code>也是<code>Box&lt;Dog&gt;</code>的子类型，这种继承关系就是逆变。在Kotlin中，我们需要使用<code>in</code>关键字表示这种关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ContravarianceBox&lt;in T&gt;(val elements: MutableList&lt;in T&gt;) &#123;</span><br><span class="line">    fun add(t: T) = elements.add(t)</span><br><span class="line">    fun first(): T = elements.first() // 编译错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于这种逆变关系，我们可以这样调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val animals = ContravarianceBox(mutableListOf(Animal()))</span><br><span class="line">val dogs: ContravarianceBox&lt;Dog&gt; = animals</span><br><span class="line">dogs.add(Dog())</span><br></pre></td></tr></table></figure>
<p>这个时候，类型始终是安全的。但是我们也注意到<code>ContravarianceBox</code>的<code>first</code>方法出现了编译错误，原因就是在逆变关系中，泛型参数只能作为输入参数，而不能作为输出参数。在拒绝了输出参数的前提下，逆变发生的时候，才不会出现强制转换的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val animals = ContravarianceBox(mutableListOf(Animal()))</span><br><span class="line">val dogs: ContravarianceBox&lt;Dog&gt; = animals</span><br><span class="line">dogs.add(Dog())</span><br><span class="line">val dog: Dog = dogs.first() // 编译错误</span><br></pre></td></tr></table></figure>

<h3 id="reification-变现"><a href="#reification-变现" class="headerlink" title="reification 变现"></a>reification 变现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reify is To convert mentally into a thing; to materialize.</span><br></pre></td></tr></table></figure>
<p>Kotlin中的Reification的实现使用的是inline模式，就是在编译期间将类型进行原地替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义</span><br><span class="line">inline fun &lt;reified T : Any&gt; loggerFor(): Logger = LoggerFactory.getLogger(T::class.java)</span><br><span class="line">// 使用</span><br><span class="line">private val logger = loggerFor&lt;AgreementFactory&gt;()</span><br></pre></td></tr></table></figure>
<p>因此，所以原来调用处的代码会在编译期间展开成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private val logger = LoggerFactory.getLogger(AgreementFactory::class.java)</span><br></pre></td></tr></table></figure>
<p>使用<code>reification</code>操作，可以精简掉很多模板代码。</p>
<h3 id="type-projection-类型投影"><a href="#type-projection-类型投影" class="headerlink" title="type projection 类型投影"></a>type projection 类型投影</h3><p><img src="https://upload-images.jianshu.io/upload_images/217988-ee46241507e001e0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="type projection 类型投影"></p>
<p>上述过程中，我们看到协变和逆变都是针对可以编辑的类。但是如果遇到已经存在的类，这件事就得运用类型投影技术。拿<code>Class</code>这个类举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val dog = Dog::class.java</span><br><span class="line">val animal: Class&lt;Animal&gt; = dog //编译不通过</span><br></pre></td></tr></table></figure>
<p>Kotlin中的type projection就是为了解决这个问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val dog = Dog::class.java</span><br><span class="line">val animal: Class&lt;out Animal&gt; = dog</span><br></pre></td></tr></table></figure>
<p>同理，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val animal = Animal::class.java</span><br><span class="line">val dog: Class&lt;in Dog&gt; = animal</span><br></pre></td></tr></table></figure>
<p>我们来看一个真实的场景</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val agreementClass: Class&lt;RentalAgreement&gt; = RentalAgreement::class.java</span><br><span class="line"></span><br><span class="line">private val virtualTable = mapOf(RentalPayload.type to RentalAgreement::class.java)</span><br><span class="line">private fun dispatch(type: String): Class&lt;out Agreement&lt;Payload&gt;&gt; &#123;</span><br><span class="line">    return virtualTable[type]</span><br><span class="line">            ?: throw RuntimeException(&quot;No suitable Agreement of this type found, please check your type: $type&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有这样，我们才能将具体的<code>Class&lt;RentalAgreement&gt;</code>投射到<code>Class&lt;out Agreement&lt;Payload&gt;&gt;</code>父类型之上，后续通过某种方式，实例化出<code>RentalAgreement</code>的实例，其继承自<code>Agreement&lt;Payload&gt;</code>。</p>
<h2 id="泛型编程的思考"><a href="#泛型编程的思考" class="headerlink" title="泛型编程的思考"></a>泛型编程的思考</h2><p><img src="https://upload-images.jianshu.io/upload_images/217988-2ae56647d7c62079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="过程式代码 vs. 面向对象"><br>Bob 大叔的 Clean Code 一书的第六章《对象和数据结构》中提到了一个很有意思的现象：数据、对象的反对称性。在这里，数据结构暴露数据，没有提供有意义的函数；对象把数据隐藏起来，暴露操作数据的函数。</p>
<p>过程式代码会基于数据结构进行操作。例如：首先会定义好数据结构<code>Square</code>, <code>Circle</code>和<code>Triangle</code>，然后统一在<code>area(shape: Any)</code>的函数中求shape数据的面积，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun area(shape: Any): Double &#123;</span><br><span class="line">    return when(shape) &#123;</span><br><span class="line">      is Square -&gt; return shape.side * shape.side</span><br><span class="line">      else -&gt; 0.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而面向对象拥趸一定会嗤之以鼻——显然应该抽象出一个shape类包含<code>area</code>方法，让其它的形状类继承。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    fun area(): Double</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Square(val side: Double) : Shape &#123;</span><br><span class="line">    override fun area(): Double &#123;</span><br><span class="line">        return side * side</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在添加新的形状的要求下，面向对象的代码是优于过程式的，因为面向对象对类型的扩展开放了。而过程式代码却不得不修改原来<code>area</code>方法的实现。</p>
<p>但是，如果此时需要添加一个求周长<code>primeter</code>的函数。相对于面向对象代码，过程式代码由于无需修改原来的实现，反而更加容易扩展。反观面向对象的代码，在接口<code>Shape</code>中添加一个<code>primeter</code>会导致所有的子类都得发生修改。</p>
<p>这就是数据和类型的反对称性。在变化方向不同的时候，它们面临的阻力也是不一样的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-cd7abfea6d757a50.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="隔离阻抗"><br>我们既想要过程式对方法扩展的优点，又执着面向对象自然的类型扩展的好处，该怎么办呢？可以考虑结合起来使用。</p>
<p>这样的结合不是说原有的双向阻力消失了，而是在不同的层次上应用各自的优点。也就是说，<code>Shape</code>需要求面积、周长，同时也要支持类型扩展，这种要求之下，基本不可能调解出一种符合开闭原则的方案。不过，如果对于所有<code>Shape</code>类，都需要统一进行某些操作，例如：集合的排序，过滤等等。那么合并两者的好处就变得可行了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-1baedd1173c5c2ad.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="泛型补充"><br>基于最先分析的通过继承的方式进行泛型编程的缺点：</p>
<ol>
<li>太多强制转换</li>
<li>非类型安全。<br>恰当地引入了泛型<code>T</code>，以期编译期的占位和运行时的替换。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-2a674d8478f7884d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="泛型限定"><br>不过没有限定的泛型大部分情况下是没有用处的，因为无限的抽象没有意义，所以需要更加精准的泛型限定。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-9bc98f8e10201115.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依赖倒置"><br>在我们做完这一切以后，会惊喜地发现依赖倒置（DIP）原则贯穿始终。不论是继承体系，还是改善之后的泛型继承体系。它们秉持的原则就是在编译期，始终朝着稳定、抽象的方向移动，而且不断在易变、具体的方向延迟决策，直到运行时方能确定。</p>
<h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><p><img src="https://upload-images.jianshu.io/upload_images/217988-613c079cce8d4fa5.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="书籍推荐"></p>
<h2 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h2><p><img src="https://upload-images.jianshu.io/upload_images/217988-8f2ce836e7ea45a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="知识梳理"></p>
<hr>
<p>参考链接<br><a href="https://www.jianshu.com/p/64b2d11decbc">泛型 一个会写诗的程序员</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>架构整洁之道导读（二）组件聚合</title>
    <url>/2019/01/17/Guide-to-Clean-Architecture-2/</url>
    <content><![CDATA[<h2 id="组件聚合"><a href="#组件聚合" class="headerlink" title="组件聚合"></a>组件聚合</h2><h3 id="组件的定义"><a href="#组件的定义" class="headerlink" title="组件的定义"></a>组件的定义</h3><p>组件是软件部署的最小单元，是整个软件系统在部署过程中可以独立完成部署的最小实体。比如，对于Java应用程序而言，Jar包就是组件；Ruby中的组件则是Gem文件；Python中的Egg或Wheel文件以及.Net下的DLL文件。</p>
<p>上回我们说到，编程范式的本质是约束。子过程、类或函数是我们编程过程中的基本元素，所以说编程范式是程序的基础构件。如果将这些基本构件比作建筑里的泥沙石，那么程序中的组件就可以类比成砖头。砖头的工艺注重材料配比，组件也是如此，恰如其分的基础构件配比是组件稳定的基础。组件的内容配比较难定量，但是在实践上，仍然受到指导原则的约束。</p>
<h3 id="软件工程中的约束三角"><a href="#软件工程中的约束三角" class="headerlink" title="软件工程中的约束三角"></a>软件工程中的约束三角</h3><p>在软件工程中，我们会看到很多约束条件都能由三角形的方式体现出来。这是因为三角形除了具有稳定的特性以外，还能体现出一种张力。<br><img src="https://upload-images.jianshu.io/upload_images/217988-c19cb030d6c0b04c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="软件开发中的各种三角"></p>
<p>比如在敏捷项目管理中，我们常会听到时间，资源和成本的约束三角；在分布式计算中，著名的CAP（一致性，可用性和分区容错性）原理也是如此；还有区块链中的不可能三角（性能，安全和去中心化）。这些三角都在反映一种现实中的约束——因为不能全部同时满足，所以需要权衡。</p>
<h3 id="组件聚合张力图"><a href="#组件聚合张力图" class="headerlink" title="组件聚合张力图"></a>组件聚合张力图</h3><p>组件的内容配比，最终反映在组件的实践上就是基本构件的拆与合。鲍勃大叔给出了三个拆合的指导原则：REP（复用&#x2F;发布等同原则），CCP（共同闭包原则）和CRP（共同复用原则）。<br><img src="https://upload-images.jianshu.io/upload_images/217988-e21240f0dc564114.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组件聚合张力图"></p>
<ol>
<li>REP（复用&#x2F;发布等同原则）：软件复用的最小粒度应该等同于其发布的最小粒度（注：只有那些通过版本追踪系统发布的组件才能被高效地复用）</li>
<li>CCP（共同闭包原则）：将同时修改，目的相同的类放到同一个组件；不会同时修改，目的不同的类放到不同的组件</li>
<li>CRP（共同复用原则）：不要强迫一个组件的用户依赖他们不需要的东西</li>
</ol>
<p>这些原则乍看上去是全新的理念，细细品来又好像“新瓶装旧酒”的老把戏。CCP不就是SRP（单一职能原则）？CRP不就是ISP（接口隔离原则）？REP，等等，这个原则不言自明地像个公理呀！难怪有些架构师朋友说，鲍勃大叔老了，又拿着SOLID那一套概念出来忽悠<del>骗钱</del>。</p>
<p>其实，不妨换个思路想想，通常当谈论SOLID、高内聚低耦合、稳定依赖、稳定抽象系列原则的时候，我们是处于软件系统生命周期的哪一环？不出意外，大家都是从编写源代码，即开发（Development）的角度出发的。但是，我们又清晰地了解，软件系统的生命周期其实还包含除开发之外的部署、发布，运行和维护环节。那么问题来了，在这些环节里，哪些指导原则是适用的呢？</p>
<p>在跳脱了开发的思维桎梏之后，我们通过两种手段分析下这三条原则。</p>
<h4 id="分开看"><a href="#分开看" class="headerlink" title="分开看"></a>分开看</h4><p>REP原则阐述了一个简单的道理：软件复用是基本要求。在追求软件复用的过程中，逐步形成了标准的发布流程，如：版本号（<a href="https://semver.org/lang/zh-CN/">语义化版本</a>），发布时间，变更内容等。这要求组件中所包含的模块和类都必须同时可发布，而可发布的深层含义既是对用户的承诺，也是对作者的约束。组件是否向后兼容？是否包含破坏性的变更？升级的注意事项？</p>
<p>CCP原则是指尽量把变更频率相同的模块和类放到同一个组件当中。这样做的好处是，当相关功能更新时，我们可以把源代码的变更局限在某一个组件当中，而不需要横跨多个组件，从而减少了部署，验证和发布的次数。概括来说，这是<strong>局部化影响</strong>的优势。CCP和OCP（开闭原则）中强调的“闭包”也有关联，所谓<strong>封装可变因素</strong>就是形成闭包的过程，CCP要求将同一时间变更的点聚合起来，达到闭包的效果。</p>
<p>CRP原则是说组件和组件之间的依赖应该达成一种默契——如果不需要完全使用某个组件中所有的模块和类，那么就不要依赖它。这看上去不太可能，但是有一点意义，它指导我们：不是紧密相连的模块和类不应该被放到同一个组件里。因为我们知道一旦某个组件变更升级之后，依赖它的组件往往也会被动的变更升级，即便是和自己那些无关的变更也是如此。而每次变更都意味着重新编译，部署验证和发布。</p>
<h4 id="合起看"><a href="#合起看" class="headerlink" title="合起看"></a>合起看</h4><p>REP原则说明软件复用是基础，复用是通过发布流程规范的。在复用和发布的上下文中，CCP原则为了便于后期维护，需要尽可能地将变更频率相同的模块和类放到相同的复用单元——组件中；CRP原则为了避免频繁发布，应该将每个组件分割的足够小，减少无关变更导致依赖链条的连锁发布反应。</p>
<p>如果我们只兼顾REP和CCP原则，那么就可能由于连锁发布反应，出现很多不必要的发布；如果只兼顾REP和CRP原则，那么就可能因为实现一个功能需要横跨多个组件修改，造成过多的组件变更；如果只兼顾CCP和CRP，那我们可能就忘记了复用这档子事儿，这在先前我们批判鲍勃大叔的时候已经体现出来了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>软件系统的生命周期里处处充斥着约束条件，每多一个环节往往就会多一种矛盾，进而衍生出多个方向的约束。组件聚合张力图反映的是发布和开发之间的矛盾，需要尽量遵循REP，CCP和CRP原则，满足其约束，才能减少变更成本。</p>
<p>组件构建过程中，除了聚合原则，还有耦合原则——描述的是组件的依赖关系。聚合原则告诉我们的是软件系统中的最小元素，耦合原则说的是元素之间的关系，当这两者和系统的功能结合到一起，就构成一个运行着的系统<a href="%5B%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BE%8E%5D(https://www.jianshu.com/p/da088142eef2)">^1</a>。系统是逐渐演化出来，即便我们熟知REP，CCP和CRP原则，也没有办法说，在系统构建之初，遵循这些原则就能画出完美的组件结构图。这便是“自顶而下”的设计不靠谱的基本解释。</p>
<p>“自顶而下”的设计不靠谱还有更深层次的原因。本书的第14章“组件耦合”会有答案，且听下回分解。</p>
<hr>
<p>[1] <a href="/2018/10/28/Guide-to-Clean-Architecture-1/">架构整洁之道导读（一）编程范式</a><br>[2] <a href="/2019/01/17/Guide-to-Clean-Architecture-2-more/">架构整洁之道导读（二）续 组件聚合张力图</a><br>于2018-10-28</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>创建数字钱包（零）KDF 密钥派生算法</title>
    <url>/2019/01/20/Digital-wallet-0-kdf-algorithm/</url>
    <content><![CDATA[<h2 id="KDF-的定义"><a href="#KDF-的定义" class="headerlink" title="KDF 的定义"></a>KDF 的定义</h2><p>实现 key stretching [^1] 的方法，具体就是从一个 master key，password 或者 passphrase 派生出一个或者多个密钥，派生的过程，使用PRF（Pseudo Random Function 伪随机函数）可以是某种哈希算法。</p>
<blockquote>
<p>[Key stretching]<br>密钥延长算法（一种更慢的哈希算法），用于将初始密钥转换成增强密钥，在计算过程中刻意延长时间或者消耗空间，这样有利于保护弱密码。</p>
</blockquote>
<h2 id="两种密钥派生算法"><a href="#两种密钥派生算法" class="headerlink" title="两种密钥派生算法"></a>两种密钥派生算法</h2><h3 id="PBKDF2-CPU-Hard-algorithm"><a href="#PBKDF2-CPU-Hard-algorithm" class="headerlink" title="PBKDF2 (CPU-Hard algorithm)"></a>PBKDF2 (CPU-Hard algorithm)</h3><p>PBKDF2是基于密码派生出密钥的算法，需要消耗很多算力，为了是防止暴力破解加密。</p>
<h3 id="Scrypt-Memory-Hard-algorithm"><a href="#Scrypt-Memory-Hard-algorithm" class="headerlink" title="Scrypt (Memory-Hard algorithm)"></a>Scrypt (Memory-Hard algorithm)</h3><p>Scrypt 也是一种 password-base KDF 算法，比起 PBKDF2 需要消耗更多的资源，从而有效防止了专有硬件 ASIC&#x2F; FPGA 的暴力破解。Scrypt 内部用的还是 PBKDF2 算法，不过内部会长时间地维护一组比特数据，这些数据会在生成复杂的 salt 的过程中反复加密（Salsa20，一种流密码<a href="%5BSalsa20%5D(https://en.wikipedia.org/wiki/Salsa20)">^3</a>）得到。网上流行说，以太坊的PoW共识算法是利用Scrypt实现的，但事实上，以太坊自己实现了一套哈希算法，叫做Ethash<a href="%5BEthash%5D(https://github.com/ethereum/wiki/wiki/Ethash)">^2</a>.</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>一言以蔽之，PBKDF2是算力型，而Scrypt是资源消耗型的。</p>
<blockquote>
<p>Both PBKDF2 and scrypt are key derivation functions (KDFs) that implement key stretching by being deliberately slow to compute and, in particular, by having an adjustable parameter to control the slowness.<br>The difference is that scrypt is also designed to require a large (and adjustable) amount of memory to compute efficiently. The purpose of this is to make cracking it harder to parallelize using devices like GPGPUs or custom ASIC &#x2F; FPGA hardware. Such devices may have hundreds or even thousands of parallel processing units, each capable of hashing a different password using traditional KDFs like PBKDF2, which don’t require much memory. However, it turns out that, at least using current technology, providing each of these parallel units with large amounts of memory space is a lot more difficult and expensive than making the units themselves.</p>
</blockquote>
<h2 id="密钥派生原理"><a href="#密钥派生原理" class="headerlink" title="密钥派生原理"></a>密钥派生原理</h2><p><a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> 运行的原理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passphrase -&gt; [dklen, salt, c] &gt; 1000] -&gt; hash</span><br><span class="line"></span><br><span class="line">DK = PBKDF2(PRF, Password, Salt, c, dkLen)</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li>PRF(Pseudorandom function)：伪随机数产生的密钥，如：hmac-sha256</li>
<li>dklen：派生所产生的密钥的长度</li>
<li>salt（盐值）：是一串随机生成的比特，加载密钥的固定位置做哈希后，可以防止彩虹表攻击导致的密码泄露</li>
<li>c：迭代的次数</li>
<li>DK：期望的密钥 derived key</li>
</ol>
<p>例子：WPA2 (WiFi Protected Access) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DK = PBKDF2(HMAC−SHA1, passphrase, ssid, 4096, 256)</span><br></pre></td></tr></table></figure>

<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><a href="https://en.wikipedia.org/wiki/Password">Password</a><br>密码就是用于证明身份，获取和身份相称的访问权限。</p>
<p><a href="https://en.wikipedia.org/wiki/Passphrase">Passphase</a><br>用于用户认证或者加密程序的操作步骤，特别是KDF算法就是从passphrase中派生出来的。</p>
<p>[^1]: <a href="https://en.wikipedia.org/wiki/Key_stretching">Key stretching</a></p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>digital-wallet</tag>
      </tags>
  </entry>
  <entry>
    <title>架构整洁之道导读（二）续 组件聚合张力图</title>
    <url>/2019/01/17/Guide-to-Clean-Architecture-2-more/</url>
    <content><![CDATA[<h2 id="关于组件聚合张力图的讨论"><a href="#关于组件聚合张力图的讨论" class="headerlink" title="关于组件聚合张力图的讨论"></a>关于组件聚合张力图的讨论</h2><p>周三的午休时间，我在ThoughtWorks北京办公室分享了一场《架构整洁之道导读》。当谈到分享组件聚合原则的时候，很多同事表示难以理解。究其缘由，是我们无法将组件违反原则的后果对应到真实项目的问题上，这就导致原则和实践之间的不一致。讨论的过程异常激烈，但是很遗憾地最终并没有得到一个服众的结论。所以为了进一步澄清这些争议点，我决定专门组织一场针对组件聚合原则张力图的讨论会。在<a href="https://www.jianshu.com/u/49ddfba9ae88">吴大师</a>的鼓动下，时间定在下周四晚上的8点半，与会人员大多是咨询团队的技术教练，也有我们项目上的客户。</p>
<p>在这场长达两个半小时的讨论会上，没想到首先出现争议的点居然是组件的定义。</p>
<blockquote>
<p>组件是软件部署的最小单元，是整个软件系统在部署过程中可以独立完成部署的最小实体。</p>
</blockquote>
<p>对于这样的定义，<a href="https://www.zhihu.com/people/nuo-tie">大魔头</a>提出了质疑：library（库）并不能独立部署。但凡出现明显的逻辑漏洞的时候，我们最好的方式是抛开译文回去看原文。</p>
<blockquote>
<p>Components are the units of deployment. They are the smallest entities that can be deployed as part of a system.</p>
</blockquote>
<p>阅读原文之后，我们发现“组件是软件部署的最小单元。”这句话翻译得并没有太大问题，但是第二句就有损原意了，原意是说<strong>可以作为系统的一部分被部署的最小实体</strong>，而没有强调部署过程这种动态的概念，否则就和前一句是同义反复。所以这个定义里面并没有说组件可以独立部署。后面提到组件可以被链接到一个独立可执行文件或者归档文件，又或者，可以被打包成.jar、.dll或者.exe文件，并以动态加载的插件形式实现<strong>独立部署</strong>。</p>
<h3 id="解读组件的定义"><a href="#解读组件的定义" class="headerlink" title="解读组件的定义"></a>解读组件的定义</h3><p>来自原文：</p>
<blockquote>
<p>Components can be linked together into a single executable. Or they can be aggregated together into a single archive, such as a .war file. Or they can be independently deployed as separate dynamically loaded plugins, such as.jar or .dll or .exe files.</p>
</blockquote>
<p>来自讨论：</p>
<blockquote>
<p>20:56:56	 From tianjie : These dynamically linked files, which can be plugged together at runtime, are the software components of our architectures.</p>
</blockquote>
<p>联系上下文理解之后，我们知道：组件可以被设计成独立部署的，但是并不是所有的组件都是可以独立部署的。这是要澄清的，不然讨论聚合原则的时候容易出现偏差。</p>
<p>吴大师接着解释说，组件应该是个逻辑单元，而不是物理单元。强制某个代码模块就是一个物理的部署单元是不合适的。另外，鲍勃大叔在介绍架构边界时，也表明了一样的观点：架构的边界并不是服务的边界。</p>
<h3 id="解读REP原则"><a href="#解读REP原则" class="headerlink" title="解读REP原则"></a>解读REP原则</h3><p>我按照自己的思路解释过REP、CCP和CRP原则[^1]之后，讨论的焦点很快聚集到REP原则的解读和实践意义上。</p>
<p><a href="https://www.zhihu.com/people/wu-xue-feng/">吴大师</a>认为REP原则如果简单解读成没有发布过程就不能复用，它就和CCP、CRP原则的排斥力量不均衡，无法形成稳定的三角关系，那么这个张力图就显得有点鸡肋。</p>
<p><a href="https://www.thoughtworks.com/cn/profiles/liu-shangqi">尚奇</a>受到CAP（分布式系统基本原理，一致性，可用性和分区容错性）原则的启发提出了另一个解读方向。他说，CAP原则在分布式系统的实践里，都会先站住P原则，然后在C和A中权衡。那么在REP、CCP和CRP三角关系里，REP原则就相当于这里的P原则，必须先满足然后再去取舍CCP和CRP。</p>
<p>大魔头理解REP的意思是可复用性就是组件是独立可复用的。假如回到没有Maven这些工具，没有依赖管理的年代，如果我们所依赖的包还依赖其它第三方包，那么这个包就不能叫做独立可复用。</p>
<blockquote>
<p>21:13:04	 From YangYun : 我倒是理解REP的意思是你发布出来的一个可重用的包就是独立可重用的，你不能让我必须带着别的jar包才能用它。<br>21:14:04	 From YangYun : The granule of reuse is the granule of release</p>
</blockquote>
<p>他接着说，假如有两个提供同样功能的包，其中一个没有第三方的依赖，而另一个有，那我当然选择前者。</p>
<p>技术教练Sara举出了一个相对复杂但是很有启发性的例子。</p>
<blockquote>
<p>21:46:35	 From Qian Ping : 假设项目包含sub module ABC<br> - 如果ABC单纯sub module没有打成jar，又互相直接复用了，就是违反了REP<br> - 如果每个sub module，打成jar，互相复用的时候是通过对方特定版本的jar（如snapshot版本），就是符合REP<br> - 如果符合REP了，而所有sub module是跟随整个项目一起升级版本，就是符合CCP因为他们是一体一起发布的<br> - 这时假如A依赖B和C，我这次单纯想改C，他们一起升版本了。但其实B的Jar完全没有变化，这个对B来说就是一个不必要的发布，B又貌似应该分离出去，但如果它分离出去了，就又离REP和CCP远了</p>
</blockquote>
<p>对于最后一句的表述，她澄清道：</p>
<blockquote>
<p>之前有遇到一个情况，比如组件A，然后它里面需要用到一个common library, lib里面其实包含了比如3个sub module（1&#x2F;2&#x2F;3），全部都是A需要复用的, 这时候如果要改1&#x2F;2&#x2F;3里面任意的东西，都会一起升级lib，然后在A里面对应升级版本。</p>
</blockquote>
<blockquote>
<p>后来，有一些新组件B，它只需要用到common lib里面的3，不需要1&#x2F;2，于是3一直被改和打包版本。 此时1&#x2F;2会跟着升版本号，但其实1&#x2F;2内容本身是完全没有变化的，只是版本号升了。</p>
</blockquote>
<p>这个场景中引入了两个组件A和B分别依赖common library的某些模块。在我们讨论一个组件依赖时，面临的约束要简单很多，但是复用的初衷就是给多个组件去依赖，所以这个假设是很有价值。</p>
<p>Sara分析的思路如下：</p>
<blockquote>
<p>如果分离出去，等于我有两个common lib（1&#x2F;2 和 3）, 对于B来说，B只需要3这么一个lib是比较完美的，反正改了3再改B就好了。</p>
</blockquote>
<blockquote>
<p>但对于A来说，它就需要同时升级1&#x2F;2的lib和3的lib，等于要3个发布，而它原来只需要2个发布（1&#x2F;2&#x2F;3 + A），所以离CRP远了，同时它也要分别维护两个lib分别的版本升级，所以CCP也比原来差了。</p>
</blockquote>
<p>在她的分析下，我们发现CRP和CCP不单是互相排斥的，还有可能两者都无法满足。造成这种结果的原因在于1&#x2F;2&#x2F;3模块形成的这个common library对于A组件而言都符合CCP和CRP原则，但是对于B组件而言，是不满足REP和CRP原则的，因为每次想要依赖3模块，就得全部依赖1&#x2F;2&#x2F;3整个common library（复用困难）。反之，如果我们将3从1&#x2F;2&#x2F;3中拆出来成为独立的组件，那就几乎宣告对于A组件而言势必违反CCP和CRP原则，但是B组件却获得了符合REP和CRP原则的好处。</p>
<p>她接着补充道：</p>
<blockquote>
<p>其实后来说起对应微服务的时候有另外一个想法，就是比如说我系统里面多个组件需要用计提（Mark to market[^2]）这么一个功能，说白了就是一条公式，那通常可以有几个做法</p>
<ul>
<li>直接把这个公式复制到要用的组件，code level的复用，没有版本 -&gt; REP bad, CCP bad, but CRP not bad (因为要更改时候发布次数还是一样的）</li>
<li>把公式写到一个common lib里面再进行复用 -&gt; REP good, CCP good, CRP bad(多发布一次）</li>
<li>把公式放在一个独立service -&gt; REP good, CCP bad(因为要维护多一个服务）, CRP good</li>
</ul>
</blockquote>
<p>这个观点就上升到不同层次的复用性上，可以算是对组件聚合原则的普适性的探索。</p>
<p>当话题再次被聚焦到复用性时，技术教练<a href="https://litongxin.github.io/">MoMo</a>提出一个观点：我们现在讨论就是可复用组件应该遵循的原则，而REP是对复用粒度的定义。至于那些那些常年采用SNAPSHOT（Java项目里Maven常用的开发版本号），没有发布概念的组件，就不该纳入复用的考虑范围内，那些也就不是REP的反模式。</p>
<p>与此同时，<a href="https://mp.weixin.qq.com/s/YkKz4lknR2fqbSgv4JL9Lw">阎王</a>指出了一个翻译上的失误。组件粘合张力图中REP原则的简短描述是“为复用性而组合”，而原文其实是”Group for reusers”，翻译过来应该是为了复用者而组合，复用性的英文是 Reusability。所以为了复用者发布，考虑的就是对外部的承诺。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-97f1eb1dfe9e1314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tension diagram"></p>
<h3 id="外部资料"><a href="#外部资料" class="headerlink" title="外部资料"></a>外部资料</h3><p>大魔头在加班写方案和讨论的间隙，快速查阅了一些资料，比如wiki上对于REP原则的定义：</p>
<blockquote>
<p>21:45:05 From YangYun : Reuse-release Equivalence Principle (REP)<br>REP essentially means that the package must be created with reusable classes – “Either all of the classes inside the package are reusable, or none of them are”. The classes must also be of the same family. Classes that are unrelated to the purpose of the package should not be included. A package constructed as a family of reusable classes tends to be most useful and reusable. - wiki百科里</p>
</blockquote>
<p>在wiki的定义里，可以看到REP原则包含CRP和CCP原则的成分，如此看来，这三大原则并不符合<a href="https://en.wikipedia.org/wiki/MECE_principle">MCME</a>分类原则，就连鲍勃大叔在书中也是模棱两可的态度——REP维护共同的大主题，组件中的类和模块也必须紧密相关，这基本是CCP和CRP的简版描述。</p>
<p>然后大魔头查找到“粒度”这个词在软件设计中详细定义，这是对REP原则定义（软件复用的最小粒度等同于其发布的最小粒度）的分解和再认知。</p>
<blockquote>
<p>21:57:03	 From YangYun : <a href="http://condor.depaul.edu/dmumaugh/OOT/Design-Principles/granularity.pdf">http://condor.depaul.edu/dmumaugh/OOT/Design-Principles/granularity.pdf</a></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-31f16cf3b2bb8922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="granularity"></p>
<blockquote>
<p>21:58:29	 From YangYun : <a href="https://fi.ort.edu.uy/innovaportal/file/2032/1/design_principles.pdf">https://fi.ort.edu.uy/innovaportal/file/2032/1/design_principles.pdf</a></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-c3db0f42dde964ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="design principles"></p>
<p>这些观点和学术建议很有代表性，值得大家反复揣摩和思考。</p>
<h3 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h3><p>软件工程师一般有个“正难则反”的习惯。原则较抽象，但是模式很具体，反模式更能指导实践。接下来，大家开始讨论哪些是违反了REP原则的反模式。</p>
<p>首当其冲的就是<code>git submodule</code>，在某些项目中，这种通过源代码划分模块并共享的方式还是挺常见的。因为共享的是代码，所以每次共享代码更新，势必要让依赖方重新编译，发布和部署。这种做法对于复用是痛苦的。</p>
<p>其次是常年使用SNAPSHOT版本的某些项目。这些项目的特点一般都是某个产品团队底下，内部团队之间有复用的要求。缺点其实也很明显，常年SNAPSHOT等于没有版本和发布的流程。使用者并不知道SNAPSHOT中哪些是稳定的，哪些是修改的，拿到的版本到底是最新的还是遗留的，我需要的功能在这个功能有包含，还是你包含了太多我不需要的升级。这种也是复用痛苦的。</p>
<h3 id="REP原则小结"><a href="#REP原则小结" class="headerlink" title="REP原则小结"></a>REP原则小结</h3><p>综合以上两个例子以及其它讨论，我们得出了一个好玩的结论：软件工程发展到现在，REP原则已经是基本的要求，它的存在有可能是鲍勃大叔年代感<del>老了</del>的体现。</p>
<p>[^1]: <a href="https://www.jianshu.com/p/96e2d580374f">架构整洁之道导读（二）组件聚合</a> <a href="https://www.jianshu.com/p/d651c9fb1755#fnref1"></a><br>[^2]: <a href="https://www.investopedia.com/terms/m/marktomarket.asp">Mark to market 按市值计价</a></p>
<p>[1] <a href="/2018/10/28/Guide-to-Clean-Architecture-1/">架构整洁之道导读（一）编程范式</a><br>[2] <a href="/2019/01/17/Guide-to-Clean-Architecture-2/">架构整洁之道导读（二）组件聚合</a><br>于 2018-11-12</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>创建数字钱包（一）账号生成</title>
    <url>/2019/01/23/Digital-wallet-1-generate-accounts/</url>
    <content><![CDATA[<h2 id="椭圆曲线数字签名算法生成私钥"><a href="#椭圆曲线数字签名算法生成私钥" class="headerlink" title="椭圆曲线数字签名算法生成私钥"></a>椭圆曲线数字签名算法生成私钥</h2><p><a href="https://en.bitcoin.it/wiki/Secp256k1">Secp256k1</a><br>通过椭圆曲线数字签名算法生成私钥和公钥，其中SEC（Standards for Efficient Cryptography）是专门利用ECDSA或者其可选项Schnorr算法来产生高效的加密方法。<br>特点是生成密钥很快。</p>
<p>Scep256k1 基本特性</p>
<ul>
<li>secp256k1 ECDSA signing&#x2F;verification and key generation.</li>
<li>Adding&#x2F;multiplying private&#x2F;public keys.</li>
<li>Serialization&#x2F;parsing of private keys, public keys, signatures.</li>
<li>Constant time, constant memory access signing and pubkey generation.</li>
<li>Derandomized DSA (via RFC6979 or with a caller provided function.)</li>
<li>Very efficient implementation.</li>
</ul>
<h2 id="讲解代码"><a href="#讲解代码" class="headerlink" title="讲解代码"></a>讲解代码</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>生成私钥</li>
<li>加密私钥</li>
<li>生成 keyObject 对象</li>
<li>从keyObject对象中恢复私钥</li>
</ol>
<h3 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h3><p>下面利用 keythereum[^1] 产生符合以太坊的密钥，并产生keyObject文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123; <span class="attr">keyBytes</span>: <span class="number">32</span>, <span class="attr">ivBytes</span>: <span class="number">16</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;privateKey, salt, iv&#125; = keythereum.<span class="title function_">create</span>(params);</span><br></pre></td></tr></table></figure>
<p>keythereum可以产生私钥，以及后面加密私钥所用的PBKDF2算法需要的salt，和加密aes-128-ctr私钥的iv值。</p>
<p>得到私钥之后，我们可以通过私钥生成公钥。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> privateKeyBuffer = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(privateKey, <span class="string">&quot;hex&quot;</span>) <span class="comment">// or &quot;base64&quot;</span></span><br><span class="line"><span class="keyword">let</span> publicKey = secp256k1.<span class="title function_">publicKeyCreate</span>(privateKeyBuffer, <span class="literal">false</span>).<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> address = <span class="string">&quot;0x&quot;</span> + <span class="title function_">keccak256</span>(publicKey).<span class="title function_">slice</span>(-<span class="number">20</span>).<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="加密私钥"><a href="#加密私钥" class="headerlink" title="加密私钥"></a>加密私钥</h3><p>利用KDF算法基于password派生出密钥，然后利用这个密钥加密我们的私钥。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> password = <span class="string">&quot;Hello,Ethereum&quot;</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">kdf</span>: <span class="string">&quot;pbkdf2&quot;</span>,</span><br><span class="line">    <span class="attr">cipher</span>: <span class="string">&quot;aes-128-ctr&quot;</span>,</span><br><span class="line">    <span class="attr">kdfparams</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="number">262144</span>,</span><br><span class="line">        <span class="attr">dklen</span>: <span class="number">32</span>,</span><br><span class="line">        <span class="attr">prf</span>: <span class="string">&quot;hmac-sha256&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> keyObject = keythereum.<span class="title function_">dump</span>(password, privateKey, salt, iv, options);</span><br></pre></td></tr></table></figure>
<p>这就是产生keyObject基本思路。我们在看看dump函数到底做了什么</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">marshal</span>(<span class="variable language_">this</span>.<span class="title function_">deriveKey</span>(password, salt, options), privateKey, salt, iv, options);</span><br></pre></td></tr></table></figure>
<p>deriveKey(…) 的源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">crypto</span>.<span class="title function_">pbkdf2Sync</span>(</span><br><span class="line">        password,</span><br><span class="line">        salt,</span><br><span class="line">        options.<span class="property">kdfparams</span>.<span class="property">c</span> || <span class="variable language_">this</span>.<span class="property">constants</span>.<span class="property">pbkdf2</span>.<span class="property">c</span>,</span><br><span class="line">        options.<span class="property">kdfparams</span>.<span class="property">dklen</span> || <span class="variable language_">this</span>.<span class="property">constants</span>.<span class="property">pbkdf2</span>.<span class="property">dklen</span>,</span><br><span class="line">        prf <span class="comment">//hmac-sha256</span></span><br><span class="line">      );</span><br></pre></td></tr></table></figure>
<p>这里基于password生成的derivedKey，这个密钥并不是我们要用的私钥，而是用来加密先前生成的privateKey的，加密的过程在marshal函数中调用的encrypt函数里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ciphertext = <span class="variable language_">this</span>.<span class="title function_">encrypt</span>(privateKey, derivedKey.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">16</span>), iv, algo).<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>encrypt函数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var cipher, ciphertext;</span><br><span class="line">algo = algo || this.constants.cipher;</span><br><span class="line">if (!this.isCipherAvailable(algo)) throw new Error(algo + &quot; is not available&quot;);</span><br><span class="line"></span><br><span class="line">//加密过程</span><br><span class="line">cipher = this.crypto.createCipheriv(algo, this.str2buf(key), this.str2buf(iv));</span><br><span class="line">ciphertext = cipher.update(this.str2buf(plaintext));</span><br><span class="line"></span><br><span class="line">return Buffer.concat([ciphertext, cipher.final()]);</span><br></pre></td></tr></table></figure>
<p>此处的ciphertext代表的是privateKey，而key则是derivedKey</p>
<h3 id="生成-keyObject-对象"><a href="#生成-keyObject-对象" class="headerlink" title="生成 keyObject 对象"></a>生成 keyObject 对象</h3><p>得到了加密后的ciphertext之后，开始组装keyObject对象并返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keyObject = &#123;</span><br><span class="line">      address: this.privateKeyToAddress(privateKey).slice(2),</span><br><span class="line">      crypto: &#123;</span><br><span class="line">        cipher: options.cipher || this.constants.cipher,</span><br><span class="line">        ciphertext: ciphertext,</span><br><span class="line">        cipherparams: &#123; iv: iv.toString(&quot;hex&quot;) &#125;,</span><br><span class="line">        mac: this.getMAC(derivedKey, ciphertext)</span><br><span class="line">      &#125;,</span><br><span class="line">      id: uuid.v4(), // random 128-bit UUID</span><br><span class="line">      version: 3</span><br><span class="line">    &#125;;</span><br><span class="line">keyObject.crypto.kdf = &quot;pbkdf2&quot;;</span><br><span class="line">      keyObject.crypto.kdfparams = &#123;</span><br><span class="line">        c: options.kdfparams.c || this.constants.pbkdf2.c,</span><br><span class="line">        dklen: options.kdfparams.dklen || this.constants.pbkdf2.dklen,</span><br><span class="line">        prf: options.kdfparams.prf || this.constants.pbkdf2.prf,</span><br><span class="line">        salt: salt.toString(&quot;hex&quot;)</span><br><span class="line">      &#125;;    </span><br></pre></td></tr></table></figure>
<p>privateKeyToAddress(…)方法里首先通过privateKey产生publicKey，然后使用keccak256哈希publicKey得到地址。</p>
<p>具体实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> privateKeyBuffer = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(privateKey);</span><br><span class="line"><span class="keyword">let</span> publicKey = secp256k1.<span class="title function_">publicKeyCreate</span>(privateKeyBuffer, <span class="literal">false</span>).<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> address = <span class="string">&quot;0x&quot;</span> + <span class="title function_">keccak256</span>(publicKey).<span class="title function_">slice</span>(-<span class="number">20</span>).<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>keccak256(publicKey) 产生了32bytes，截取尾部20bytes转换成十六进制之后就是40字符，加上前导0x之后，就是42个字符的以太坊地址，比如：<em>0x0f645438395206b408e52be4fcf4bc21c330bfa2</em></p>
<h3 id="从keyObject对象中恢复私钥"><a href="#从keyObject对象中恢复私钥" class="headerlink" title="从keyObject对象中恢复私钥"></a>从keyObject对象中恢复私钥</h3><p>有了keyObject和密码就可以恢复原来的私钥</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> privateKey = keythereum.<span class="title function_">recover</span>(password, keyObject)</span><br></pre></td></tr></table></figure>
<p>可以想到，recover方法中，首先会利用password和keyObject中的salt派生出当初的密钥derivedKey，然后把加密过的私钥ciphertext和derivedKey, iv作为原来加密算法aes-128-ctr的输入参数，成功解密后返回明文的私钥。</p>
<p>具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">verifyAndDecrypt</span>(<span class="variable language_">this</span>.<span class="title function_">deriveKey</span>(password, salt, keyObjectCrypto), salt, iv, ciphertext, algo)</span><br></pre></td></tr></table></figure>
<p>这里首先得到了derivedKey，然后验证并解密kyeObject中的ciphertext，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">verifyAndDecrypt</span>(<span class="params">derivedKey, salt, iv, ciphertext, algo</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> key;</span><br><span class="line">  <span class="keyword">if</span> (self.<span class="title function_">getMAC</span>(derivedKey, ciphertext) !== keyObjectCrypto.<span class="property">mac</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;message authentication code mismatch&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (keyObject.<span class="property">version</span> === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">    key = <span class="title function_">keccak256</span>(derivedKey.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">16</span>)).<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    key = derivedKey.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self.<span class="title function_">decrypt</span>(ciphertext, key, iv, algo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的mac值比较，确保了ciphertext没有被人篡改才有解密的必要。</p>
<h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><ol>
<li><a href="https://github.com/cryptocoinjs/secp256k1-node">NodeJS</a></li>
<li><a href="https://github.com/bitcoin-core/secp256k1">Bitcoin-core</a><br>[^1]: <a href="https://github.com/ethereumjs/keythereum">Keythereum</a></li>
</ol>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>digital-wallet</tag>
      </tags>
  </entry>
  <entry>
    <title>创建数字钱包（三）助记词</title>
    <url>/2019/01/24/Digital-wallet-3-mnemonic-sentence/</url>
    <content><![CDATA[<h2 id="BIP39解释"><a href="#BIP39解释" class="headerlink" title="BIP39解释"></a>BIP39解释</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>BIP39<a href="%5BBIP39%5D(https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)">^1</a>定义了一种将计算机产生的随机数翻译成人类可读的方式，初衷很简单：结合BIP32<a href="%5BBIP32%5D(https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)">^2</a>，辅助人类记忆产生主密钥的种子。</p>
<h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><ol>
<li>initial entropy (ENT)</li>
<li>check sum (CS)</li>
<li>mnemonic sentence (MS)</li>
<li>wordlists</li>
</ol>
<p>这三者的长度关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CS = ENT/32</span><br><span class="line">MS = (ENT + CS)/11 化简成 MS = 3 * CS</span><br></pre></td></tr></table></figure>
<p>举个例子，如果初始熵长度为 128，ENT&#x2F;CS&#x2F;MS组成的关系表格填充如下：</p>
<table>
<thead>
<tr>
<th align="center">ENT</th>
<th align="center">CS</th>
<th align="center">MS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">128</td>
<td align="center">4</td>
<td align="center">12</td>
</tr>
</tbody></table>
<h4 id="初始熵-initial-entropy"><a href="#初始熵-initial-entropy" class="headerlink" title="初始熵 initial entropy"></a>初始熵 initial entropy</h4><p>初始熵可以通过随机数生成器生成，允许的大小在 128-256 bits 范围之内。</p>
<h4 id="校验码-check-sum"><a href="#校验码-check-sum" class="headerlink" title="校验码 check sum"></a>校验码 check sum</h4><p>校验码利用初始熵经过哈希得出，而且长度必须是$ENT&#x2F;32$。</p>
<h4 id="助记词-mnemonic-sentence"><a href="#助记词-mnemonic-sentence" class="headerlink" title="助记词 mnemonic sentence"></a>助记词 mnemonic sentence</h4><p>助记词需要将初始熵和校验码拼接，然后切分成每11位为一组，每一组二进制数转换成十进制数作为索引wordlists的下标，以便提取对应的词汇。以128位的ENT为例，它最终会产生12个词汇。</p>
<h4 id="词汇表-wordlists"><a href="#词汇表-wordlists" class="headerlink" title="词汇表 wordlists"></a>词汇表 wordlists</h4><p>词汇表的构成是有原则可遵守的，其一，词汇之间可辨识性强，英文的词汇在前4个词汇就能有很快速的区分；其二，避免相似的词语，人毕竟是健忘的；其三，词汇应该排过序，便于二分查找。</p>
<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><p>下面利用Nodejs版本的BIP39<a href="%5BNodeJS-BIP39%5D(https://github.com/bitcoinjs/bip39)">^3</a>解释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">generateMnemonic</span> (strength, rng, wordlist) &#123;</span><br><span class="line">  strength = strength || <span class="number">128</span></span><br><span class="line">  <span class="keyword">if</span> (strength % <span class="number">32</span> !== <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="variable constant_">INVALID_ENTROPY</span>)</span><br><span class="line">  rng = rng || randomBytes</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">entropyToMnemonic</span>(<span class="title function_">rng</span>(strength / <span class="number">8</span>), wordlist)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>generateMnemonic(...)</code>函数的参数rng全称是random number generator，即随机数发生器，默认是randomBytes。此处，ENT的默认长度是128位，运行<code>randomBytes(128/8)</code>将产生了16字节的随机数。然后调用<code>entropyToMnemonic(...)</code>函数生成助记词。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">entropyToMnemonic</span> (entropy, wordlist) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Buffer</span>.<span class="title function_">isBuffer</span>(entropy)) entropy = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(entropy, <span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">  wordlist = wordlist || <span class="variable constant_">DEFAULT_WORDLIST</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 128 &lt;= ENT &lt;= 256</span></span><br><span class="line">  <span class="keyword">if</span> (entropy.<span class="property">length</span> &lt; <span class="number">16</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="variable constant_">INVALID_ENTROPY</span>)</span><br><span class="line">  <span class="keyword">if</span> (entropy.<span class="property">length</span> &gt; <span class="number">32</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="variable constant_">INVALID_ENTROPY</span>)</span><br><span class="line">  <span class="keyword">if</span> (entropy.<span class="property">length</span> % <span class="number">4</span> !== <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="variable constant_">INVALID_ENTROPY</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> entropyBits = <span class="title function_">bytesToBinary</span>([].<span class="property">slice</span>.<span class="title function_">call</span>(entropy))</span><br><span class="line">  <span class="keyword">var</span> checksumBits = <span class="title function_">deriveChecksumBits</span>(entropy)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> bits = entropyBits + checksumBits</span><br><span class="line">  <span class="keyword">var</span> chunks = bits.<span class="title function_">match</span>(<span class="regexp">/(.&#123;1,11&#125;)/g</span>)</span><br><span class="line">  <span class="keyword">var</span> words = chunks.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">binary</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="title function_">binaryToByte</span>(binary)</span><br><span class="line">    <span class="keyword">return</span> wordlist[index]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wordlist === <span class="variable constant_">JAPANESE_WORDLIST</span> ? words.<span class="title function_">join</span>(<span class="string">&#x27;\u3000&#x27;</span>) : words.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>entropyBits是entropy的二进制表示；checksumBits是entropy经由SHA256计算得到的哈希值再截断到CS的长度得来的，调用<code>deriveChecksumBits(...)</code>函数产生checksumBits的逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deriveChecksumBits</span> (entropyBuffer) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">ENT</span> = entropyBuffer.<span class="property">length</span> * <span class="number">8</span></span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">CS</span> = <span class="variable constant_">ENT</span> / <span class="number">32</span></span><br><span class="line">  <span class="keyword">var</span> hash = <span class="title function_">createHash</span>(<span class="string">&#x27;sha256&#x27;</span>).<span class="title function_">update</span>(entropyBuffer).<span class="title function_">digest</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">bytesToBinary</span>([].<span class="property">slice</span>.<span class="title function_">call</span>(hash)).<span class="title function_">slice</span>(<span class="number">0</span>, <span class="variable constant_">CS</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的计算和前面长度关系规则完全吻合，checksumBits通过<code>slice(0, CS)</code>截断得到4位的二进制数。</p>
<p>计算得到entropyBits和checksumBits之后，把它们拼接到一起，得到一组bits，然后按每组11bits分隔，这里使用了正则表达式 <code>bits.match(/(.&#123;1,11&#125;)/g)</code>，正则表达式<code>(.&#123;1,11&#125;)</code>表示对任意1-11个bit进行分组，由于正则默认是最长匹配，所以每11位就被分成了一组。最终，每组二进制数都会被转成十进制数，进而作为词汇表的下标索引对应的词汇，详细见上文的<code>chunks.map(function (binary) ...</code> 过程。</p>
<h3 id="中文词汇表"><a href="#中文词汇表" class="headerlink" title="中文词汇表"></a>中文词汇表</h3><p>BIP39其实并没有定义词汇表，所以不同的自然语言都可以自行实现自己的词汇表。NodeJS版本的BIP39<a href="%5BNodeJS-BIP39%5D(https://github.com/bitcoinjs/bip39)">^3</a>就支持中文的词汇表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mnemonic = bip39.<span class="title function_">generateMnemonic</span>(<span class="number">160</span>, <span class="literal">null</span>, bip39.<span class="property">wordlists</span>.<span class="property">chinese_simplified</span>)</span><br><span class="line">-&gt;</span><br><span class="line"><span class="string">&#x27;定 过 丘 搭 斥 紫 遍 官 寿 穿 贯 别 讯 卵 符&#x27;</span></span><br></pre></td></tr></table></figure>
<p>除了中文的词汇表，它还支持下列词汇，如：繁体中文等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">wordlists</span>: &#123;</span><br><span class="line">    <span class="attr">EN</span>: string[];</span><br><span class="line">    <span class="attr">JA</span>: string[];</span><br><span class="line">    <span class="attr">chinese_simplified</span>: string[];</span><br><span class="line">    <span class="attr">chinese_traditional</span>: string[];</span><br><span class="line">    <span class="attr">english</span>: string[];</span><br><span class="line">    <span class="attr">french</span>: string[];</span><br><span class="line">    <span class="attr">italian</span>: string[];</span><br><span class="line">    <span class="attr">japanese</span>: string[];</span><br><span class="line">    <span class="attr">spanish</span>: string[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="生成BIP32种子"><a href="#生成BIP32种子" class="headerlink" title="生成BIP32种子"></a>生成BIP32种子</h3><p>拿到助记词之后，就可以从助记词生成种子。这里其实使用了pbkdf2算法，不过有趣的是，参数mnemonic反而是pdkdf2算法中的password参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mnemonicToSeed (mnemonic, password) &#123;</span><br><span class="line">  var mnemonicBuffer = Buffer.from(unorm.nfkd(mnemonic), &#x27;utf8&#x27;)</span><br><span class="line">  var saltBuffer = Buffer.from(salt(unorm.nfkd(password)), &#x27;utf8&#x27;)</span><br><span class="line"></span><br><span class="line">  return pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, &#x27;sha512&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>digital-wallet</tag>
      </tags>
  </entry>
  <entry>
    <title>创建数字钱包（二）HD Wallet</title>
    <url>/2019/01/24/Digital-wallet-2-hd-wallet/</url>
    <content><![CDATA[<p>BIP 全称是 Bitcoin Improvement Proposals，相当于互联网中RFC (Request for Comments)，它是用来记录草案或者标准的。</p>
<h2 id="BIP32解释"><a href="#BIP32解释" class="headerlink" title="BIP32解释"></a>BIP32解释</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>BIP32定义了Hierarchical deterministic wallets (HD Wallets)，HD指出了这类钱包的两大特征。</p>
<p>第一点特征是层级结构，钱包一般会存储一组key-pair对，这组key-pair对是链状存储，但是HD钱包是树状存储，也就是说它的结构中有根节点，根节点会派生出子节点，子节点又可以派生出子节点。这样做的优势是它可以有选择的把某个层级的一组key-pair对分配出去，这样就可以和组织结构匹配，比如：总部保留根密钥，其它分部用总部派生的密钥；也可以和用途匹配，比如：花钱的和收钱的地址可以分开。</p>
<p>第二点特征是确定性，因为所有的key-pair对都是从同一个根派生出来的，所以只要妥善保管好根（主密钥）就可以在其它的系统中快速地恢复钱包。</p>
<p>层级结构和确定性如下图示：<br><img src="https://upload-images.jianshu.io/upload_images/217988-02f038826fdc3e69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HD Wallets"></p>
<h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><ol>
<li>Master key</li>
<li>Chain Code</li>
<li>Extended key</li>
</ol>
<h4 id="主密钥及其生成"><a href="#主密钥及其生成" class="headerlink" title="主密钥及其生成"></a>主密钥及其生成</h4><p>主密钥是从一串长度在128到256位的比特序列（种子）中生成的，然后使用HMAC-SHA512计算出64字节序列（称为I），左边32字节（称为IL）作为主私钥，右边32字节（称为IR）作为主Chain Code。</p>
<p>大致步骤如下：</p>
<ol>
<li>生成熵为128 - 256bit 的种子</li>
<li>I &#x3D; HMAC-SHA512(key&#x3D;”Bitcoin seed”, data &#x3D; seed)</li>
<li>&lt;&lt;IL :: bytes(32), LR :: bytes(32) &gt;&gt; &#x3D; I</li>
<li>MasterSecretKey &#x3D; IL &amp; MasterChainCode &#x3D; IR</li>
</ol>
<p>这里有个问题值得探讨，这样生成的 MasterSecretKey 是符合 secp256k1 定义的利用ECDSA算法生成的私钥吗？我们可以利用secp256k1.privateKeyVerify(…)方法验证，结果是正确的。</p>
<h4 id="额外的熵-Chain-Code"><a href="#额外的熵-Chain-Code" class="headerlink" title="额外的熵 Chain Code"></a>额外的熵 Chain Code</h4><p>因为每个父密钥都可以派生出很多子密钥，所以为了避免子密钥直接依赖父密钥，需要引入额外的熵（chain code）去增强父密钥，这个额外的熵，或者说，随机的256位的比特序列就是 Chain Code。</p>
<h4 id="扩展密钥-Extended-Key"><a href="#扩展密钥-Extended-Key" class="headerlink" title="扩展密钥 Extended Key"></a>扩展密钥 Extended Key</h4><p>根据定义，父密钥和Chain Code的组合 (k, c) 就是扩展私钥，而扩展公钥则是 (K, c)，其中的 K 是通过 secp256k1 计算私钥 k 得到的。</p>
<p>Extended Key 在序列化的地方也值得关注，具体的规则，可以细读BIP32。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// publicKey</span><br><span class="line">03795fd38bbffdddb24b72af417cf3fa540db8f60783dd32f61f0ca5af464fd492</span><br><span class="line">// ExtendedPublicKey</span><br><span class="line">xpub6GmbjntbdLF4JNhBxwoRBrdw2BBujvJ514tRHFMQaoFA5eSRaWwr6CQSGq1HtirLGSTT8SHqMGWQk4rbZLJsVFA4NLZZYUR25ZEdhnGJ7R1</span><br></pre></td></tr></table></figure>
<p>序列化之后的publicKey的首部4比特是版本号，比如此处的xpub就是mainnet的意思。</p>
<p>每个扩展密钥都有$2^{31}$个普通子密钥和$2^{31}$个Hardened子密钥，一般会用i+$2^{31}$表示Hardened子密钥，记为$I_H$。</p>
<h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>这里，我们使用hdkey[^1]进行代码解释。</p>
<h4 id="主密钥及其生成-1"><a href="#主密钥及其生成-1" class="headerlink" title="主密钥及其生成"></a>主密钥及其生成</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">MASTER_SECRET</span> = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;Bitcoin seed&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">HDKey</span>.<span class="property">fromMasterSeed</span> = <span class="keyword">function</span> (<span class="params">seedBuffer, versions</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> I = crypto.<span class="title function_">createHmac</span>(<span class="string">&#x27;sha512&#x27;</span>, <span class="variable constant_">MASTER_SECRET</span>).<span class="title function_">update</span>(seedBuffer).<span class="title function_">digest</span>()</span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">IL</span> = I.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">IR</span> = I.<span class="title function_">slice</span>(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> hdkey = <span class="keyword">new</span> <span class="title class_">HDKey</span>(versions)</span><br><span class="line">  hdkey.<span class="property">chainCode</span> = <span class="variable constant_">IR</span></span><br><span class="line">  hdkey.<span class="property">privateKey</span> = <span class="variable constant_">IL</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hdkey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>seedBuffer是128-256bit的随机序列作为种子，然后利用HMAC-SHA512生成I值，分割出的IL和IR分别赋值给privateKey和chainCode。</p>
<h4 id="Chain-code"><a href="#Chain-code" class="headerlink" title="Chain code"></a>Chain code</h4><p>Chain code 会在派生子密钥的时候起作用，derive(path) -&gt; deriveChild(index) 是派生子密钥的过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>([<span class="variable language_">this</span>.<span class="property">publicKey</span>, indexBuffer])</span><br><span class="line"><span class="keyword">var</span> I = crypto.<span class="title function_">createHmac</span>(<span class="string">&#x27;sha512&#x27;</span>, <span class="variable language_">this</span>.<span class="property">chainCode</span>).<span class="title function_">update</span>(data).<span class="title function_">digest</span>()</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IL</span> = I.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IR</span> = I.<span class="title function_">slice</span>(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hd = <span class="keyword">new</span> <span class="title class_">HDKey</span>(<span class="variable language_">this</span>.<span class="property">versions</span>)</span><br><span class="line"><span class="comment">// Private parent key -&gt; private child key</span></span><br><span class="line"><span class="comment">// ki = parse256(IL) + kpar (mod n)</span></span><br><span class="line">hd.<span class="property">privateKey</span> = secp256k1.<span class="title function_">privateKeyTweakAdd</span>(<span class="variable language_">this</span>.<span class="property">privateKey</span>, <span class="variable constant_">IL</span>)</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看到，chainCode用来作为HMAC-SHA512的密钥对data进行了哈希处理。最终子密钥privateKey通过secp256k1.privateKeyTweakAdd(…)生成，这个函数来自secp256k1[^2]库，主要功能是拼接，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">privateKeyTweakAdd</span> = <span class="keyword">function</span> (<span class="params">privateKey, tweak</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> bn = <span class="variable constant_">BN</span>.<span class="title function_">fromBuffer</span>(tweak)</span><br><span class="line">  <span class="keyword">if</span> (bn.<span class="title function_">isOverflow</span>()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(messages.<span class="property">EC_PRIVATE_KEY_TWEAK_ADD_FAIL</span>)</span><br><span class="line"></span><br><span class="line">  bn.<span class="title function_">iadd</span>(<span class="variable constant_">BN</span>.<span class="title function_">fromBuffer</span>(privateKey))</span><br><span class="line">  <span class="keyword">if</span> (bn.<span class="title function_">isOverflow</span>()) bn.<span class="title function_">isub</span>(<span class="variable constant_">BN</span>.<span class="property">n</span>)</span><br><span class="line">  <span class="keyword">if</span> (bn.<span class="title function_">isZero</span>()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(messages.<span class="property">EC_PRIVATE_KEY_TWEAK_ADD_FAIL</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bn.<span class="title function_">toBuffer</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，在derive(path)函数中，我们会看到Hardened判断的条件是是否带有单引号，例如：<code>44&#39;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var hardened = (c.length &gt; 1) &amp;&amp; (c[c.length - 1] === &quot;&#x27;&quot;)</span><br><span class="line">var childIndex = parseInt(c, 10) // &amp; (HARDENED_OFFSET - 1)</span><br><span class="line">assert(childIndex &lt; HARDENED_OFFSET, &#x27;Invalid index&#x27;)</span><br><span class="line">if (hardened) childIndex += HARDENED_OFFSET</span><br><span class="line"></span><br><span class="line">hdkey = hdkey.deriveChild(childIndex)</span><br></pre></td></tr></table></figure>
<p>在后续介绍BIP44的过程中，我们会明白这样处理的含义，Path为<code>m/44&#39;/60&#39;/0&#39;/0/0</code>在BIP44中有特定的含义，这种表示法和BIP32的结合点就在这里。</p>
<h3 id="Extended-key"><a href="#Extended-key" class="headerlink" title="Extended key"></a>Extended key</h3><p>Extended key 可以分为 privateExtendedKey 和 publicExtendedKey，这里以 privateExtendedKey 为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cs.<span class="title function_">encode</span>(<span class="title function_">serialize</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">versions</span>.<span class="property">private</span>, <span class="title class_">Buffer</span>.<span class="title function_">concat</span>([<span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="variable language_">this</span>.<span class="property">privateKey</span>])))</span><br></pre></td></tr></table></figure>
<p>其中versionls.private，默认值是0x0488ADE4，encode操作可以忽略，具体的序列化逻辑发生在serialize中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">serialize</span> (hdkey, version, key) &#123;</span><br><span class="line">  <span class="comment">// =&gt; version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)</span></span><br><span class="line">  <span class="keyword">var</span> buffer = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="variable constant_">LEN</span>)</span><br><span class="line"></span><br><span class="line">  buffer.<span class="title function_">writeUInt32BE</span>(version, <span class="number">0</span>)</span><br><span class="line">  buffer.<span class="title function_">writeUInt8</span>(hdkey.<span class="property">depth</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fingerprint = hdkey.<span class="property">depth</span> ? hdkey.<span class="property">parentFingerprint</span> : <span class="number">0x00000000</span></span><br><span class="line">  buffer.<span class="title function_">writeUInt32BE</span>(fingerprint, <span class="number">5</span>)</span><br><span class="line">  buffer.<span class="title function_">writeUInt32BE</span>(hdkey.<span class="property">index</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">  hdkey.<span class="property">chainCode</span>.<span class="title function_">copy</span>(buffer, <span class="number">13</span>)</span><br><span class="line">  key.<span class="title function_">copy</span>(buffer, <span class="number">45</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量<code>LEN</code>为78，这就是序列化的结构大小。需要注意的点是，按照定义这里的字节序都是大端（Big Endian，也成为网络字节序）。</p>
<h2 id="BIP44解释"><a href="#BIP44解释" class="headerlink" title="BIP44解释"></a>BIP44解释</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>BIP44 定义了逻辑上的层级结构，所谓逻辑，就是人为赋予意义。BIP44综合了BIP32的HD Wallet设计和BIP43[^3]的Purpose约定，使得HD Wallet能够表达多币种，多账号，账号的外部或内部key-pair对构成的组，外部指的是地址对外可见，专门用来接收或发送数字货币的地址；而内部则是对外不可见，多用来表达找零 (change) 的概念。</p>
<h3 id="主要概念-1"><a href="#主要概念-1" class="headerlink" title="主要概念"></a>主要概念</h3><p>BIP44在BIP32的路径中定义了5个层级：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m / purpose&#x27; / coin_type&#x27; / account&#x27; / change / address_index</span><br></pre></td></tr></table></figure>
<ul>
<li>Purpose: <code>44&#39;</code>or 0x8000002C 这表明后面的子密钥都遵从BIP44的约定</li>
<li>Coin type: <code>0&#39;</code> 代表比特币，<code>60&#39;</code> 代表以太币</li>
<li>Account: 代表不同的用户身份，比如：储蓄或者收款账户，以及各种开支账户</li>
<li>Change: 0 表示外部key-pair组；1 代表内部key-pair组，比如专门用来找零的地址</li>
<li>Address_index: 根据BIP32，地址会生成多个，可以从0开始索引</li>
</ul>
<p>Purpose, Coin type以及Account都有单引号，意味着它们都是Hardened密钥，而Change和Address_index则是Normal的密钥。这样做是为了安全，BIP32中提到了一个事实，如果知道了父级的ExtendedPublicKey及其派生出来的Non-hardened private key，就等于知道了父级的ExtendedPrivateKey，这就是Hardened密钥存在的理由。引文如下：</p>
<blockquote>
<p>One weakness that may not be immediately obvious, is that knowledge of a parent extended public key plus any non-hardened private key descending from it is equivalent to knowing the parent extended private key (and thus every private and public key descending from it). This means that extended public keys must be treated more carefully than regular public keys. It is also the reason for the existence of hardened keys, and why they are used for the account level in the tree. This way, a leak of account-specific (or below) private key never risks compromising the master or other accounts.</p>
</blockquote>
<h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><p>继续使用hdkey[^1]来解释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let hdWallet = hdkey.fromMasterSeed(seed)</span><br><span class="line">let key = hdWallet.derivePath(&quot;m/44&#x27;/60&#x27;/0&#x27;/0/0&quot;)</span><br><span class="line">console.log(&quot;publicKey:&quot;, key1._hdkey._publicKey.toString(&quot;hex&quot;), &quot;\nextendPublicKey:&quot;, key1.publicExtendedKey())</span><br><span class="line">-&gt;</span><br><span class="line">publicKey: 03795fd38bbffdddb24b72af417cf3fa540db8f60783dd32f61f0ca5af464fd492 </span><br><span class="line">extendPublicKey: xpub6GmbjntbdLF4JNhBxwoRBrdw2BBujvJ514tRHFMQaoFA5eSRaWwr6CQSGq1HtirLGSTT8SHqMGWQk4rbZLJsVFA4NLZZYUR25ZEdhnGJ7R1</span><br></pre></td></tr></table></figure>
<p>依据前面提到的定义，通过路径<code>m/44&#39;/60&#39;/0&#39;/0/0</code>派生出了以太坊某个外部账户下的第一个地址。</p>
<p>[^1]: <a href="https://github.com/cryptocoinjs/hdkey">NodeJS - hdkey</a></p>
<p>[^2]: <a href="https://github.com/cryptocoinjs/secp256k1-node">NodeJS - secp256k1</a></p>
<p>[^3]: <a href="https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki">BIP43 - Purpose scheme</a></p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>digital-wallet</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 入门（Rust rocks）</title>
    <url>/2019/09/23/Rust-rocks/</url>
    <content><![CDATA[<ul>
<li>缘起</li>
<li>实践出真知<ul>
<li>快速获取</li>
<li>澄清概念<ul>
<li>Ownership</li>
<li>Move</li>
<li>Reference</li>
<li>Mutable reference</li>
</ul>
</li>
<li>解释错误</li>
<li>数据竞态条件</li>
<li>构建树状结构</li>
<li>渲染树状结构</li>
</ul>
</li>
<li>总结</li>
<li><a href="https://github.com/qianyan/tree/blob/master/tree.rs">源码 Github</a></li>
</ul>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>做区块链的基本几乎没有人不知道 Rust 这门编程语言，它非常受区块链底层开发人员的青睐。说来也奇怪，Rust 起源于 Mazilla，唯一大规模应用就是 Firefox，作为小众语言却在区块链圈子里火了。这其中应该和以太坊的发起人 Govin Wood 创建的 Parity 项目有关，Parity 是一款用 Rust 编写的以太坊客户端。</p>
<p>最初接触 Rust 的时间大概是 2015 年，当年有同事发了一封“是否对 Rust 编程语言感兴趣的”的邮件。当时年少<del>不懂事</del>热血，觉得这门语言因为它小众很酷，所以特别适合拿来练功，所以就激情地回应了邮件，结果之后就没有了下文，想必那位同事也因为响应的人数太少而兴致缺缺。</p>
<p>第二次关注 Rust 是因为陈天在自己的公众号中提到了这门语言。我比较欣赏陈天，当初学习 Elixir 也是受他影响，所以也跟着他的步伐去听了张汉东的知乎Live，然后加入了他的读者群（魅力Rust），在这个群中潜水了大半年，一直很惊叹这个群的活跃度。</p>
<p>2019年，区块链圈中的一次大事件是 Facebook 要发非主权货币 Libra，随之而来是基于 Rust 之上的 Move 编程语言。这个 Move 说白了就是 Move 的一种 DSL，用比较学术的话说是指称（denotational）语义，用简单的编译器把 Move 的语法翻译成 Rust 的语法然后借助 Rust 的编译器生成二进制码。这个过程没有什么惊喜，不过 Move 语言显然是借鉴了 Rust 中移交（Move）主权（Ownership）的概念，它表征了这样一种事实——数字资产只能有一个主人，一旦移动，就会发生主权转移，以前的主人就丧失了该主权。这种想法和 Rust 中主权管理非常契合，所以不难理解为什么 Libra 的开发团队把名字也照搬过来了。当然，Libra 的底层区块链也用的是 Rust。这个大事件加上以太坊 Parity 的珠玉在前，对于程序员这群天生喜欢新鲜事物的人类而言，学习 Rust 的热情必然水涨船高。</p>
<p>大概就是在这种契机下，我开始学习 Rust 的。依照老规矩，我还是会从 tree 这个命令行程序入手，在试错中逐步学习 Rust 这门语言。包含它的基本数据类型，组合数据类型，控制流，模块（函数）以及文件和集合操作，还有最关键的 Ownership 的应用。</p>
<h2 id="实践出真知"><a href="#实践出真知" class="headerlink" title="实践出真知"></a>实践出真知</h2><p>学习 Rust 最深刻的体验莫过于和编译器较劲，这也是我听到过最多的抱怨。我想许多新手看到这么多警告或者错误，嘴上不说，心里应该很不是滋味。但是这也是 Rust 引以为豪的设计哲学，每一门新进的语言都有自己的本质原因（Rationale）或者设计哲学，比如 Lisp 家族的 Clojure 就有 <em>Elegance and familiarity are orthogonal</em> 的玄言妙语；往远古追溯，Java 的 <em>Write Once, Run Anywhere</em> 豪言壮语；而 Rust 的基本设计哲学是 <em>If it compiles, then it works</em>，这个条件有多苛刻我们稍微想一想就能知道——动态弱类型语言向静态强类型语言的逐步趋同态势，基本已经宣告了类型系统的胜利，但即便如此，现代软件工程也还是处处强调程序员要手写各种测试确保代码运行时的正确性——从单元测试到集成测试，从冒烟测试到回归测试，从 Profiling 到性能测试。这些测试方法和工具已经深入到软件工程的方方面面，然而各类软件还是漏洞百出。Rust 发出这种高调宣言，不免有夜郎自大之嫌疑。不过程序届是个能造概念也能落地概念的神奇圈子，高调的牛吹着吹着也就实现了。况且，Rust 充分诠释了现代编程语言的核心思想——约束程序员，不是劝劝你的意思，是憋死你的意思。</p>
<p>我在<a href="/2018/07/18/the-joy-of-learning-new-programming-language/">《我是如何学习新的编程语言》</a>中说过学习的最好方式是有目的地试错，我时常拿来练手的程序叫<em>tree - list contents of directories in a tree-like format.</em> 这段程序需要用到的 Rust 基本构件有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基础概念</span><br><span class="line">1. 变量 - let</span><br><span class="line">2. ownership borrow - &amp;</span><br><span class="line">3. 可变性 - mut</span><br><span class="line">4. 可变引用 - &amp;mut</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复合数据类型</span><br><span class="line">1. String - String::from(&quot;&quot;) // 非基本类型</span><br><span class="line">2. Slice - &quot;&quot; or vec[..]</span><br><span class="line">2. struct - struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">集合及其操作</span><br><span class="line">1. Vec&lt;_&gt; - Vec::new() // 考虑到集合需要自动扩展</span><br><span class="line">2. iter()</span><br><span class="line">3. .map()</span><br><span class="line">4. .enumerate()</span><br><span class="line">5. .flatten()</span><br><span class="line">6. .collect()</span><br><span class="line">7. .extend() //集合拼接</span><br><span class="line"></span><br><span class="line">控制语句</span><br><span class="line">1. if Expressions - if &#123;&#125; else &#123;&#125;</span><br><span class="line">2. recursions</span><br><span class="line"></span><br><span class="line">模块</span><br><span class="line">1. fn - fn x(s: String) -&gt; Vec&lt;String&gt;</span><br><span class="line"></span><br><span class="line">功能组件</span><br><span class="line">1. Path</span><br><span class="line">2. fs</span><br><span class="line">3. env</span><br></pre></td></tr></table></figure>
<p>当尝试寻找这些元素时，我发现 Rust 或者诸如此类的编译型语言都有一个让人不舒服的地方——验证的前置步骤耗时太长。因为没有<em>repl</em>，所以想去了解一些概念的使用方法，就不得不另外创建一个项目（我可不想污染当前项目的代码），在它的 main 函数里编写试验程序，这比起具有快速反馈能力的<em>repl</em>，着实太慢了。不过这里的慢也是相对的，Rust 也有一个显著的优势，在出现编译错误时，编译器不仅能向你解释原因，还能推荐潜在的修改方式，这就比 Javascript 一类的动态语言要清晰和高明得多。再利用内置的 <code>assert_eq!</code> 等断言函数预判结果，又比单独写测试省事。所以，总体而言，学习的过程还是很愉悦的。</p>
<h3 id="快速获取"><a href="#快速获取" class="headerlink" title="快速获取"></a>快速获取</h3><p>这里举个例子，为了解如何拼接两个集合时，需要事先搞明白几个问题：</p>
<ol>
<li>集合的构造？</li>
<li>集合的拼接？</li>
<li>结果的断言？</li>
</ol>
<p>在没有<em>repl</em>的条件下，唯一快速上手的工具就是文档，在 <a href="https://doc.rust-lang.org/std/">https://doc.rust-lang.org/std/</a> 的官方标准库中，可以搜到<code>Struct std::vec::Vec</code>的<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">详细解释</a>。</p>
<p>通过例子程序，可以很快知道集合的构造方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mut v = vec![1, 2, 3];</span><br><span class="line">v.reverse();</span><br><span class="line">assert_eq!(v, [3, 2, 1]);</span><br></pre></td></tr></table></figure>
<p><code>vec!</code> 宏可以快速构造出一个集合来，顺便试验下它的<code>reverse</code>方法。那么集合如何拼接呢？为了解答这个问题，我一般会用搜索引擎，或者深入文档，查找如 <code>concat</code>，<code>append</code>等关键字，每每总有收获。</p>
<p>在不考虑非功能需求的前提下，我们先用最直接的方式实现，例如：文档中给出的样例<code>extend</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let v = vec![1, 2, 3];</span><br><span class="line">v.extend([1, 2, 3].iter().cloned()); // 编译错误</span><br></pre></td></tr></table></figure>
<p>注意，这里编译失败。Rust 编译器会直截了当地给出错误信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error[E0596]: cannot borrow `v` as mutable, as it is not declared as mutable</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/main.rs:13:5</span></span><br><span class="line">   |</span><br><span class="line">12 |     let v = vec![1, 2, 3];</span><br><span class="line">   |         - help: consider changing this to be mutable: `mut v`</span><br><span class="line">13 |     v.extend([1, 2, 3].iter().cloned());</span><br><span class="line">   |     ^ cannot borrow as mutable</span><br></pre></td></tr></table></figure>
<p>错误信息中透露出我们的程序在尝试借用（borrow）一个不可变的变量。<em>borrow</em>和 <em>mutable</em>都是新的概念。对于新的概念，我们会习惯地用熟知的知识去类比。如果套用函数式编程中不可变的特性，大体可以猜到 Rust 中的变量默认是不可变的。但是 <em>cannot borrow as mutable</em> 中 <em>borrow</em> 确实是有点超出认知范围。那么此时弄清定义是非常有必要的。</p>
<h3 id="澄清概念"><a href="#澄清概念" class="headerlink" title="澄清概念"></a>澄清概念</h3><p><strong>学习语言的过程中最需要注意的事项就是澄清概念</strong>。当遇到崭新的概念时，我们得停下先去补充这部分的知识，然后再回过头来理解和解决实际遇到的问题。因为每一门编程语言都有本门派的哲学原理，它本身就萃取了多种理论和实践的成果，所以必须学习这些概念。学习的过程其实就是逐步澄清概念的过程。</p>
<p>在学习（尝试定义）<em>borrow</em> 的过程中，我又先后接触到了 <em>ownership</em>, <em>move</em>, <em>reference</em>, <em>mutable reference</em> 等概念。所以我定义了这些概念：</p>
<h4 id="Ownership"><a href="#Ownership" class="headerlink" title="Ownership"></a>Ownership</h4><p>变量拥有它指称的值的所有权。<br>在 Rust 当中，变量拥有它指称的值，即变量（variable）是它指称值（value）的主人（owner），值一次只能有一个主人，一旦主人离开作用域它的值就会被销毁。</p>
<h4 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h4><p>把一个变量的值重新赋值给另一个变量的行为。<br>根据 Ownership 的定义，值一次只能有一个主人，所以此时该值的所有权会被<strong>转移</strong>给另一个变量，原来的变量就丧失了对这个值的所有权，导致的直接影响就是这个变量此后不再可用。</p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>一个变量指向（refer to）值而非拥有该值的所有权的状态。<br>在很多赋值的场景，包括变量赋值或者函数参数赋值，我们并不希望之后原来的变量不再可用，此时可以通过<code>&amp;</code>(ampersands创建一个指向值的引用，将引用进行赋值时不会发生 <em>Move</em>，所以原来的变量依旧可用。这种赋值行为被称为<em>borrow</em>（借用）。结合实际，我们拥有的物品可以出借给别人，别人享有该物品的使用权（Possession），而非所有权（Ownership）。</p>
<h4 id="Mutable-reference"><a href="#Mutable-reference" class="headerlink" title="Mutable reference"></a>Mutable reference</h4><p>标识该引用的值是可变的。</p>
<p>很多场景下，我们希望引用传递的值是可以改变的。此时我们就必须通过<code>&amp;mut</code>标识该引用，否则不允许修改操作发生。值得注意的是，<code>&amp;mut</code>标识要求原来的变量也必须是<code>mut</code>的，这很好理解，可变的变量的引用也得可变。而且为了防止数据竞态条件的发生，在同一个作用域下，<code>&amp;mut</code>的引用只能有一个，因为一旦出现多个可变引用，就可能遭遇不可重复读风险（注意，Rust 保证这里没有并行修改的风险）。而且同一个值的<code>&amp;mut</code>和<code>&amp;</code>的引用不能共存，因为我们不希望一个只读<code>&amp;</code>的值同时还能被写<code>&amp;mut</code>，这样会导致歧义。</p>
<h3 id="解释错误"><a href="#解释错误" class="headerlink" title="解释错误"></a>解释错误</h3><p>澄清了必要概念以后，我们再来回顾上面的代码。先去看一下这个<code>extend</code>函数的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn extend&lt;I&gt;(&amp;mut self, iter: I)</span><br><span class="line">where</span><br><span class="line">    I: IntoIterator&lt;Item = T&gt;, </span><br><span class="line">Extends a collection with the contents of an iterator...</span><br></pre></td></tr></table></figure>
<p>原来<code>v.extend</code>只是一个语法糖，真正的方法调用会把<code>self</code>作为第一个参数传递到<code>extend(&amp;mut self, iter: I)</code>当中。可变引用作为函数参数赋值，那么自然原来的变量也必须声明成可变的。</p>
<p>所以我们照着它的指示修正如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mut v = vec![1, 2, 3]; // 加上一个mut修饰符</span><br><span class="line">v.extend([1, 2, 3].iter().cloned());</span><br></pre></td></tr></table></figure>
<p>这回编译器消停了，利用<code>assert_eq!</code>，我们来验证<code>extend</code>操作的正确性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assert_eq!(v, [1, 2, 3, 1, 2, 3]);</span><br></pre></td></tr></table></figure>
<p>另外，值得注意的是，Rust 和我们熟悉的函数式编程有些不同，集合的拼接不会产生一个新的集合，而是对原有的集合进行修改。一般情况下，我们都会警惕可能会出现数据的竞态条件——<strong>多个线程对该集合进行写入操作怎么办？</strong>带着这个问题，我们反思一下什么是数据的竞态条件。</p>
<h3 id="数据竞态条件"><a href="#数据竞态条件" class="headerlink" title="数据竞态条件"></a>数据竞态条件</h3><p>数据竞态条件发生的必要条件有：</p>
<ol>
<li>多个引用同时指向相同的数据；</li>
<li>至少有一个引用在写数据；</li>
<li>对于数据的访问没有同步机制。</li>
</ol>
<p><strong>考察1和2：</strong><br>假如此处有两个引用指向同一个集合，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mut v = vec![1, 2, 3];</span><br><span class="line">let r1 = &amp;mut v;</span><br><span class="line">let r2 = &amp;mut v;</span><br><span class="line">assert_eq!(r1, r2);</span><br></pre></td></tr></table></figure>
<p>编译器会立即给出编译错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error[E0499]: cannot borrow `v` as mutable more than once at a time</span><br><span class="line">--&gt; src/main.rs:13:10</span><br><span class="line">|</span><br><span class="line">12 | let r1 = &amp;mut v;</span><br><span class="line">|          ------ first mutable borrow occurs here</span><br><span class="line">13 | let r2 = &amp;mut v;</span><br><span class="line">|          ^^^^^^ second mutable borrow occurs here</span><br><span class="line">14 | assert_eq!(r1, r2);</span><br><span class="line">| ------------------- first borrow later used here</span><br></pre></td></tr></table></figure>
<p>也就是说，在指定的作用域下只能有一个可变引用。为什么要如此设计呢？在单线程下，这好像并不会出现数据竞争的问题<a href="https://www.reddit.com/r/rust/comments/95ky6u/why_arent_multiple_mutable_references_allowed_in/">^1</a>。不过考虑到下面这种场景的语义，我们思考一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mut v = vec![1, 2, 3];</span><br><span class="line">let r1 = &amp;mut v;</span><br><span class="line">let r2 = &amp;mut v;</span><br><span class="line">assert_eq!(r2[1], 2);</span><br><span class="line">*r1 = vec![0]</span><br><span class="line">assert_eq!(r2[1], 2); // 失效</span><br></pre></td></tr></table></figure>
<p>一旦允许r1改变数据，那对于r2而言，它先前持有的数据就已经发生改变甚至失效，再拿来使用就有问题了，在上面这个例子当中，<code>*r1</code>解除引用后被重新赋值，导致v的值随之改变，但是r2并不知情，依旧使用<code>r2[1]</code>导致此处越界。这个问题和数据库中事务的不可重复读（提交读）的隔离级别类似，但是在单线程下这并不能算作充分的理由，只是说在语义层面有细微的不自然，留待后续研究。</p>
<p>蹊跷的是，如果我将两个可变引用放到不同的函数中，同样的逻辑却可以绕过编译器错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = vec![1, 2, 3];</span><br><span class="line">    mut1(&amp;mut v);</span><br><span class="line">    mut2(&amp;mut v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn mut1(v: &amp;mut Vec&lt;i32&gt;) &#123;</span><br><span class="line">    *v = vec![0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn mut2(v: &amp;mut Vec&lt;i32&gt;) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, v[1]); // panicked at &#x27;index out of bounds&#x27; 运行时错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，上述的论述并没有解释清楚在单线程下同一个作用域下限制多个可变引用的根本原因。</p>
<p>对于<code>&amp;mut</code>和<code>&amp;</code>其实也可以做同样的解释。所以<code>&amp;mut</code>和<code>&amp;</code>在 Rust 同一个作用域中无法共存。</p>
<p><strong>考察3：</strong><br>至于在多线程的环境下，是否会出现数据竞态条件，我们得看 Rust 在线程使用方面的限制。在 Rust 的上下文里，使用<code>Thread::spawn</code>的线程时必须 <em>Move</em> 所有权<a href="http://squidarth.com/rc/rust/2018/06/04/rust-concurrency.html">^2</a>，因为在 Rust 看来，Thread 的 <em>LifeTime</em>（生命周期）会比调用它的函数的生命周期的长，如果不 <em>Move</em> 所有权，那么线程中数据就会在调用函数结束后释放掉变量的内存，导致线程中的数据无效。所以，这样的限制是很有必要的，但反过来想，一旦数据的所有权发生转移，那么多个线程并行修改同样数据的可能性也就不复存在。</p>
<h3 id="构建树状结构"><a href="#构建树状结构" class="headerlink" title="构建树状结构"></a>构建树状结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Entry &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    children: Vec&lt;Entry&gt; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn tree(path: &amp;Path) -&gt; Entry &#123;</span><br><span class="line">    Entry&#123;</span><br><span class="line">        name: path.file_name()</span><br><span class="line">            .and_then(|name| name.to_str())</span><br><span class="line">            .map_or(String::from(&quot;.&quot;), |str| String::from(str)),</span><br><span class="line">       </span><br><span class="line">        children: if path.is_dir() &#123;</span><br><span class="line">            children(path)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Vec::new()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然是树状结构，定义的结构体就是递归的。这里的<code>struct Entry &#123;&#125;</code>就是一种递归的结构。我想实现的树状结构大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry :: &#123;name, [child]&#125;</span><br><span class="line">child :: entry</span><br></pre></td></tr></table></figure>
<p>Rust 中没有显式的return，最后一个表达式的结果会被当成返回值，所以此处整个<code>Entry</code>结构体会被返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path.file_name()</span><br><span class="line"> .and_then(|name| name.to_str())</span><br><span class="line"> .map_or(String::from(&quot;.&quot;), |str| String::from(str)),</span><br></pre></td></tr></table></figure>
<p>这段代码看上去很复杂，但实现的功能其实很简单，目的是为了获取当前文件的文件名。那么逻辑为何如此绕呢？这是由于 Rust 中的多种字符串表示导致的问题，暂按不表。先去看看各个函数的定义。</p>
<p><strong>Path.file_name 的定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pub fn file_name(&amp;self) -&gt; Option&lt;&amp;OsStr&gt;</span><br></pre></td></tr></table></figure>
<p><code>and_then</code>是我们常见的<code>flat_map</code>操作在 Rust 中的命名，其目的是为了在两个<code>Option</code>之间实现转换。</p>
<p><strong>OsStr.to_str 的定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pub fn to_str(&amp;self) -&gt; Option&lt;&amp;str&gt;</span><br></pre></td></tr></table></figure>
<p>上面的<code>path.file_name().and_then(|name| name.to_str())</code>最终转变成了<code>Option&lt;&amp;str&gt;</code>，在其上调用<code>Option.map_or</code>方法并提供默认值：字符串<code>&quot;.&quot;</code>。为什么要提供默认值呢？这和<code>OsStr</code>到<code>Str</code>的转换密切相关，当我们传入参数<code>&quot;.&quot;</code>时，<code>Path.file_name</code>返回的其实是一个<code>None</code>。</p>
<p>构建了父级的树状结构，我们需要把子级的树状结构也一并完成，最终通过递归，构建出一棵内存中的目录树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn children(dir: &amp;Path) -&gt; Vec&lt;Entry&gt; &#123;</span><br><span class="line">    fs::read_dir(dir)</span><br><span class="line">        .expect(&quot;unable to read dir&quot;)</span><br><span class="line">        .into_iter()</span><br><span class="line">        .map(|e| e.expect(&quot;unable to get entry&quot;))</span><br><span class="line">        .filter(|e| is_not_hidden(&amp;e))</span><br><span class="line">        .map(|e| e.path())</span><br><span class="line">        .map(|e| tree(&amp;e))</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn is_not_hidden(entry: &amp;DirEntry) -&gt; bool &#123;</span><br><span class="line">    entry</span><br><span class="line">         .file_name()</span><br><span class="line">         .to_str()</span><br><span class="line">         .map(|s| !s.starts_with(&quot;.&quot;))</span><br><span class="line">         .unwrap_or(false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也存在挺多的转换操作，我们一一解释。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs::read_dir(dir).expect(&quot;unable to read dir&quot;)</span><br></pre></td></tr></table></figure>
<p>使用<code>expect</code>是因为<code>fs::read_dir</code>返回的是一个<code>Result&lt;ReadDir&gt;</code>，在其上调用<code>expect</code>会尝试解开其中的值，如果有错则会抛出错误。解开的结果类型是<code>ReadDir</code>，它是<code>io::Result&lt;DirEntry&gt;</code>的迭代器，也就是一个目录下的所有类目，可以在上面调用<code>into_iter()</code>创建出可以被消费的迭代器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.map(|e| e.expect(&quot;unable to get entry&quot;))</span><br><span class="line">.filter(|e| is_not_hidden(e))</span><br><span class="line">.map(|e| e.path())</span><br><span class="line">.map(|e| tree(&amp;e))</span><br></pre></td></tr></table></figure>

<p>接着，解开<code>Result&lt;DirEntry&gt;</code>之后，我们把隐藏文件过滤掉，因为<code>filter</code>接收的一个闭包，这个闭包的类型声明是<code>P: FnMut(&amp;Self::Item) -&gt; bool</code>，所以filter接收的所有元素都是引用类型，故调用时无需需声明成<code>is_not_hidden(&amp;e)</code>。</p>
<p>然后利用<code>e.path()</code>获取每个文件的全路径，并依次交给<code>tree</code>去递归构建。经过<code>tree</code>和<code>children</code>两个函数的交替递归，内存中的一棵目录树就被构建出来了。</p>
<p>有了内存中的树状结构，我们接下来就可以渲染这个结构了。具体的做法如下：</p>
<ol>
<li>对于第一层目录名，如果它是最后一个目录，则前缀修饰为<code>L_branch = &quot;└── &quot;</code>；反之，装饰成 <code>T_branch = &quot;├── &quot; </code>。</li>
<li>对于有子目录，如果是其父目录是父级最后一个目录，则前缀装饰为<code>SPACER   = &quot;    &quot;</code>；反之，前缀装饰成 <code>I_branch = &quot;│   &quot;</code>。</li>
</ol>
<h3 id="渲染树状结构"><a href="#渲染树状结构" class="headerlink" title="渲染树状结构"></a>渲染树状结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn render_tree(tree: &amp;Entry) -&gt; Vec&lt;String&gt; &#123;</span><br><span class="line">    let mut names = vec![tree.name]; // error</span><br><span class="line">    let children = &amp;tree.children;</span><br><span class="line">    let children: Vec&lt;_&gt; = children</span><br><span class="line">        .iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .map(|(i, child)| decorate(children.len() - 1 == i, render_tree(child)))</span><br><span class="line">        .flatten()</span><br><span class="line">        .collect();</span><br><span class="line">    </span><br><span class="line">    names.extend(children);</span><br><span class="line"></span><br><span class="line">    names</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会有编译错误，错误信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error[e0507]: cannot move out of `tree.name` which is behind a shared reference</span><br><span class="line">  --&gt; src/main.rs:48:26</span><br><span class="line">   |</span><br><span class="line">48 |     let mut names = vec![tree.name];</span><br><span class="line">   |                          ^^^^^^^^^ move occurs because `tree.name` has type `std::string::string`, which does not implement the `copy` trait</span><br></pre></td></tr></table></figure>
<p>由于<code>tree.name</code>不是标量类型（Scalar Type），它没有实现<code>copy</code> trait（见提示），又因为<code>tree</code>本身是复合类型（Compound Type），<code>tree.name</code>如果发生 <em>Move</em> 的话，包含它的<code>tree</code>就有问题了。为了避免发生这种情况，我们不得不去引用<code>&amp;tree.name</code>。但是一旦加上引用，又会出现类型不匹配的编译错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">59 |     names</span><br><span class="line">   |     ^^^^^ expected struct `std::string::String`, found reference</span><br><span class="line">      |</span><br><span class="line">         = note: expected type `std::vec::Vec&lt;std::string::String&gt;`</span><br><span class="line">                       found type `std::vec::Vec&lt;&amp;std::string::String&gt;`</span><br></pre></td></tr></table></figure>

<p>我们期待的是<code>Vec&lt;String&gt;</code>而不是<code>Vec&lt;&amp;String&gt;</code>，所以需要重新构建出一个<code>String</code>出来。可以使用<code>String::from(&amp;String)</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mut names = vec![String::from(&amp;tree.name)];</span><br></pre></td></tr></table></figure>
<p>这样修改下来，才能保证编译完全通过。但事实上，Rust 给我们提供了一个更加便捷的写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mut names = vec![tree.name.to_owned()]</span><br></pre></td></tr></table></figure>
<p>使用<code>to_owned()</code>表示重新拷贝了一份数据，和重新构建一个<code>String</code>出来别无二致。</p>
<h3 id="组合调用"><a href="#组合调用" class="headerlink" title="组合调用"></a>组合调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::env;</span><br><span class="line">use std::path::Path;</span><br><span class="line">use std::fs::&#123;self, DirEntry&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let args: Vec&lt;String&gt; = env::args().collect();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, render_tree(&amp;tree(Path::new(&amp;args[1]))).join(&quot;\n&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>render_tree</code> 返回的是<code>Vec&lt;String&gt;</code>，所以为了打印出来，我们将所有元素用<code>&quot;\n&quot;</code> <code>join</code>到一起。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── target</span><br><span class="line">│   └── debug</span><br><span class="line">│       ├── tree</span><br><span class="line">│       ├── incremental</span><br><span class="line">│       │   ├── tree-emhx2ztsyouq</span><br><span class="line">│       │   │   ├── s-fg6t1j15rq-rcdkil.lock</span><br><span class="line">│       │   │   └── s-fg6t1j15rq-rcdkil-2guhg58bq8usk</span><br><span class="line">│       │   │       ├── 2y5hmosay7v21uaa.o</span><br><span class="line">│       │   │       ├── 3bc30huj642htvsl.o</span><br><span class="line">│       │   │       ├── os4trg3bosufhmz.o</span><br><span class="line">│       │   │       ├── 24gploi4fp7jtlzq.o</span><br><span class="line">│       │   │       ├── query-cache.bin</span><br><span class="line">│       │   │       ├── dep-graph.bin</span><br><span class="line">│       │   │       ├── 4x450fwi8c4bpcw1.o</span><br><span class="line">│       │   │       └── work-products.bin</span><br><span class="line">│       │   └── tree-145pnmzdafxnt</span><br><span class="line">│       │       ├── s-fg7zukct1x-1q6vl1v.lock</span><br><span class="line">│       │       └── s-fg7zukct1x-1q6vl1v-2bl7ybv3bt926</span><br><span class="line">│       │           ├── 1hr1ye57pnkjmrbq.o</span><br><span class="line">│       │           ├── 27h2hp0z2xow1ues.o</span><br><span class="line">│       │           ├── 5ed0wukafi4fahkg.o</span><br><span class="line">│       │           ├── 2f0ihwts74qcmxow.o</span><br><span class="line">│       │           ├── 330o0ei85brt7kr4.o</span><br><span class="line">│       │           ├── 4v9apptkodzb8xa6.o</span><br><span class="line">│       │           ├── 1g9e2frs3e2z69pv.o</span><br><span class="line">│       │           ├── 37b06wzocgbel481.o</span><br><span class="line">│       │           ├── 4l05de8rviyudi4f.o</span><br><span class="line">│       │           ├── h6fn9swczh7498b.o</span><br><span class="line">│       │           ├── 316xpau62mt4is8d.o</span><br><span class="line">│       │           ├── 5ekvjec2kf4lmbtt.o</span><br><span class="line">│       │           ├── 1futuyfy32uf6fso.o</span><br><span class="line">│       │           ├── 2h1ucudwsaw3ps8a.o</span><br><span class="line">│       │           ├── 1gotohk3wwy2f6dy.o</span><br><span class="line">│       │           ├── 3b9tgf3uo9qj9m4l.o</span><br><span class="line">│       │           ├── 11nu5z6vt7pkotko.o</span><br><span class="line">│       │           ├── 1iwt54u59d6ic7px.o</span><br><span class="line">│       │           ├── 2knnbzs842y8uh0j.o</span><br><span class="line">│       │           ├── 3ifvzvvypros5ggf.o</span><br><span class="line">│       │           ├── 2z2hec5yokv1i4dp.o</span><br><span class="line">│       │           ├── ya9r48v2sak0pg6.o</span><br><span class="line">│       │           ├── 155em2p8h2hm19ng.o</span><br><span class="line">│       │           ├── 32v7dlio50845m8.o</span><br><span class="line">│       │           ├── 4c1hc1pxl75vi07x.o</span><br><span class="line">│       │           ├── 2yqijaid0vje1zn1.o</span><br><span class="line">│       │           ├── 4vjgrzm4xto1375t.o</span><br><span class="line">│       │           ├── 21iztlljbl6euh9m.o</span><br><span class="line">│       │           ├── 20v9k1fk8kja961x.o</span><br><span class="line">│       │           ├── 4z53k2t8wxm10fyq.o</span><br><span class="line">│       │           ├── bhyzck3ll360qet.o</span><br><span class="line">│       │           ├── 1y3hdwm9ww9b9y5i.o</span><br><span class="line">│       │           ├── 3c44aga3rejf73f6.o</span><br><span class="line">│       │           ├── rj0yv7mdi9un1aq.o</span><br><span class="line">│       │           ├── 50x9vm1j7pl93o9s.o</span><br><span class="line">│       │           ├── 217lokaaxwdhlrx9.o</span><br><span class="line">│       │           ├── 4wnp20b81q6iaxux.o</span><br><span class="line">│       │           ├── 3r82h5ttm93ejtxf.o</span><br><span class="line">│       │           ├── 3ot3q95g45ci1vo6.o</span><br><span class="line">│       │           ├── query-cache.bin</span><br><span class="line">│       │           ├── 39sf80jvxavwpxo3.o</span><br><span class="line">│       │           ├── 8oeuahm3962nobh.o</span><br><span class="line">│       │           ├── cik7i0re2dlsxhk.o</span><br><span class="line">│       │           ├── 1waoie6zpkzqj4ct.o</span><br><span class="line">│       │           ├── 19luckbhcaquztt8.o</span><br><span class="line">│       │           ├── 3g7vkdnj0ai0qhcm.o</span><br><span class="line">│       │           ├── 1rp337sq8mpirnfu.o</span><br><span class="line">│       │           ├── 1b3x8y2m27htwxg6.o</span><br><span class="line">│       │           ├── 41wp4wr46haq7yo6.o</span><br><span class="line">│       │           ├── gupfi67uepu20cm.o</span><br><span class="line">│       │           ├── dep-graph.bin</span><br><span class="line">│       │           ├── 5btmoqde9gzs48ku.o</span><br><span class="line">│       │           ├── 4vmtr5p2n2ar0hfj.o</span><br><span class="line">│       │           ├── work-products.bin</span><br><span class="line">│       │           ├── 2jd13r5ry01uwce0.o</span><br><span class="line">│       │           ├── 54om8xu4dcwmt36o.o</span><br><span class="line">│       │           ├── 3pjvdh4zm61wtvac.o</span><br><span class="line">│       │           ├── 21mzfl756r7eb753.o</span><br><span class="line">│       │           ├── 57o4bjq3o18zq3ji.o</span><br><span class="line">│       │           ├── 4lh6qwni3j9cdda6.o</span><br><span class="line">│       │           └── 4rj8jramt231qg09.o</span><br><span class="line">│       ├── native</span><br><span class="line">│       ├── tree-e27a55060278e1c5.dSYM</span><br><span class="line">│       │   └── Contents</span><br><span class="line">│       │       ├── Resources</span><br><span class="line">│       │       │   └── DWARF</span><br><span class="line">│       │       │       └── tree-e27a55060278e1c5</span><br><span class="line">│       │       └── Info.plist</span><br><span class="line">│       ├── tree.dSYM</span><br><span class="line">│       │   └── Contents</span><br><span class="line">│       │       ├── Resources</span><br><span class="line">│       │       │   └── DWARF</span><br><span class="line">│       │       │       └── tree-5fa2575d1085e7f2</span><br><span class="line">│       │       └── Info.plist</span><br><span class="line">│       ├── tree-e27a55060278e1c5.d</span><br><span class="line">│       ├── examples</span><br><span class="line">│       ├── tree-e27a55060278e1c5</span><br><span class="line">│       ├── deps</span><br><span class="line">│       │   ├── tree-5fa2575d1085e7f2.dSYM</span><br><span class="line">│       │   │   └── Contents</span><br><span class="line">│       │   │       ├── Resources</span><br><span class="line">│       │   │       │   └── DWARF</span><br><span class="line">│       │   │       │       └── tree-5fa2575d1085e7f2</span><br><span class="line">│       │   │       └── Info.plist</span><br><span class="line">│       │   ├── tree-5fa2575d1085e7f2.d</span><br><span class="line">│       │   ├── tree-e27a55060278e1c5.dSYM</span><br><span class="line">│       │   │   └── Contents</span><br><span class="line">│       │   │       ├── Resources</span><br><span class="line">│       │   │       │   └── DWARF</span><br><span class="line">│       │   │       │       └── tree-e27a55060278e1c5</span><br><span class="line">│       │   │       └── Info.plist</span><br><span class="line">│       │   ├── tree-5fa2575d1085e7f2</span><br><span class="line">│       │   ├── tree-e27a55060278e1c5.d</span><br><span class="line">│       │   └── tree-e27a55060278e1c5</span><br><span class="line">│       ├── build</span><br><span class="line">│       └── tree.d</span><br><span class="line">├── Cargo.lock</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习下来的一些主观感觉是 Rust 中的概念繁杂，有些地方的设计确实让人有些迷惑。再加上类型众多（如：OsStr, String），代码很难通过直觉判断写出，需要大量查阅文档才能让编译器消停。所以学习曲线相对陡峭。</p>
<p>不过，语言约束的越多，某种程度上讲，对于程序员而言却是福音。<em>If it compiles, then it works.</em> 的哲学理念在前。学习道阻且长，努力加餐饭。</p>
<hr>
<p><strong>提示</strong><br>一般标量类型都实现了<code>copy</code> trait.</p>
<ul>
<li>所有的整，如：u32</li>
<li>布尔类型，如：true 或 false</li>
<li>字符类型，如：char</li>
<li>浮点数类型，如：f64</li>
<li>当且仅当所有元素都是Copy的元组，如：(i32, i32)是Copy，但是(i32, String)就不是Copy的。</li>
</ul>
<hr>
<p>于2019年9月22日</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链DApp开发环境 embark 初探</title>
    <url>/2019/05/07/try-embark/</url>
    <content><![CDATA[<h2 id="embark是什么"><a href="#embark是什么" class="headerlink" title="embark是什么"></a>embark是什么</h2><p><a href="http://embark.status.im/">embark</a>是一款特定于Ethereum区块链平台的DApp开发环境，辅助开发者创建、构建编译、测试和部署DApp，可无缝集成计算（EVM）、存储（IPFS&#x2F;Swarm）和网络（Whisper）资源。</p>
<h2 id="embark的便捷之处"><a href="#embark的便捷之处" class="headerlink" title="embark的便捷之处"></a>embark的便捷之处</h2><p>在尝试embark并和truffle框架进行对比之后，我总结以下几个方面的优势：功能全面，上手迅速，反馈快速，可视化程度高，合约可调试。</p>
<h3 id="功能全面"><a href="#功能全面" class="headerlink" title="功能全面"></a>功能全面</h3><p>正如embark<a href="https://embark.status.im/docs/overview.html">概览</a>所言，embark并不仅仅是一款只提供构建编译、测试部署功能的开发工具，还是一整套的开发环境。它包含了智能合约自动部署，客户端(UI)开发，测试，DApp分布式托管（IPFS&#x2F;Swarm），点对点通信（Whipser）和组件监控、在线IDE及代码调试（Cockpit）等功能。</p>
<p>如果和truffle框架比较，embark几乎包含了它提供的所有功能。不过，embark缺失了truffle在migration方面的功能，基于对不可变基础设施的考量，embark有必要拥抱这项标准实践。</p>
<p>embark考虑了单独开发智能合约的可能性，所以允许开发者在创建项目时只创建智能合约项目结构，通过启用<code> --contracts-only</code>选项。而且在构建编译时，也可以指定<code>embark build --contracts</code>命令单独构建智能合约。</p>
<h3 id="上手迅速"><a href="#上手迅速" class="headerlink" title="上手迅速"></a>上手迅速</h3><p>这个维度虽然有点主观，但是很值得拿出来说。一般学习新的工具，需要花很多时间看文档学习基本概念和操作流程，最恼火的就是熟悉各种配置项，当你左支右绌，手忙脚乱让工具程序跑起来，除了浪费时间，也侧面证明该工具不够成熟、对开发者不友好。</p>
<p>很意外的是，本来以为这么一个大而全的开发环境设置起来一定得耗费不少时间，结果却是除了用<code>yarn global add embark</code>报出一个compiler和yarn不兼容后，改成了<code>npm install -g embark</code>安装，就再没有特别恼人的问题出现了。</p>
<hr>
<p><strong>注意：</strong><br>上面的安装错误其实是因为embark对于yarn的版本有一定的要求，从embark源码中可以得到如下前置条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;engines&quot;: &#123;</span><br><span class="line">  &quot;node&quot;: &quot;&gt;=8.12.0&quot;,</span><br><span class="line">  &quot;npm&quot;: &quot;&gt;=6.4.1&quot;,</span><br><span class="line">  &quot;yarn&quot;: &quot;&gt;=1.12.3&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>我当前的yarn版本是<em>1.6.0</em>，使用<code>brew upgrade yarn</code>升级到<em>1.15.2</em>就可以全局安装了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn global add embark</span><br><span class="line">...</span><br><span class="line">embark version</span><br><span class="line">4.0.2</span><br></pre></td></tr></table></figure>

<hr>
<p><code>embark run</code>会启动一个命令行中可视化界面，里面会告诉你当前Dapp的状态，包括智能合约是否部署，哪些组件服务可用，最最重要的是它会告诉你接下来你该做什么！在<em>Logs</em>视窗中，embark试图告诉你开发环境确实哪些依赖服务，比如geth节点没有启动（事实上，可以用gananche-cli代替），ipfs节点未侦测到，Cockpit Web UI所在端口还有Dapp服务的入口等等。而console视窗则是命令交互入口，一条<code>help</code>命令就能展示很多有用信息。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-f683bed1ef30c0e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dashboard"><br>以上这些信息都无需查看文档便可以获得，个人觉得从尝试中学习是特别有趣的事情。</p>
<p>我一般拿从零到写出第一行程序的时间作为上手快慢的标准。这行程序是用来试验，未必得手写，所以我选用了truffle自带的样例<code>MetaCoin.sol</code>和<code>ConvertLib.sol</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ConvertLib.sol</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">library ConvertLib&#123;</span><br><span class="line">  function convert(uint amount,uint conversionRate) public pure returns (uint convertedAmount) &#123;</span><br><span class="line">    return amount * conversionRate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// MetaCoin.sol</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line">import &quot;./ConvertLib.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MetaCoin &#123;</span><br><span class="line">  mapping (address =&gt; uint) balances;</span><br><span class="line"></span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _value);</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    balances[msg.sender] = 10001;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendCoin(address receiver, uint amount) public returns(bool sufficient) &#123;</span><br><span class="line">    if (balances[msg.sender] &lt; amount) return false;</span><br><span class="line">    balances[msg.sender] -= amount;</span><br><span class="line">    balances[receiver] += amount;</span><br><span class="line">    emit Transfer(msg.sender, receiver, amount);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getBalanceInEth(address addr) public view returns(uint) &#123;</span><br><span class="line">    return ConvertLib.convert(getBalance(addr), 4);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getBalance(address addr) public view returns(uint) &#123;</span><br><span class="line">    return balances[addr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当把这两个智能合约文件放到项目根目录下<em>contracts&#x2F;<em>目录中后，合约代码被自动编译，并在</em>Contracts</em>视窗中展示出来，状态为<strong>Deployed</strong>，这表明智能合约已经被部署到区块链网络里。之后，我进入Cockpit Web UI，惊喜地发现这个服务俨然就是一个高配版的<a href="https://etherscan.io/">etherscan.io</a>，通过它不仅可以查看部署之后的合约，甚至还可以调用合约方法。</p>
<p>估算下来，我用embark写完第一行代码的时间基本可以忽略不计。</p>
<h3 id="反馈快速"><a href="#反馈快速" class="headerlink" title="反馈快速"></a>反馈快速</h3><p>写程序都希望其可行性能被快速验证，因为只有这样才能方便快速地迭代出正确功能的程序。我所知道的前端开发者是把这个过程做到极致的群体，比如Liveloading；embark对于智能合约也提供了一致的功能。当修改合约文件并保存时，embark会自动检测变更同时重新编译再部署，这个过程非常快速（当然，embark对于哪些修改的合约需要重新部署是有一定限制的，而且据我观察，这里面有些潜在的bug，比如修改合约constructor中的内容就不会触发重新构建，即便用<code>embark reset</code>也不行，这个和文档的描述有些出入，值得花时间研究下）。</p>
<p>自动重新构建和部署合约对程序员的效率提升很有帮助，但是无法快速验证同样达不到目的。所幸的是，embark不仅提供了Cockpit这样的可视化工具辅助验证合约的正确性，而且还提供embark console，在console中可以调用部署合约的实例，比如：输入<code>Embark (Development) &gt; MetaCoin &lt;ENTER&gt;</code>就能获取部署好的实例，有了合约实例就可以调用其上的方法进行数据校验。</p>
<p>同样重要的是，embark支持js和sol版本测试，我可以像使用truffle一样使用TDD的方式开发DApp了。</p>
<h3 id="可视化程度高"><a href="#可视化程度高" class="headerlink" title="可视化程度高"></a>可视化程度高</h3><p>当在终端中运行<code>embark run</code>时，embark会自动进入<a href="https://embark.status.im/docs/dashboard.html">可视化界面</a>（dashboard）。这里面监控的信息会实时告诉你DApp开发的状态。除此之外，embark还提供了DApp的Web server，Cockpit Web UI页面，这些绝对是开发DApp极大的助力。</p>
<p>如果不想使用dashboard，可以通过<code>embark run --nodashboard</code>禁用。不过，根据我的经验，禁用dashboard的结果是没法直接拿到进入Cockpit的访问token，还需要运行<code>embark console</code>进入命令行单独获取。</p>
<p>从上面这点来看，embark在组件化方面做得相当出色，虽然功能大而全，但是并没有限制你删减不必要的组件、独立启用感兴趣的组件</p>
<h3 id="合约可调试"><a href="#合约可调试" class="headerlink" title="合约可调试"></a>合约可调试</h3><p>调试合约在以前的开发过程中还是比较难的，不过借助于Cockpit，embark也提供了在线调试的能力。Cockpit内置一个编辑器，它和本地的开发目录保持一致，该编辑器就提供了debug功能。另外，进入Explorer页，我们甚至可以对某次的tx进行debug验证这次合约调用的真实数据流转情况。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-c8292962071caab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Explorer &amp; Debug"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总的来说，embark是一款优秀的区块链开发环境。相比较truffle的专注于合约工程化的努力，embark的功能更加丰富，而且各组件组合性很强。对于开发者而言，快速开发出DApp才是真的诉求，而embark显然在这一方面具备很大的优势。</p>
<h2 id="怎么快速玩转embark"><a href="#怎么快速玩转embark" class="headerlink" title="怎么快速玩转embark"></a>怎么快速玩转embark</h2><p>工具版本号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn --version</span><br><span class="line">1.15.2</span><br><span class="line">npm -v</span><br><span class="line">6.4.1</span><br><span class="line">node -v</span><br><span class="line">v10.15.3</span><br><span class="line">embark version</span><br><span class="line">4.0.2</span><br></pre></td></tr></table></figure>
<h3 id="快速使用DApp"><a href="#快速使用DApp" class="headerlink" title="快速使用DApp"></a>快速使用DApp</h3><p>embark默认开发时都是 development 环境，为了对接正确的ganache-cli（模拟以太坊客户端）端口，我们需要修改<code>config/contract.js</code>文件中<code>development/port</code>到ganache-cli默认的8545端口。</p>
<p>先执行<code>embark build  --pipeline development</code>，然后启动<code>embark run</code>，此时就可以在<code>http://localhost:8000</code>查看DApp的界面了。</p>
<h3 id="IPFS分布式托管"><a href="#IPFS分布式托管" class="headerlink" title="IPFS分布式托管"></a>IPFS分布式托管</h3><p>首先得安装IPFS的客户端，然后运行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipfs init</span><br><span class="line">ipfs daemon</span><br><span class="line">...</span><br><span class="line">Daemon is ready</span><br></pre></td></tr></table></figure>
<p>当ipfs启动完成后，embark的dashboard会显示ipfs节点已连接。此时执行<code>embark upload</code>，构建出来的<em>dist</em>目录就会被分发到ipfs网络，然后就可以通过内容寻址（content-addressed）的方式访问这个静态网站了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/217988-8007519cf8fff2e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IPFS distribution of static pages"></p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>embark</tag>
        <tag>devOps</tag>
      </tags>
  </entry>
</search>
